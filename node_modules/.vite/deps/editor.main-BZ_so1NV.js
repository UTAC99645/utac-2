import { $ as createElement, $a as addDisposableListener, $c as isNumber, $i as transparent, $n as lengthAdd, $o as disposableTimeout, $r as editorInlayHintBackground, $s as Lazy, $t as MarkdownString, A as HC_BLACK_THEME_NAME, Aa as ThemeIcon, Ac as combinedDisposable, Ai as inputValidationInfoBorder, An as isModelDecorationInString, Ao as SimpleKeybinding, Ar as InMemoryClipboardMetadataManager, As as InvisibleCharacters, At as IKeybindingService, B as WorkbenchTreeElementCanExpand, Ba as Action, Bc as onUnexpectedExternalError, Bi as overviewRulerFindMatchForeground, Bn as dirname, Bo as SearchParams, Br as editorFindMatchBorder, Bs as format, Bt as IDialogService, C as isDiffEditor, Ca as IMenuService, Cc as Emitter$1, Ci as inputBackground, Cl as isMacintosh, Cn as Sash, Co as FileAccess, Cr as editorBracketMatchBackground, Cs as createDecorator, Ct as ToggleHighContrastNLS, D as IStorageService, Da as SubmenuItemAction, Dc as DisposableStore, Di as inputValidationErrorBorder, Dl as language, Dn as Severity, Do as sanitize, Dr as ghostTextForeground, Ds as PixelRatio, Dt as toWorkspaceIdentifier, E as TextModelCancellationTokenSource, Ea as MenuRegistry, Ec as Disposable, Ei as inputValidationErrorBackground, El as isWindows, En as INotificationService, Eo as removeHook, Er as ghostTextBorder, Es as createFastDomNode, Et as isSingleFolderWorkspaceIdentifier, F as Extensions, Fa as ContextKeyExpr, Fc as CancellationError, Fi as listFocusHighlightForeground, Fn as TextModel, Fo as TokenMetadata, Fr as editorActiveLinkForeground, Fs as containsRTL, Ft as ILanguageFeatureDebounceService, G as WholeWordsToggle, Ga as IMarkerDecorationsService, Gc as unicodeHighlightConfigKeys, Gi as quickInputListFocusBackground, Gn as originalFSPath, Go as AsyncIterableObject, Gr as editorForeground, Gs as isLowSurrogate, Gt as IContextMenuService, H as FindInput, Ha as Separator, Hc as EditorFontLigatures, Hi as problemsErrorIconForeground, Hn as extname, Ho as CharacterSet, Hr as editorFindMatchHighlightBorder, Hs as isBasicASCII, Ht as IProgressService, I as IListService, Ia as IContextKeyService, Ic as canceled, Ii as listHighlightForeground, In as IUndoRedoService, Io as ILanguageFeaturesService, Ir as editorBackground, Is as containsUppercaseCharacter, It as IOpenerService, J as SplitView, Ja as $, Jc as mixin, Ji as registerColor, Jn as hasDriveLetter, Jo as IdleValue, Jr as editorHoverForeground, Js as lastNonWhitespaceIndex, Jt as registerIcon, K as Toggle, Ka as alert, Kc as cloneAndChange, Ki as quickInputListFocusForeground, Kn as relativePath, Ko as DeferredPromise, Kr as editorHoverBackground, Ks as isLowerAsciiLetter, Kt as IContextViewService, L as WorkbenchAsyncDataTree, La as RawContextKey, Lc as illegalArgument, Li as minimapFindMatch, Ln as DataUri, Lo as ILogService, Lr as editorErrorBorder, Ls as escape, Lt as NullOpenerService, M as VS_DARK_THEME_NAME, Ma as themeColorFromId, Mc as isDisposable, Mi as inputValidationWarningBackground, Mn as tokenizeToString, Mo as renderViewLine, Mr as DynamicCssRules, Ms as commonSuffixLength, Mt as editorConfigurationBaseNode, N as VS_LIGHT_THEME_NAME, Na as isDark, Nc as toDisposable, Ni as inputValidationWarningBorder, Nn as ModelDecorationInjectedTextOptions, No as LineDecoration, Nr as activeContrastBorder, Ns as compare, Nt as IBulkEditService, O as WillSaveStateReason, Oa as isIMenuItem, Oc as MutableDisposable, Oi as inputValidationErrorForeground, Ol as localize, On as severity_default, Oo as StandardMouseEvent, Or as overviewRulerRangeHighlight, Os as isFirefox, Ot as ILabelService, P as IQuickInputService, Pa as isHighContrast, Pc as once, Pi as inputValidationWarningForeground, Pn as ModelDecorationOptions, Po as LineTokens, Pr as contrastBorder, Ps as compareIgnoreCase, Pt as ResourceEdit, Q as HistoryInputBox, Qa as ModifierKeyEmitter, Qc as isArray, Qi as toolbarHoverBackground, Qn as DenseKeyProvider, Qo as createCancelablePromise, Qr as editorInfoForeground, Qs as trim, Qt as BaseActionViewItem, R as WorkbenchListFocusContextKey, Ra as CommandsRegistry, Rc as isCancellationError, Ri as minimapSelectionOccurrenceHighlight, Rn as basename, Ro as ITextResourceConfigurationService, Rr as editorErrorForeground, Rs as escapeRegExpCharacters, Rt as extractSelection, S as isCodeEditor, Sa as KeybindingsRegistry, Sc as CancellationTokenSource$1, Si as inputActiveOptionForeground, Sl as isLinux, Sn as OrthogonalEdge, So as trackFocus, Sr as normalizeIndentation, Ss as IInstantiationService, St as QuickOutlineNLS, T as EditorStateCancellationTokenSource, Ta as MenuItemAction, Tc as StopWatch, Ti as inputForeground, Tl as isWeb, Tn as CodeEditorWidget, To as addHook, Tr as ghostTextBackground, Ts as applyFontInfo, Tt as WORKSPACE_EXTENSION, U as CaseSensitiveToggle, Ua as SubmenuAction, Uc as EditorOptions, Ui as problemsInfoIconForeground, Un as isEqual, Uo as LcsDiff, Ur as editorFindRangeHighlight, Us as isFalsyOrWhitespace, Ut as Progress, V as IsWindowsContext, Va as ActionRunner, Vc as EDITOR_FONT_DEFAULTS, Vi as overviewRulerSelectionHighlightForeground, Vn as extUri, Vo as getMapForWordSeparators, Vr as editorFindMatchHighlight, Vs as getLeadingWhitespace, Vt as IEditorProgressService, W as RegexToggle, Wa as ITextModelService, Wc as inUntrustedWorkspace, Wi as problemsWarningIconForeground, Wn as joinPath, Wo as hash, Wr as editorFindRangeHighlightBorder, Ws as isHighSurrogate, Wt as IClipboardService, X as IconLabel, Xa as EventHelper, Xc as assertNever, Xi as textLinkActiveForeground, Xn as LanguageAgnosticBracketTokens, Xo as TimeoutTimer, Xr as editorHoverStatusBarBackground, Xs as splitLines, Xt as ActionBar, Y as List, Ya as Dimension, Yc as assertIsDefined, Yi as textCodeBlockBackground, Yn as parseDocument, Yo as RunOnceScheduler, Yr as editorHoverHighlight, Ys as noBreakWhitespace, Yt as widgetClose, Z as HighlightedLabel, Za as EventType$1, Zc as assertType, Zi as textLinkForeground, Zn as TextBufferTokenizer, Zo as createCancelableAsyncIterable, Zr as editorInfoBorder, Zs as stripWildcards, Zt as ActionViewItem, _ as formatDocumentRangesWithSelectedProvider, _a as registerEditorContribution, _c as basename$1, _i as focusBorder, _l as quickSelect, _n as LRUCache, _o as prepend, _r as MoveOperations, _s as IndentAction, _t as AccessibilityHelpNLS, a as MarkerSeverity, aa as EventType, ac as InlayHintKind, ai as editorLightBulbAutoFixForeground, al as binarySearch, an as stripIcons, ao as createCSSRule, ar as ScrollableElement, as as NullState, at as SEMANTIC_HIGHLIGHTING_SETTING_ID, b as FormattingEdit, ba as registerMultiEditorAction, bc as KeyChord, bi as inputActiveOptionBackground, bl as OS, bn as DataTransfers, bo as show, br as ReplaceCommandThatSelectsText, bs as OverviewRulerLane, bt as QuickCommandNLS, c as Range, ca as IAccessibilityService, cc as SymbolKinds, ci as editorSelectionHighlight, cl as distinct, cn as anyScore, co as getComputedStyle, cr as EditorContextKeys, cs as ILanguageConfigurationService, ct as hasDocumentRangeSemanticTokensProvider, d as Token, da as EditorCommand, dc as CSSIcon, di as editorWarningForeground, dl as findLast, dn as fuzzyScoreGracefulAggressive, do as getTopLeftOffset, dr as getIndentMetadata, ds as Mimes, dt as IMarkerService, ea as widgetShadow, ec as CompletionItemInsertTextRule, ei as editorInlayHintForeground, el as isObject, en as escapeDoubleQuotes, eo as addStandardDisposableGenericMouseDownListener, er as lengthGetColumnCountIfZeroLineCount, es as first, et as renderFormattedText, f as Uri, fa as EditorExtensionsRegistry, fc as Codicon, fi as editorWidgetBackground, fl as findMaxBy, fn as matchesContiguousSubString, fo as getTotalWidth, fr as ShiftCommand, fs as Registry, ft as MarkerSeverity$1, g as alertFormattingEdits, ga as registerEditorCommand, gc as URI, gi as errorForeground, gl as numberComparator, gn as or, go as isInShadowDOM, gr as WordPartOperations, gs as createStringBuilder, gt as IWorkspaceTrustManagementService, h as languages, ha as registerEditorAction, hc as Position$1, hi as editorWidgetResizeBorder, hl as isNonEmptyArray, hn as matchesWords, ho as isInDOM, hr as WordOperations, hs as IConfigurationService, ht as attachListStyler, i as KeyMod, ia as GlobalPointerMoveMonitor, ic as FoldingRangeKind, ii as editorInlayHintTypeForeground, il as asArray, in as markdownEscapeEscapedIcons, io as clearNode, ir as DomScrollableElement, is as IModelService, it as renderLabelWithIcons, j as HC_LIGHT_THEME_NAME, ja as registerThemingParticipant, jc as dispose, ji as inputValidationInfoForeground, jn as isModelDecorationVisible, jo as RenderLineInput, jr as CursorColumns, js as commonPrefixLength, jt as EditOperation, k as IStandaloneThemeService, ka as IThemeService, kc as RefCountedDisposable, ki as inputValidationInfoBackground, kn as isModelDecorationInComment, ko as StandardKeyboardEvent, kr as CopyOptions, ks as isStandalone, kt as UILabelProvider, l as Selection, la as TabFocus, lc as TokenizationRegistry, li as editorSelectionHighlightBorder, ll as equals, ln as createMatches, lo as getDomNodePagePosition, lr as TypeOperations, ls as PLAINTEXT_LANGUAGE_ID, lt as toMultilineTokens2, m as editor_api_exports, ma as MultiEditorAction, mc as Range$1, mi as editorWidgetForeground, ml as isFalsyOrEmpty, mn as matchesSubString, mo as hookDomPurifyHrefAndSrcSanitizer, mr as CursorMoveCommands, ms as ILanguageService, mt as attachBadgeStyler, n as Emitter, na as HSVA, nc as CompletionItemKinds, ni as editorInlayHintParameterForeground, nl as isUndefined, nn as parseHrefAndDimensions, no as append, nr as countEOL, ns as runWhenIdle, nt as defaultGenerator, o as MarkerTag, oa as Gesture, oc as InlineCompletionTriggerKind, oi as editorLightBulbForeground, ol as coalesce, on as FuzzyScore, oo as createStyleSheet, or as Widget, os as nullTokenize, ot as isSemanticColoringEnabled, p as editor, pa as MultiCommand, pc as Selection$1, pi as editorWidgetBorder, pl as groupBy, pn as matchesPrefix, po as hide, pr as getEnterAction, ps as registerSingleton, pt as parse, q as Sizing, qa as status, qc as deepClone, qi as quickInputListFocusIconForeground, qn as resolvePath, qo as Delayer, qr as editorHoverBorder, qs as isUpperAsciiLetter, qt as IEditorWorkerService, r as KeyCode, ra as RGBA, rc as DocumentHighlightKind, ri as editorInlayHintTypeBackground, rl as withNullAsUndefined, rn as removeMarkdownEscapes, ro as asCSSUrl, rr as computeIndentLevel, rs as timeout, rt as CountBadge, s as Position, sa as CONTEXT_ACCESSIBILITY_MODE_ENABLED, sc as SignatureHelpTriggerKind, si as editorSelectionBackground, sl as compareBy, sn as FuzzyScoreOptions, so as getClientArea, sr as CoreEditingCommands, ss as nullTokenizeEncoded, st as getDocumentRangeSemanticTokens, t as CancellationTokenSource, ta as Color, tc as Command, ti as editorInlayHintParameterBackground, tl as isString, tn as isEmptyMarkdownString, to as addStandardDisposableListener, tr as lengthZero, ts as raceCancellation, tt as IdGenerator, u as SelectionDirection, ua as EditorAction, uc as isLocationLink, ui as editorWarningBorder, ul as findFirstInSorted, un as fuzzyScore, uo as getShadowRoot, ur as getGoodIndentForLine, us as Extensions$1, ut as IMarkerData, v as formatDocumentWithSelectedProvider, va as registerInstantiatedEditorAction, vc as dirname$1, vi as foreground, vl as LinkedList, vn as ResourceMap, vo as removeCSSRulesContainingSelector, vr as ReplaceCommand, vs as InjectedTextCursorStops, vt as GoToLineNLS, w as EditorState, wa as MenuId, wc as Event, wi as inputBorder, wl as isNative, wn as DomEmitter, wo as Schemas, wr as editorBracketMatchBorder, ws as EditorZoom, wt as IWorkspaceContextService, x as getCodeEditor, xa as ITelemetryService, xc as CancellationToken, xi as inputActiveOptionBorder, xl as isIOS, xn as StableEditorScrollState, xo as size, xr as CursorState, xs as ICodeEditorService, xt as QuickHelpNLS, y as getOnTypeFormattingEdits, ya as registerModelAndPositionCommand, yc as sep, yi as iconForeground, yl as Iterable, yn as TernarySearchTree, yo as reset, yr as ReplaceCommandThatPreservesSelection, ys as MinimapPosition, yt as InspectTokensNLS, z as WorkbenchTreeElementCanCollapse, za as ICommandService, zc as onUnexpectedError, zi as oneOf, zn as basenameOrAuthority, zo as UnicodeTextModelHighlighter, zr as editorFindMatch, zs as firstNonWhitespaceIndex, zt as clamp } from "./editor.api-CwculVLh.js";
import "./monaco.contribution-B9iDpr95.js";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/message/browser/messageController.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/media/action.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/lightBulbWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/media/peekViewWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/browser/zoneWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/media/gotoErrorWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/media/suggest.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameInputField.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.css";
import "/data/data/com.termux/files/home/utac_2/node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.css";

//#region node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$3 = Object.getOwnPropertyNames;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __copyProps$3 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$3(from)) if (!__hasOwnProp$3.call(to, key) && key !== except) __defProp$3(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$3(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport$3 = (target, mod, secondTarget) => (__copyProps$3(target, mod, "default"), secondTarget && __copyProps$3(secondTarget, mod, "default"));
var monaco_editor_core_exports$3 = {};
__reExport$3(monaco_editor_core_exports$3, editor_api_exports);
var languageDefinitions = {};
var lazyLanguageLoaders = {};
var LazyLanguageLoader = class {
	static getOrCreate(languageId) {
		if (!lazyLanguageLoaders[languageId]) lazyLanguageLoaders[languageId] = new LazyLanguageLoader(languageId);
		return lazyLanguageLoaders[languageId];
	}
	_languageId;
	_loadingTriggered;
	_lazyLoadPromise;
	_lazyLoadPromiseResolve;
	_lazyLoadPromiseReject;
	constructor(languageId) {
		this._languageId = languageId;
		this._loadingTriggered = false;
		this._lazyLoadPromise = new Promise((resolve, reject) => {
			this._lazyLoadPromiseResolve = resolve;
			this._lazyLoadPromiseReject = reject;
		});
	}
	load() {
		if (!this._loadingTriggered) {
			this._loadingTriggered = true;
			languageDefinitions[this._languageId].loader().then((mod) => this._lazyLoadPromiseResolve(mod), (err) => this._lazyLoadPromiseReject(err));
		}
		return this._lazyLoadPromise;
	}
};
function registerLanguage(def) {
	const languageId = def.id;
	languageDefinitions[languageId] = def;
	monaco_editor_core_exports$3.languages.register(def);
	const lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);
	monaco_editor_core_exports$3.languages.registerTokensProviderFactory(languageId, { create: async () => {
		return (await lazyLanguageLoader.load()).language;
	} });
	monaco_editor_core_exports$3.languages.onLanguage(languageId, async () => {
		const mod = await lazyLanguageLoader.load();
		monaco_editor_core_exports$3.languages.setLanguageConfiguration(languageId, mod.conf);
	});
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/abap/abap.contribution.js
registerLanguage({
	id: "abap",
	extensions: [".abap"],
	aliases: ["abap", "ABAP"],
	loader: () => {
		return import("./abap-CQ2lef7Z.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/apex/apex.contribution.js
registerLanguage({
	id: "apex",
	extensions: [".cls"],
	aliases: ["Apex", "apex"],
	mimetypes: ["text/x-apex-source", "text/x-apex"],
	loader: () => {
		return import("./apex-X2dS4wmz.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/azcli/azcli.contribution.js
registerLanguage({
	id: "azcli",
	extensions: [".azcli"],
	aliases: ["Azure CLI", "azcli"],
	loader: () => {
		return import("./azcli-BlwsUgbI.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/bat/bat.contribution.js
registerLanguage({
	id: "bat",
	extensions: [".bat", ".cmd"],
	aliases: ["Batch", "bat"],
	loader: () => {
		return import("./bat-4L6_55ZA.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/bicep/bicep.contribution.js
registerLanguage({
	id: "bicep",
	extensions: [".bicep"],
	aliases: ["Bicep"],
	loader: () => {
		return import("./bicep-CJNhcRCQ.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/cameligo/cameligo.contribution.js
registerLanguage({
	id: "cameligo",
	extensions: [".mligo"],
	aliases: ["Cameligo"],
	loader: () => {
		return import("./cameligo-D34Xa5Ws.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/clojure/clojure.contribution.js
registerLanguage({
	id: "clojure",
	extensions: [
		".clj",
		".cljs",
		".cljc",
		".edn"
	],
	aliases: ["clojure", "Clojure"],
	loader: () => {
		return import("./clojure-B0riPItq.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/coffee/coffee.contribution.js
registerLanguage({
	id: "coffeescript",
	extensions: [".coffee"],
	aliases: [
		"CoffeeScript",
		"coffeescript",
		"coffee"
	],
	mimetypes: ["text/x-coffeescript", "text/coffeescript"],
	loader: () => {
		return import("./coffee-D_eeNMBr.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/cpp/cpp.contribution.js
registerLanguage({
	id: "c",
	extensions: [".c", ".h"],
	aliases: ["C", "c"],
	loader: () => {
		return import("./cpp-BLmf1ffM.js");
	}
});
registerLanguage({
	id: "cpp",
	extensions: [
		".cpp",
		".cc",
		".cxx",
		".hpp",
		".hh",
		".hxx"
	],
	aliases: [
		"C++",
		"Cpp",
		"cpp"
	],
	loader: () => {
		return import("./cpp-BLmf1ffM.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/csharp/csharp.contribution.js
registerLanguage({
	id: "csharp",
	extensions: [
		".cs",
		".csx",
		".cake"
	],
	aliases: ["C#", "csharp"],
	loader: () => {
		return import("./csharp-oFhjPh-T.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/csp/csp.contribution.js
registerLanguage({
	id: "csp",
	extensions: [],
	aliases: ["CSP", "csp"],
	loader: () => {
		return import("./csp-JiyXM2ei.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/css/css.contribution.js
registerLanguage({
	id: "css",
	extensions: [".css"],
	aliases: ["CSS", "css"],
	mimetypes: ["text/css"],
	loader: () => {
		return import("./css-CBy_WisV.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/cypher/cypher.contribution.js
registerLanguage({
	id: "cypher",
	extensions: [".cypher", ".cyp"],
	aliases: ["Cypher", "OpenCypher"],
	loader: () => {
		return import("./cypher-BKx8G91P.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/dart/dart.contribution.js
registerLanguage({
	id: "dart",
	extensions: [".dart"],
	aliases: ["Dart", "dart"],
	mimetypes: ["text/x-dart-source", "text/x-dart"],
	loader: () => {
		return import("./dart-BKDtskRW.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/dockerfile/dockerfile.contribution.js
registerLanguage({
	id: "dockerfile",
	extensions: [".dockerfile"],
	filenames: ["Dockerfile"],
	aliases: ["Dockerfile"],
	loader: () => {
		return import("./dockerfile-CYHjPZZv.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/ecl/ecl.contribution.js
registerLanguage({
	id: "ecl",
	extensions: [".ecl"],
	aliases: [
		"ECL",
		"Ecl",
		"ecl"
	],
	loader: () => {
		return import("./ecl-C4-YpV48.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.contribution.js
registerLanguage({
	id: "elixir",
	extensions: [".ex", ".exs"],
	aliases: [
		"Elixir",
		"elixir",
		"ex"
	],
	loader: () => {
		return import("./elixir-DMXmEkYA.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/flow9/flow9.contribution.js
registerLanguage({
	id: "flow9",
	extensions: [".flow"],
	aliases: [
		"Flow9",
		"Flow",
		"flow9",
		"flow"
	],
	loader: () => {
		return import("./flow9-DYBeWh2B.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/fsharp/fsharp.contribution.js
registerLanguage({
	id: "fsharp",
	extensions: [
		".fs",
		".fsi",
		".ml",
		".mli",
		".fsx",
		".fsscript"
	],
	aliases: [
		"F#",
		"FSharp",
		"fsharp"
	],
	loader: () => {
		return import("./fsharp-Ps5fwRzO.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.contribution.js
registerLanguage({
	id: "freemarker2",
	extensions: [
		".ftl",
		".ftlh",
		".ftlx"
	],
	aliases: ["FreeMarker2", "Apache FreeMarker2"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagAutoInterpolationDollar);
	}
});
registerLanguage({
	id: "freemarker2.tag-angle.interpolation-dollar",
	aliases: ["FreeMarker2 (Angle/Dollar)", "Apache FreeMarker2 (Angle/Dollar)"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagAngleInterpolationDollar);
	}
});
registerLanguage({
	id: "freemarker2.tag-bracket.interpolation-dollar",
	aliases: ["FreeMarker2 (Bracket/Dollar)", "Apache FreeMarker2 (Bracket/Dollar)"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagBracketInterpolationDollar);
	}
});
registerLanguage({
	id: "freemarker2.tag-angle.interpolation-bracket",
	aliases: ["FreeMarker2 (Angle/Bracket)", "Apache FreeMarker2 (Angle/Bracket)"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagAngleInterpolationBracket);
	}
});
registerLanguage({
	id: "freemarker2.tag-bracket.interpolation-bracket",
	aliases: ["FreeMarker2 (Bracket/Bracket)", "Apache FreeMarker2 (Bracket/Bracket)"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagBracketInterpolationBracket);
	}
});
registerLanguage({
	id: "freemarker2.tag-auto.interpolation-dollar",
	aliases: ["FreeMarker2 (Auto/Dollar)", "Apache FreeMarker2 (Auto/Dollar)"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagAutoInterpolationDollar);
	}
});
registerLanguage({
	id: "freemarker2.tag-auto.interpolation-bracket",
	aliases: ["FreeMarker2 (Auto/Bracket)", "Apache FreeMarker2 (Auto/Bracket)"],
	loader: () => {
		return import("./freemarker2-7vTK_vms.js").then((m) => m.TagAutoInterpolationBracket);
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/go/go.contribution.js
registerLanguage({
	id: "go",
	extensions: [".go"],
	aliases: ["Go"],
	loader: () => {
		return import("./go-DuwkyXwo.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/graphql/graphql.contribution.js
registerLanguage({
	id: "graphql",
	extensions: [".graphql", ".gql"],
	aliases: [
		"GraphQL",
		"graphql",
		"gql"
	],
	mimetypes: ["application/graphql"],
	loader: () => {
		return import("./graphql-DqyM0-S2.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/handlebars/handlebars.contribution.js
registerLanguage({
	id: "handlebars",
	extensions: [".handlebars", ".hbs"],
	aliases: [
		"Handlebars",
		"handlebars",
		"hbs"
	],
	mimetypes: ["text/x-handlebars-template"],
	loader: () => {
		return import("./handlebars-DC4DuDPp.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/hcl/hcl.contribution.js
registerLanguage({
	id: "hcl",
	extensions: [
		".tf",
		".tfvars",
		".hcl"
	],
	aliases: [
		"Terraform",
		"tf",
		"HCL",
		"hcl"
	],
	loader: () => {
		return import("./hcl-DZuPA93U.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/html/html.contribution.js
registerLanguage({
	id: "html",
	extensions: [
		".html",
		".htm",
		".shtml",
		".xhtml",
		".mdoc",
		".jsp",
		".asp",
		".aspx",
		".jshtm"
	],
	aliases: [
		"HTML",
		"htm",
		"html",
		"xhtml"
	],
	mimetypes: [
		"text/html",
		"text/x-jshtm",
		"text/template",
		"text/ng-template"
	],
	loader: () => {
		return import("./html-4Xel03XD.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/ini/ini.contribution.js
registerLanguage({
	id: "ini",
	extensions: [
		".ini",
		".properties",
		".gitconfig"
	],
	filenames: [
		"config",
		".gitattributes",
		".gitconfig",
		".editorconfig"
	],
	aliases: ["Ini", "ini"],
	loader: () => {
		return import("./ini-Df5gE1mD.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/java/java.contribution.js
registerLanguage({
	id: "java",
	extensions: [".java", ".jav"],
	aliases: ["Java", "java"],
	mimetypes: ["text/x-java-source", "text/x-java"],
	loader: () => {
		return import("./java-Cbw-6V-0.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution.js
registerLanguage({
	id: "javascript",
	extensions: [
		".js",
		".es6",
		".jsx",
		".mjs",
		".cjs"
	],
	firstLine: "^#!.*\\bnode",
	filenames: ["jakefile"],
	aliases: [
		"JavaScript",
		"javascript",
		"js"
	],
	mimetypes: ["text/javascript"],
	loader: () => {
		return import("./javascript-C_ueMW8Q.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/julia/julia.contribution.js
registerLanguage({
	id: "julia",
	extensions: [".jl"],
	aliases: ["julia", "Julia"],
	loader: () => {
		return import("./julia-btwDKMfV.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/kotlin/kotlin.contribution.js
registerLanguage({
	id: "kotlin",
	extensions: [".kt"],
	aliases: ["Kotlin", "kotlin"],
	mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
	loader: () => {
		return import("./kotlin-CL_10KYl.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/less/less.contribution.js
registerLanguage({
	id: "less",
	extensions: [".less"],
	aliases: ["Less", "less"],
	mimetypes: ["text/x-less", "text/less"],
	loader: () => {
		return import("./less-CxugccUR.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/lexon/lexon.contribution.js
registerLanguage({
	id: "lexon",
	extensions: [".lex"],
	aliases: ["Lexon"],
	loader: () => {
		return import("./lexon-BGbNgaGT.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/lua/lua.contribution.js
registerLanguage({
	id: "lua",
	extensions: [".lua"],
	aliases: ["Lua", "lua"],
	loader: () => {
		return import("./lua-k21lFVcG.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/liquid/liquid.contribution.js
registerLanguage({
	id: "liquid",
	extensions: [".liquid", ".html.liquid"],
	aliases: ["Liquid", "liquid"],
	mimetypes: ["application/liquid"],
	loader: () => {
		return import("./liquid-CRG7xD5a.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/m3/m3.contribution.js
registerLanguage({
	id: "m3",
	extensions: [
		".m3",
		".i3",
		".mg",
		".ig"
	],
	aliases: [
		"Modula-3",
		"Modula3",
		"modula3",
		"m3"
	],
	loader: () => {
		return import("./m3-B52od4-m.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution.js
registerLanguage({
	id: "markdown",
	extensions: [
		".md",
		".markdown",
		".mdown",
		".mkdn",
		".mkd",
		".mdwn",
		".mdtxt",
		".mdtext"
	],
	aliases: ["Markdown", "markdown"],
	loader: () => {
		return import("./markdown-CmvCj2fJ.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/mips/mips.contribution.js
registerLanguage({
	id: "mips",
	extensions: [".s"],
	aliases: ["MIPS", "MIPS-V"],
	mimetypes: [
		"text/x-mips",
		"text/mips",
		"text/plaintext"
	],
	loader: () => {
		return import("./mips-w__9uUwb.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/msdax/msdax.contribution.js
registerLanguage({
	id: "msdax",
	extensions: [".dax", ".msdax"],
	aliases: ["DAX", "MSDAX"],
	loader: () => {
		return import("./msdax-RKFByRjs.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/mysql/mysql.contribution.js
registerLanguage({
	id: "mysql",
	extensions: [],
	aliases: ["MySQL", "mysql"],
	loader: () => {
		return import("./mysql-4sRId5Ry.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/objective-c/objective-c.contribution.js
registerLanguage({
	id: "objective-c",
	extensions: [".m"],
	aliases: ["Objective-C"],
	loader: () => {
		return import("./objective-c-Cxf7VCow.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.contribution.js
registerLanguage({
	id: "pascal",
	extensions: [
		".pas",
		".p",
		".pp"
	],
	aliases: ["Pascal", "pas"],
	mimetypes: ["text/x-pascal-source", "text/x-pascal"],
	loader: () => {
		return import("./pascal-C1z7sKPk.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/pascaligo/pascaligo.contribution.js
registerLanguage({
	id: "pascaligo",
	extensions: [".ligo"],
	aliases: ["Pascaligo", "ligo"],
	loader: () => {
		return import("./pascaligo-BVOOK3PO.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/perl/perl.contribution.js
registerLanguage({
	id: "perl",
	extensions: [".pl"],
	aliases: ["Perl", "pl"],
	loader: () => {
		return import("./perl-QRiDDo-W.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/pgsql/pgsql.contribution.js
registerLanguage({
	id: "pgsql",
	extensions: [],
	aliases: [
		"PostgreSQL",
		"postgres",
		"pg",
		"postgre"
	],
	loader: () => {
		return import("./pgsql-BcJm7W78.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/php/php.contribution.js
registerLanguage({
	id: "php",
	extensions: [
		".php",
		".php4",
		".php5",
		".phtml",
		".ctp"
	],
	aliases: ["PHP", "php"],
	mimetypes: ["application/x-php"],
	loader: () => {
		return import("./php-BLmI0_v2.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/pla/pla.contribution.js
registerLanguage({
	id: "pla",
	extensions: [".pla"],
	loader: () => {
		return import("./pla-D2GH6jO8.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/postiats/postiats.contribution.js
registerLanguage({
	id: "postiats",
	extensions: [
		".dats",
		".sats",
		".hats"
	],
	aliases: ["ATS", "ATS/Postiats"],
	loader: () => {
		return import("./postiats-NjhMKTHM.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/powerquery/powerquery.contribution.js
registerLanguage({
	id: "powerquery",
	extensions: [".pq", ".pqm"],
	aliases: [
		"PQ",
		"M",
		"Power Query",
		"Power Query M"
	],
	loader: () => {
		return import("./powerquery-CsndvhE4.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/powershell/powershell.contribution.js
registerLanguage({
	id: "powershell",
	extensions: [
		".ps1",
		".psm1",
		".psd1"
	],
	aliases: [
		"PowerShell",
		"powershell",
		"ps",
		"ps1"
	],
	loader: () => {
		return import("./powershell-CSHleMgV.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/protobuf/protobuf.contribution.js
registerLanguage({
	id: "proto",
	extensions: [".proto"],
	aliases: ["protobuf", "Protocol Buffers"],
	loader: () => {
		return import("./protobuf-BkcOWR-8.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/pug/pug.contribution.js
registerLanguage({
	id: "pug",
	extensions: [".jade", ".pug"],
	aliases: [
		"Pug",
		"Jade",
		"jade"
	],
	loader: () => {
		return import("./pug-7fNJDrJ0.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/python/python.contribution.js
registerLanguage({
	id: "python",
	extensions: [
		".py",
		".rpy",
		".pyw",
		".cpy",
		".gyp",
		".gypi"
	],
	aliases: ["Python", "py"],
	firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
	loader: () => {
		return import("./python-DlD9DvEb.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/qsharp/qsharp.contribution.js
registerLanguage({
	id: "qsharp",
	extensions: [".qs"],
	aliases: ["Q#", "qsharp"],
	loader: () => {
		return import("./qsharp-Cgiocq8h.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/r/r.contribution.js
registerLanguage({
	id: "r",
	extensions: [
		".r",
		".rhistory",
		".rmd",
		".rprofile",
		".rt"
	],
	aliases: ["R", "r"],
	loader: () => {
		return import("./r-Ce40aLgA.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/razor/razor.contribution.js
registerLanguage({
	id: "razor",
	extensions: [".cshtml"],
	aliases: ["Razor", "razor"],
	mimetypes: ["text/x-cshtml"],
	loader: () => {
		return import("./razor-CfNObmqZ.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/redis/redis.contribution.js
registerLanguage({
	id: "redis",
	extensions: [".redis"],
	aliases: ["redis"],
	loader: () => {
		return import("./redis-CNUIWXEu.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/redshift/redshift.contribution.js
registerLanguage({
	id: "redshift",
	extensions: [],
	aliases: ["Redshift", "redshift"],
	loader: () => {
		return import("./redshift-DsPuO_nA.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/restructuredtext/restructuredtext.contribution.js
registerLanguage({
	id: "restructuredtext",
	extensions: [".rst"],
	aliases: ["reStructuredText", "restructuredtext"],
	loader: () => {
		return import("./restructuredtext-BBSR77He.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.contribution.js
registerLanguage({
	id: "ruby",
	extensions: [
		".rb",
		".rbx",
		".rjs",
		".gemspec",
		".pp"
	],
	filenames: ["rakefile", "Gemfile"],
	aliases: ["Ruby", "rb"],
	loader: () => {
		return import("./ruby-BAIJNctZ.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/rust/rust.contribution.js
registerLanguage({
	id: "rust",
	extensions: [".rs", ".rlib"],
	aliases: ["Rust", "rust"],
	loader: () => {
		return import("./rust-DqiVlVhq.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/sb/sb.contribution.js
registerLanguage({
	id: "sb",
	extensions: [".sb"],
	aliases: ["Small Basic", "sb"],
	loader: () => {
		return import("./sb-DD01HBR9.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/scala/scala.contribution.js
registerLanguage({
	id: "scala",
	extensions: [
		".scala",
		".sc",
		".sbt"
	],
	aliases: [
		"Scala",
		"scala",
		"SBT",
		"Sbt",
		"sbt",
		"Dotty",
		"dotty"
	],
	mimetypes: [
		"text/x-scala-source",
		"text/x-scala",
		"text/x-sbt",
		"text/x-dotty"
	],
	loader: () => {
		return import("./scala-Djepw_DR.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/scheme/scheme.contribution.js
registerLanguage({
	id: "scheme",
	extensions: [
		".scm",
		".ss",
		".sch",
		".rkt"
	],
	aliases: ["scheme", "Scheme"],
	loader: () => {
		return import("./scheme-xG_ywEx-.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/scss/scss.contribution.js
registerLanguage({
	id: "scss",
	extensions: [".scss"],
	aliases: [
		"Sass",
		"sass",
		"scss"
	],
	mimetypes: ["text/x-scss", "text/scss"],
	loader: () => {
		return import("./scss-BHospol0.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/shell/shell.contribution.js
registerLanguage({
	id: "shell",
	extensions: [".sh", ".bash"],
	aliases: ["Shell", "sh"],
	loader: () => {
		return import("./shell-BNnPP88D.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/solidity/solidity.contribution.js
registerLanguage({
	id: "sol",
	extensions: [".sol"],
	aliases: [
		"sol",
		"solidity",
		"Solidity"
	],
	loader: () => {
		return import("./solidity-CLOsHQp1.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/sophia/sophia.contribution.js
registerLanguage({
	id: "aes",
	extensions: [".aes"],
	aliases: [
		"aes",
		"sophia",
		"Sophia"
	],
	loader: () => {
		return import("./sophia-B6V3E7q6.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/sparql/sparql.contribution.js
registerLanguage({
	id: "sparql",
	extensions: [".rq"],
	aliases: ["sparql", "SPARQL"],
	loader: () => {
		return import("./sparql-ZnSHqdGp.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/sql/sql.contribution.js
registerLanguage({
	id: "sql",
	extensions: [".sql"],
	aliases: ["SQL"],
	loader: () => {
		return import("./sql-B2U4fD3X.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/st/st.contribution.js
registerLanguage({
	id: "st",
	extensions: [
		".st",
		".iecst",
		".iecplc",
		".lc3lib"
	],
	aliases: [
		"StructuredText",
		"scl",
		"stl"
	],
	loader: () => {
		return import("./st-DIsw1cF-.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/swift/swift.contribution.js
registerLanguage({
	id: "swift",
	aliases: ["Swift", "swift"],
	extensions: [".swift"],
	mimetypes: ["text/swift"],
	loader: () => {
		return import("./swift-DjsUOsUY.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/systemverilog/systemverilog.contribution.js
registerLanguage({
	id: "systemverilog",
	extensions: [".sv", ".svh"],
	aliases: [
		"SV",
		"sv",
		"SystemVerilog",
		"systemverilog"
	],
	loader: () => {
		return import("./systemverilog-Cf_EXyIo.js");
	}
});
registerLanguage({
	id: "verilog",
	extensions: [".v", ".vh"],
	aliases: [
		"V",
		"v",
		"Verilog",
		"verilog"
	],
	loader: () => {
		return import("./systemverilog-Cf_EXyIo.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/tcl/tcl.contribution.js
registerLanguage({
	id: "tcl",
	extensions: [".tcl"],
	aliases: [
		"tcl",
		"Tcl",
		"tcltk",
		"TclTk",
		"tcl/tk",
		"Tcl/Tk"
	],
	loader: () => {
		return import("./tcl-BcxA8Mma.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/twig/twig.contribution.js
registerLanguage({
	id: "twig",
	extensions: [".twig"],
	aliases: ["Twig", "twig"],
	mimetypes: ["text/x-twig"],
	loader: () => {
		return import("./twig-CYxw8gn4.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js
registerLanguage({
	id: "typescript",
	extensions: [".ts", ".tsx"],
	aliases: [
		"TypeScript",
		"ts",
		"typescript"
	],
	mimetypes: ["text/typescript"],
	loader: () => {
		return import("./typescript-L_q480eC.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/vb/vb.contribution.js
registerLanguage({
	id: "vb",
	extensions: [".vb"],
	aliases: ["Visual Basic", "vb"],
	loader: () => {
		return import("./vb-DdAdz_UU.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/xml/xml.contribution.js
registerLanguage({
	id: "xml",
	extensions: [
		".xml",
		".dtd",
		".ascx",
		".csproj",
		".config",
		".wxi",
		".wxl",
		".wxs",
		".xaml",
		".svg",
		".svgz",
		".opf",
		".xsl"
	],
	firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
	aliases: ["XML", "xml"],
	mimetypes: [
		"text/xml",
		"application/xml",
		"application/xaml+xml",
		"application/xml-dtd"
	],
	loader: () => {
		return import("./xml-v7wWxkPV.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution.js
registerLanguage({
	id: "yaml",
	extensions: [".yaml", ".yml"],
	aliases: [
		"YAML",
		"yaml",
		"YML",
		"yml"
	],
	mimetypes: ["application/x-yaml", "text/x-yaml"],
	loader: () => {
		return import("./yaml-BtE7u6pv.js");
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __copyProps$2 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$2(from)) if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport$2 = (target, mod, secondTarget) => (__copyProps$2(target, mod, "default"), secondTarget && __copyProps$2(secondTarget, mod, "default"));
var monaco_editor_core_exports$2 = {};
__reExport$2(monaco_editor_core_exports$2, editor_api_exports);
var LanguageServiceDefaultsImpl$2 = class {
	_onDidChange = new monaco_editor_core_exports$2.Emitter();
	_options;
	_modeConfiguration;
	_languageId;
	constructor(languageId, options, modeConfiguration) {
		this._languageId = languageId;
		this.setOptions(options);
		this.setModeConfiguration(modeConfiguration);
	}
	get onDidChange() {
		return this._onDidChange.event;
	}
	get languageId() {
		return this._languageId;
	}
	get modeConfiguration() {
		return this._modeConfiguration;
	}
	get diagnosticsOptions() {
		return this.options;
	}
	get options() {
		return this._options;
	}
	setOptions(options) {
		this._options = options || /* @__PURE__ */ Object.create(null);
		this._onDidChange.fire(this);
	}
	setDiagnosticsOptions(options) {
		this.setOptions(options);
	}
	setModeConfiguration(modeConfiguration) {
		this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
		this._onDidChange.fire(this);
	}
};
var optionsDefault$1 = {
	validate: true,
	lint: {
		compatibleVendorPrefixes: "ignore",
		vendorPrefix: "warning",
		duplicateProperties: "warning",
		emptyRules: "warning",
		importStatement: "ignore",
		boxModel: "ignore",
		universalSelector: "ignore",
		zeroUnits: "ignore",
		fontFaceProperties: "warning",
		hexColorLength: "error",
		argumentsInColorFunction: "error",
		unknownProperties: "warning",
		ieHack: "ignore",
		unknownVendorSpecificProperties: "ignore",
		propertyIgnoredDueToDisplay: "warning",
		important: "ignore",
		float: "ignore",
		idSelector: "ignore"
	},
	data: { useDefaultDataProvider: true },
	format: {
		newlineBetweenSelectors: true,
		newlineBetweenRules: true,
		spaceAroundSelectorSeparator: false,
		braceStyle: "collapse",
		maxPreserveNewLines: void 0,
		preserveNewLines: true
	}
};
var modeConfigurationDefault = {
	completionItems: true,
	hovers: true,
	documentSymbols: true,
	definitions: true,
	references: true,
	documentHighlights: true,
	rename: true,
	colors: true,
	foldingRanges: true,
	diagnostics: true,
	selectionRanges: true,
	documentFormattingEdits: true,
	documentRangeFormattingEdits: true
};
var cssDefaults = new LanguageServiceDefaultsImpl$2("css", optionsDefault$1, modeConfigurationDefault);
var scssDefaults = new LanguageServiceDefaultsImpl$2("scss", optionsDefault$1, modeConfigurationDefault);
var lessDefaults = new LanguageServiceDefaultsImpl$2("less", optionsDefault$1, modeConfigurationDefault);
monaco_editor_core_exports$2.languages.css = {
	cssDefaults,
	lessDefaults,
	scssDefaults
};
function getMode$2() {
	return import("./cssMode-RiBe-l82.js");
}
monaco_editor_core_exports$2.languages.onLanguage("less", () => {
	getMode$2().then((mode) => mode.setupMode(lessDefaults));
});
monaco_editor_core_exports$2.languages.onLanguage("scss", () => {
	getMode$2().then((mode) => mode.setupMode(scssDefaults));
});
monaco_editor_core_exports$2.languages.onLanguage("css", () => {
	getMode$2().then((mode) => mode.setupMode(cssDefaults));
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport$1 = (target, mod, secondTarget) => (__copyProps$1(target, mod, "default"), secondTarget && __copyProps$1(secondTarget, mod, "default"));
var monaco_editor_core_exports$1 = {};
__reExport$1(monaco_editor_core_exports$1, editor_api_exports);
var LanguageServiceDefaultsImpl$1 = class {
	_onDidChange = new monaco_editor_core_exports$1.Emitter();
	_options;
	_modeConfiguration;
	_languageId;
	constructor(languageId, options, modeConfiguration) {
		this._languageId = languageId;
		this.setOptions(options);
		this.setModeConfiguration(modeConfiguration);
	}
	get onDidChange() {
		return this._onDidChange.event;
	}
	get languageId() {
		return this._languageId;
	}
	get options() {
		return this._options;
	}
	get modeConfiguration() {
		return this._modeConfiguration;
	}
	setOptions(options) {
		this._options = options || /* @__PURE__ */ Object.create(null);
		this._onDidChange.fire(this);
	}
	setModeConfiguration(modeConfiguration) {
		this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
		this._onDidChange.fire(this);
	}
};
var optionsDefault = {
	format: {
		tabSize: 4,
		insertSpaces: false,
		wrapLineLength: 120,
		unformatted: "default\": \"a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var",
		contentUnformatted: "pre",
		indentInnerHtml: false,
		preserveNewLines: true,
		maxPreserveNewLines: void 0,
		indentHandlebars: false,
		endWithNewline: false,
		extraLiners: "head, body, /html",
		wrapAttributes: "auto"
	},
	suggest: {},
	data: { useDefaultDataProvider: true }
};
function getConfigurationDefault(languageId) {
	return {
		completionItems: true,
		hovers: true,
		documentSymbols: true,
		links: true,
		documentHighlights: true,
		rename: true,
		colors: true,
		foldingRanges: true,
		selectionRanges: true,
		diagnostics: languageId === htmlLanguageId,
		documentFormattingEdits: languageId === htmlLanguageId,
		documentRangeFormattingEdits: languageId === htmlLanguageId
	};
}
var htmlLanguageId = "html";
var handlebarsLanguageId = "handlebars";
var razorLanguageId = "razor";
var htmlLanguageService = registerHTMLLanguageService(htmlLanguageId, optionsDefault, getConfigurationDefault(htmlLanguageId));
var htmlDefaults = htmlLanguageService.defaults;
var handlebarLanguageService = registerHTMLLanguageService(handlebarsLanguageId, optionsDefault, getConfigurationDefault(handlebarsLanguageId));
var handlebarDefaults = handlebarLanguageService.defaults;
var razorLanguageService = registerHTMLLanguageService(razorLanguageId, optionsDefault, getConfigurationDefault(razorLanguageId));
var razorDefaults = razorLanguageService.defaults;
monaco_editor_core_exports$1.languages.html = {
	htmlDefaults,
	razorDefaults,
	handlebarDefaults,
	htmlLanguageService,
	handlebarLanguageService,
	razorLanguageService,
	registerHTMLLanguageService
};
function getMode$1() {
	return import("./htmlMode-BREvcs75.js");
}
function registerHTMLLanguageService(languageId, options = optionsDefault, modeConfiguration = getConfigurationDefault(languageId)) {
	const defaults = new LanguageServiceDefaultsImpl$1(languageId, options, modeConfiguration);
	let mode;
	const onLanguageListener = monaco_editor_core_exports$1.languages.onLanguage(languageId, async () => {
		mode = (await getMode$1()).setupMode(defaults);
	});
	return {
		defaults,
		dispose() {
			onLanguageListener.dispose();
			mode?.dispose();
			mode = void 0;
		}
	};
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var monaco_editor_core_exports = {};
__reExport(monaco_editor_core_exports, editor_api_exports);
var LanguageServiceDefaultsImpl = class {
	_onDidChange = new monaco_editor_core_exports.Emitter();
	_diagnosticsOptions;
	_modeConfiguration;
	_languageId;
	constructor(languageId, diagnosticsOptions, modeConfiguration) {
		this._languageId = languageId;
		this.setDiagnosticsOptions(diagnosticsOptions);
		this.setModeConfiguration(modeConfiguration);
	}
	get onDidChange() {
		return this._onDidChange.event;
	}
	get languageId() {
		return this._languageId;
	}
	get modeConfiguration() {
		return this._modeConfiguration;
	}
	get diagnosticsOptions() {
		return this._diagnosticsOptions;
	}
	setDiagnosticsOptions(options) {
		this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);
		this._onDidChange.fire(this);
	}
	setModeConfiguration(modeConfiguration) {
		this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
		this._onDidChange.fire(this);
	}
};
var jsonDefaults = new LanguageServiceDefaultsImpl("json", {
	validate: true,
	allowComments: true,
	schemas: [],
	enableSchemaRequest: false,
	schemaRequest: "warning",
	schemaValidation: "warning",
	comments: "error",
	trailingCommas: "error"
}, {
	documentFormattingEdits: true,
	documentRangeFormattingEdits: true,
	completionItems: true,
	hovers: true,
	documentSymbols: true,
	tokens: true,
	colors: true,
	foldingRanges: true,
	diagnostics: true,
	selectionRanges: true
});
monaco_editor_core_exports.languages.json = { jsonDefaults };
function getMode() {
	return import("./jsonMode-DnBMcp5P.js");
}
monaco_editor_core_exports.languages.register({
	id: "json",
	extensions: [
		".json",
		".bowerrc",
		".jshintrc",
		".jscsrc",
		".eslintrc",
		".babelrc",
		".har"
	],
	aliases: ["JSON", "json"],
	mimetypes: ["application/json"]
});
monaco_editor_core_exports.languages.onLanguage("json", () => {
	getMode().then((mode) => mode.setupMode(jsonDefaults));
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.js
var __decorate$81 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$81 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$56 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
var SelectionAnchorController = class SelectionAnchorController$1 {
	constructor(editor$1, contextKeyService) {
		this.editor = editor$1;
		this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
		this.modelChangeListener = editor$1.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
	}
	static get(editor$1) {
		return editor$1.getContribution(SelectionAnchorController$1.ID);
	}
	setSelectionAnchor() {
		if (this.editor.hasModel()) {
			const position = this.editor.getPosition();
			this.editor.changeDecorations((accessor) => {
				if (this.decorationId) accessor.removeDecoration(this.decorationId);
				this.decorationId = accessor.addDecoration(Selection$1.fromPositions(position, position), {
					description: "selection-anchor",
					stickiness: 1,
					hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
					className: "selection-anchor"
				});
			});
			this.selectionAnchorSetContextKey.set(!!this.decorationId);
			alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
		}
	}
	goToSelectionAnchor() {
		if (this.editor.hasModel() && this.decorationId) {
			const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
			if (anchorPosition) this.editor.setPosition(anchorPosition.getStartPosition());
		}
	}
	selectFromAnchorToCursor() {
		if (this.editor.hasModel() && this.decorationId) {
			const start = this.editor.getModel().getDecorationRange(this.decorationId);
			if (start) {
				const end = this.editor.getPosition();
				this.editor.setSelection(Selection$1.fromPositions(start.getStartPosition(), end));
				this.cancelSelectionAnchor();
			}
		}
	}
	cancelSelectionAnchor() {
		if (this.decorationId) {
			const decorationId = this.decorationId;
			this.editor.changeDecorations((accessor) => {
				accessor.removeDecoration(decorationId);
				this.decorationId = void 0;
			});
			this.selectionAnchorSetContextKey.set(false);
		}
	}
	dispose() {
		this.cancelSelectionAnchor();
		this.modelChangeListener.dispose();
	}
};
SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
SelectionAnchorController = __decorate$81([__param$81(1, IContextKeyService)], SelectionAnchorController);
var SetSelectionAnchor = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.setSelectionAnchor",
			label: localize("setSelectionAnchor", "Set Selection Anchor"),
			alias: "Set Selection Anchor",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2080),
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		var _a$5;
		return __awaiter$56(this, void 0, void 0, function* () {
			(_a$5 = SelectionAnchorController.get(editor$1)) === null || _a$5 === void 0 || _a$5.setSelectionAnchor();
		});
	}
};
var GoToSelectionAnchor = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.goToSelectionAnchor",
			label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
			alias: "Go to Selection Anchor",
			precondition: SelectionAnchorSet
		});
	}
	run(_accessor, editor$1) {
		var _a$5;
		return __awaiter$56(this, void 0, void 0, function* () {
			(_a$5 = SelectionAnchorController.get(editor$1)) === null || _a$5 === void 0 || _a$5.goToSelectionAnchor();
		});
	}
};
var SelectFromAnchorToCursor = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.selectFromAnchorToCursor",
			label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
			alias: "Select from Anchor to Cursor",
			precondition: SelectionAnchorSet,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2089),
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		var _a$5;
		return __awaiter$56(this, void 0, void 0, function* () {
			(_a$5 = SelectionAnchorController.get(editor$1)) === null || _a$5 === void 0 || _a$5.selectFromAnchorToCursor();
		});
	}
};
var CancelSelectionAnchor = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.cancelSelectionAnchor",
			label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
			alias: "Cancel Selection Anchor",
			precondition: SelectionAnchorSet,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 9,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		var _a$5;
		return __awaiter$56(this, void 0, void 0, function* () {
			(_a$5 = SelectionAnchorController.get(editor$1)) === null || _a$5 === void 0 || _a$5.cancelSelectionAnchor();
		});
	}
};
registerEditorContribution(SelectionAnchorController.ID, SelectionAnchorController);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.js
var overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", {
	dark: "#A0A0A0",
	light: "#A0A0A0",
	hcDark: "#A0A0A0",
	hcLight: "#A0A0A0"
}, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
var JumpToBracketAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.jumpToBracket",
			label: localize("smartSelect.jumpBracket", "Go to Bracket"),
			alias: "Go to Bracket",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3160,
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		var _a$5;
		(_a$5 = BracketMatchingController.get(editor$1)) === null || _a$5 === void 0 || _a$5.jumpToBracket();
	}
};
var SelectToBracketAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.selectToBracket",
			label: localize("smartSelect.selectToBracket", "Select to Bracket"),
			alias: "Select to Bracket",
			precondition: void 0,
			description: {
				description: `Select to Bracket`,
				args: [{
					name: "args",
					schema: {
						type: "object",
						properties: { "selectBrackets": {
							type: "boolean",
							default: true
						} }
					}
				}]
			}
		});
	}
	run(accessor, editor$1, args) {
		var _a$5;
		let selectBrackets = true;
		if (args && args.selectBrackets === false) selectBrackets = false;
		(_a$5 = BracketMatchingController.get(editor$1)) === null || _a$5 === void 0 || _a$5.selectToBracket(selectBrackets);
	}
};
var BracketsData = class {
	constructor(position, brackets, options) {
		this.position = position;
		this.brackets = brackets;
		this.options = options;
	}
};
var BracketMatchingController = class BracketMatchingController extends Disposable {
	constructor(editor$1) {
		super();
		this._editor = editor$1;
		this._lastBracketsData = [];
		this._lastVersionId = 0;
		this._decorations = this._editor.createDecorationsCollection();
		this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
		this._matchBrackets = this._editor.getOption(66);
		this._updateBracketsSoon.schedule();
		this._register(editor$1.onDidChangeCursorPosition((e) => {
			if (this._matchBrackets === "never") return;
			this._updateBracketsSoon.schedule();
		}));
		this._register(editor$1.onDidChangeModelContent((e) => {
			this._updateBracketsSoon.schedule();
		}));
		this._register(editor$1.onDidChangeModel((e) => {
			this._lastBracketsData = [];
			this._updateBracketsSoon.schedule();
		}));
		this._register(editor$1.onDidChangeModelLanguageConfiguration((e) => {
			this._lastBracketsData = [];
			this._updateBracketsSoon.schedule();
		}));
		this._register(editor$1.onDidChangeConfiguration((e) => {
			if (e.hasChanged(66)) {
				this._matchBrackets = this._editor.getOption(66);
				this._decorations.clear();
				this._lastBracketsData = [];
				this._lastVersionId = 0;
				this._updateBracketsSoon.schedule();
			}
		}));
		this._register(editor$1.onDidBlurEditorWidget(() => {
			this._updateBracketsSoon.schedule();
		}));
		this._register(editor$1.onDidFocusEditorWidget(() => {
			this._updateBracketsSoon.schedule();
		}));
	}
	static get(editor$1) {
		return editor$1.getContribution(BracketMatchingController.ID);
	}
	jumpToBracket() {
		if (!this._editor.hasModel()) return;
		const model = this._editor.getModel();
		const newSelections = this._editor.getSelections().map((selection) => {
			const position = selection.getStartPosition();
			const brackets = model.bracketPairs.matchBracket(position);
			let newCursorPosition = null;
			if (brackets) {
				if (brackets[0].containsPosition(position) && !brackets[1].containsPosition(position)) newCursorPosition = brackets[1].getStartPosition();
				else if (brackets[1].containsPosition(position)) newCursorPosition = brackets[0].getStartPosition();
			} else {
				const enclosingBrackets = model.bracketPairs.findEnclosingBrackets(position);
				if (enclosingBrackets) newCursorPosition = enclosingBrackets[1].getStartPosition();
				else {
					const nextBracket = model.bracketPairs.findNextBracket(position);
					if (nextBracket && nextBracket.range) newCursorPosition = nextBracket.range.getStartPosition();
				}
			}
			if (newCursorPosition) return new Selection$1(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
			return new Selection$1(position.lineNumber, position.column, position.lineNumber, position.column);
		});
		this._editor.setSelections(newSelections);
		this._editor.revealRange(newSelections[0]);
	}
	selectToBracket(selectBrackets) {
		if (!this._editor.hasModel()) return;
		const model = this._editor.getModel();
		const newSelections = [];
		this._editor.getSelections().forEach((selection) => {
			const position = selection.getStartPosition();
			let brackets = model.bracketPairs.matchBracket(position);
			if (!brackets) {
				brackets = model.bracketPairs.findEnclosingBrackets(position);
				if (!brackets) {
					const nextBracket = model.bracketPairs.findNextBracket(position);
					if (nextBracket && nextBracket.range) brackets = model.bracketPairs.matchBracket(nextBracket.range.getStartPosition());
				}
			}
			let selectFrom = null;
			let selectTo = null;
			if (brackets) {
				brackets.sort(Range$1.compareRangesUsingStarts);
				const [open, close] = brackets;
				selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
				selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
				if (close.containsPosition(position)) {
					const tmp = selectFrom;
					selectFrom = selectTo;
					selectTo = tmp;
				}
			}
			if (selectFrom && selectTo) newSelections.push(new Selection$1(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
		});
		if (newSelections.length > 0) {
			this._editor.setSelections(newSelections);
			this._editor.revealRange(newSelections[0]);
		}
	}
	_updateBrackets() {
		if (this._matchBrackets === "never") return;
		this._recomputeBrackets();
		const newDecorations = [];
		let newDecorationsLen = 0;
		for (const bracketData of this._lastBracketsData) {
			const brackets = bracketData.brackets;
			if (brackets) {
				newDecorations[newDecorationsLen++] = {
					range: brackets[0],
					options: bracketData.options
				};
				newDecorations[newDecorationsLen++] = {
					range: brackets[1],
					options: bracketData.options
				};
			}
		}
		this._decorations.set(newDecorations);
	}
	_recomputeBrackets() {
		if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
			this._lastBracketsData = [];
			this._lastVersionId = 0;
			return;
		}
		const selections = this._editor.getSelections();
		if (selections.length > 100) {
			this._lastBracketsData = [];
			this._lastVersionId = 0;
			return;
		}
		const model = this._editor.getModel();
		const versionId = model.getVersionId();
		let previousData = [];
		if (this._lastVersionId === versionId) previousData = this._lastBracketsData;
		const positions = [];
		let positionsLen = 0;
		for (let i = 0, len = selections.length; i < len; i++) {
			const selection = selections[i];
			if (selection.isEmpty()) positions[positionsLen++] = selection.getStartPosition();
		}
		if (positions.length > 1) positions.sort(Position$1.compare);
		const newData = [];
		let newDataLen = 0;
		let previousIndex = 0;
		const previousLen = previousData.length;
		for (let i = 0, len = positions.length; i < len; i++) {
			const position = positions[i];
			while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) previousIndex++;
			if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) newData[newDataLen++] = previousData[previousIndex];
			else {
				let brackets = model.bracketPairs.matchBracket(position, 20);
				let options = BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
				if (!brackets && this._matchBrackets === "always") {
					brackets = model.bracketPairs.findEnclosingBrackets(position, 20);
					options = BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
				}
				newData[newDataLen++] = new BracketsData(position, brackets, options);
			}
		}
		this._lastBracketsData = newData;
		this._lastVersionId = versionId;
	}
};
BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
	description: "bracket-match-overview",
	stickiness: 1,
	className: "bracket-match",
	overviewRuler: {
		color: themeColorFromId(overviewRulerBracketMatchForeground),
		position: OverviewRulerLane.Center
	}
});
BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
	description: "bracket-match-no-overview",
	stickiness: 1,
	className: "bracket-match"
});
registerEditorContribution(BracketMatchingController.ID, BracketMatchingController);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerThemingParticipant((theme, collector) => {
	const bracketMatchBackground = theme.getColor(editorBracketMatchBackground);
	if (bracketMatchBackground) collector.addRule(`.monaco-editor .bracket-match { background-color: ${bracketMatchBackground}; }`);
	const bracketMatchBorder = theme.getColor(editorBracketMatchBorder);
	if (bracketMatchBorder) collector.addRule(`.monaco-editor .bracket-match { border: 1px solid ${bracketMatchBorder}; }`);
});
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
	group: "5_infile_nav",
	command: {
		id: "editor.action.jumpToBracket",
		title: localize({
			key: "miGoToBracket",
			comment: ["&& denotes a mnemonic"]
		}, "Go to &&Bracket")
	},
	order: 2
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/moveCaretCommand.js
var MoveCaretCommand = class {
	constructor(selection, isMovingLeft) {
		this._selection = selection;
		this._isMovingLeft = isMovingLeft;
	}
	getEditOperations(model, builder) {
		if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) return;
		const lineNumber = this._selection.startLineNumber;
		const startColumn = this._selection.startColumn;
		const endColumn = this._selection.endColumn;
		if (this._isMovingLeft && startColumn === 1) return;
		if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) return;
		if (this._isMovingLeft) {
			const rangeBefore = new Range$1(lineNumber, startColumn - 1, lineNumber, startColumn);
			const charBefore = model.getValueInRange(rangeBefore);
			builder.addEditOperation(rangeBefore, null);
			builder.addEditOperation(new Range$1(lineNumber, endColumn, lineNumber, endColumn), charBefore);
		} else {
			const rangeAfter = new Range$1(lineNumber, endColumn, lineNumber, endColumn + 1);
			const charAfter = model.getValueInRange(rangeAfter);
			builder.addEditOperation(rangeAfter, null);
			builder.addEditOperation(new Range$1(lineNumber, startColumn, lineNumber, startColumn), charAfter);
		}
	}
	computeCursorState(model, helper) {
		if (this._isMovingLeft) return new Selection$1(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
		else return new Selection$1(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
var MoveCaretAction = class extends EditorAction {
	constructor(left, opts) {
		super(opts);
		this.left = left;
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const commands = [];
		const selections = editor$1.getSelections();
		for (const selection of selections) commands.push(new MoveCaretCommand(selection, this.left));
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var MoveCaretLeftAction = class extends MoveCaretAction {
	constructor() {
		super(true, {
			id: "editor.action.moveCarretLeftAction",
			label: localize("caret.moveLeft", "Move Selected Text Left"),
			alias: "Move Selected Text Left",
			precondition: EditorContextKeys.writable
		});
	}
};
var MoveCaretRightAction = class extends MoveCaretAction {
	constructor() {
		super(false, {
			id: "editor.action.moveCarretRightAction",
			label: localize("caret.moveRight", "Move Selected Text Right"),
			alias: "Move Selected Text Right",
			precondition: EditorContextKeys.writable
		});
	}
};
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/transpose.js
var TransposeLettersAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.transposeLetters",
			label: localize("transposeLetters.label", "Transpose Letters"),
			alias: "Transpose Letters",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 306 },
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const model = editor$1.getModel();
		const commands = [];
		const selections = editor$1.getSelections();
		for (const selection of selections) {
			if (!selection.isEmpty()) continue;
			const lineNumber = selection.startLineNumber;
			const column = selection.startColumn;
			const lastColumn = model.getLineMaxColumn(lineNumber);
			if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) continue;
			const endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
			const middlePosition = MoveOperations.leftPosition(model, endPosition);
			const beginPosition = MoveOperations.leftPosition(model, middlePosition);
			const leftChar = model.getValueInRange(Range$1.fromPositions(beginPosition, middlePosition));
			const rightChar = model.getValueInRange(Range$1.fromPositions(middlePosition, endPosition));
			const replaceRange = Range$1.fromPositions(beginPosition, endPosition);
			commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
		}
		if (commands.length > 0) {
			editor$1.pushUndoStop();
			editor$1.executeCommands(this.id, commands);
			editor$1.pushUndoStop();
		}
	}
};
registerEditorAction(TransposeLettersAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/browser/clipboard.js
var __awaiter$55 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
var supportsCut = isNative || document.queryCommandSupported("cut");
var supportsCopy = isNative || document.queryCommandSupported("copy");
var supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
	command.register();
	return command;
}
const CutAction = supportsCut ? registerCommand(new MultiCommand({
	id: "editor.action.clipboardCutAction",
	precondition: void 0,
	kbOpts: isNative ? {
		primary: 2102,
		win: {
			primary: 2102,
			secondary: [1044]
		},
		weight: 100
	} : void 0,
	menuOpts: [
		{
			menuId: MenuId.MenubarEditMenu,
			group: "2_ccp",
			title: localize({
				key: "miCut",
				comment: ["&& denotes a mnemonic"]
			}, "Cu&&t"),
			order: 1
		},
		{
			menuId: MenuId.EditorContext,
			group: CLIPBOARD_CONTEXT_MENU_GROUP,
			title: localize("actions.clipboard.cutLabel", "Cut"),
			when: EditorContextKeys.writable,
			order: 1
		},
		{
			menuId: MenuId.CommandPalette,
			group: "",
			title: localize("actions.clipboard.cutLabel", "Cut"),
			order: 1
		},
		{
			menuId: MenuId.SimpleEditorContext,
			group: CLIPBOARD_CONTEXT_MENU_GROUP,
			title: localize("actions.clipboard.cutLabel", "Cut"),
			when: EditorContextKeys.writable,
			order: 1
		}
	]
})) : void 0;
const CopyAction = supportsCopy ? registerCommand(new MultiCommand({
	id: "editor.action.clipboardCopyAction",
	precondition: void 0,
	kbOpts: isNative ? {
		primary: 2081,
		win: {
			primary: 2081,
			secondary: [2067]
		},
		weight: 100
	} : void 0,
	menuOpts: [
		{
			menuId: MenuId.MenubarEditMenu,
			group: "2_ccp",
			title: localize({
				key: "miCopy",
				comment: ["&& denotes a mnemonic"]
			}, "&&Copy"),
			order: 2
		},
		{
			menuId: MenuId.EditorContext,
			group: CLIPBOARD_CONTEXT_MENU_GROUP,
			title: localize("actions.clipboard.copyLabel", "Copy"),
			order: 2
		},
		{
			menuId: MenuId.CommandPalette,
			group: "",
			title: localize("actions.clipboard.copyLabel", "Copy"),
			order: 1
		},
		{
			menuId: MenuId.SimpleEditorContext,
			group: CLIPBOARD_CONTEXT_MENU_GROUP,
			title: localize("actions.clipboard.copyLabel", "Copy"),
			order: 2
		}
	]
})) : void 0;
MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, {
	submenu: MenuId.MenubarCopy,
	title: {
		value: localize("copy as", "Copy As"),
		original: "Copy As"
	},
	group: "2_ccp",
	order: 3
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
	submenu: MenuId.EditorContextCopy,
	title: {
		value: localize("copy as", "Copy As"),
		original: "Copy As"
	},
	group: CLIPBOARD_CONTEXT_MENU_GROUP,
	order: 3
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
	submenu: MenuId.EditorContextShare,
	title: {
		value: localize("share", "Share"),
		original: "Share"
	},
	group: "11_share",
	order: -1
});
const PasteAction = supportsPaste ? registerCommand(new MultiCommand({
	id: "editor.action.clipboardPasteAction",
	precondition: void 0,
	kbOpts: isNative ? {
		primary: 2100,
		win: {
			primary: 2100,
			secondary: [1043]
		},
		linux: {
			primary: 2100,
			secondary: [1043]
		},
		weight: 100
	} : void 0,
	menuOpts: [
		{
			menuId: MenuId.MenubarEditMenu,
			group: "2_ccp",
			title: localize({
				key: "miPaste",
				comment: ["&& denotes a mnemonic"]
			}, "&&Paste"),
			order: 4
		},
		{
			menuId: MenuId.EditorContext,
			group: CLIPBOARD_CONTEXT_MENU_GROUP,
			title: localize("actions.clipboard.pasteLabel", "Paste"),
			when: EditorContextKeys.writable,
			order: 4
		},
		{
			menuId: MenuId.CommandPalette,
			group: "",
			title: localize("actions.clipboard.pasteLabel", "Paste"),
			order: 1
		},
		{
			menuId: MenuId.SimpleEditorContext,
			group: CLIPBOARD_CONTEXT_MENU_GROUP,
			title: localize("actions.clipboard.pasteLabel", "Paste"),
			when: EditorContextKeys.writable,
			order: 4
		}
	]
})) : void 0;
var ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
			label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
			alias: "Copy With Syntax Highlighting",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		if (!editor$1.getOption(33) && editor$1.getSelection().isEmpty()) return;
		CopyOptions.forceCopyWithSyntaxHighlighting = true;
		editor$1.focus();
		document.execCommand("copy");
		CopyOptions.forceCopyWithSyntaxHighlighting = false;
	}
};
function registerExecCommandImpl(target, browserCommand) {
	if (!target) return;
	target.addImplementation(1e4, "code-editor", (accessor, args) => {
		const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
		if (focusedEditor && focusedEditor.hasTextFocus()) {
			const emptySelectionClipboard = focusedEditor.getOption(33);
			const selection = focusedEditor.getSelection();
			if (selection && selection.isEmpty() && !emptySelectionClipboard) return true;
			document.execCommand(browserCommand);
			return true;
		}
		return false;
	});
	target.addImplementation(0, "generic-dom", (accessor, args) => {
		document.execCommand(browserCommand);
		return true;
	});
}
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
	PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
		const codeEditorService = accessor.get(ICodeEditorService);
		const clipboardService = accessor.get(IClipboardService);
		const focusedEditor = codeEditorService.getFocusedCodeEditor();
		if (focusedEditor && focusedEditor.hasTextFocus()) {
			if (!document.execCommand("paste") && isWeb) return (() => __awaiter$55(void 0, void 0, void 0, function* () {
				const clipboardText = yield clipboardService.readText();
				if (clipboardText !== "") {
					const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
					let pasteOnNewLine = false;
					let multicursorText = null;
					let mode = null;
					if (metadata) {
						pasteOnNewLine = focusedEditor.getOption(33) && !!metadata.isFromEmptySelection;
						multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
						mode = metadata.mode;
					}
					focusedEditor.trigger("keyboard", "paste", {
						text: clipboardText,
						pasteOnNewLine,
						multicursorText,
						mode
					});
				}
			}))();
			return true;
		}
		return false;
	});
	PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
		document.execCommand("paste");
		return true;
	});
}
if (supportsCopy) registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/types.js
var CodeActionKind = class CodeActionKind {
	constructor(value) {
		this.value = value;
	}
	equals(other) {
		return this.value === other.value;
	}
	contains(other) {
		return this.equals(other) || this.value === "" || other.value.startsWith(this.value + CodeActionKind.sep);
	}
	intersects(other) {
		return this.contains(other) || other.contains(this);
	}
	append(part) {
		return new CodeActionKind(this.value + CodeActionKind.sep + part);
	}
};
CodeActionKind.sep = ".";
CodeActionKind.None = new CodeActionKind("@@none@@");
CodeActionKind.Empty = new CodeActionKind("");
CodeActionKind.QuickFix = new CodeActionKind("quickfix");
CodeActionKind.Refactor = new CodeActionKind("refactor");
CodeActionKind.Source = new CodeActionKind("source");
CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
var CodeActionTriggerSource;
(function(CodeActionTriggerSource$1) {
	CodeActionTriggerSource$1["Refactor"] = "refactor";
	CodeActionTriggerSource$1["RefactorPreview"] = "refactor preview";
	CodeActionTriggerSource$1["Lightbulb"] = "lightbulb";
	CodeActionTriggerSource$1["Default"] = "other (default)";
	CodeActionTriggerSource$1["SourceAction"] = "source action";
	CodeActionTriggerSource$1["QuickFix"] = "quick fix action";
	CodeActionTriggerSource$1["FixAll"] = "fix all";
	CodeActionTriggerSource$1["OrganizeImports"] = "organize imports";
	CodeActionTriggerSource$1["AutoFix"] = "auto fix";
	CodeActionTriggerSource$1["QuickFixHover"] = "quick fix hover window";
	CodeActionTriggerSource$1["OnSave"] = "save participants";
	CodeActionTriggerSource$1["ProblemsView"] = "problems view";
})(CodeActionTriggerSource || (CodeActionTriggerSource = {}));
function mayIncludeActionsOfKind(filter, providedKind) {
	if (filter.include && !filter.include.intersects(providedKind)) return false;
	if (filter.excludes) {
		if (filter.excludes.some((exclude) => excludesAction(providedKind, exclude, filter.include))) return false;
	}
	if (!filter.includeSourceActions && CodeActionKind.Source.contains(providedKind)) return false;
	return true;
}
function filtersAction(filter, action) {
	const actionKind = action.kind ? new CodeActionKind(action.kind) : void 0;
	if (filter.include) {
		if (!actionKind || !filter.include.contains(actionKind)) return false;
	}
	if (filter.excludes) {
		if (actionKind && filter.excludes.some((exclude) => excludesAction(actionKind, exclude, filter.include))) return false;
	}
	if (!filter.includeSourceActions) {
		if (actionKind && CodeActionKind.Source.contains(actionKind)) return false;
	}
	if (filter.onlyIncludePreferredActions) {
		if (!action.isPreferred) return false;
	}
	return true;
}
function excludesAction(providedKind, exclude, include) {
	if (!exclude.contains(providedKind)) return false;
	if (include && exclude.contains(include)) return false;
	return true;
}
var CodeActionCommandArgs = class CodeActionCommandArgs {
	constructor(kind, apply, preferred) {
		this.kind = kind;
		this.apply = apply;
		this.preferred = preferred;
	}
	static fromUser(arg, defaults) {
		if (!arg || typeof arg !== "object") return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);
		return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));
	}
	static getApplyFromUser(arg, defaultAutoApply) {
		switch (typeof arg.apply === "string" ? arg.apply.toLowerCase() : "") {
			case "first": return "first";
			case "never": return "never";
			case "ifsingle": return "ifSingle";
			default: return defaultAutoApply;
		}
	}
	static getKindFromUser(arg, defaultKind) {
		return typeof arg.kind === "string" ? new CodeActionKind(arg.kind) : defaultKind;
	}
	static getPreferredUser(arg) {
		return typeof arg.preferred === "boolean" ? arg.preferred : false;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeAction.js
var __awaiter$54 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const codeActionCommandId = "editor.action.codeAction";
const refactorCommandId = "editor.action.refactor";
const refactorPreviewCommandId = "editor.action.refactor.preview";
const sourceActionCommandId = "editor.action.sourceAction";
const organizeImportsCommandId = "editor.action.organizeImports";
const fixAllCommandId = "editor.action.fixAll";
var CodeActionItem = class {
	constructor(action, provider) {
		this.action = action;
		this.provider = provider;
	}
	resolve(token) {
		var _a$5;
		return __awaiter$54(this, void 0, void 0, function* () {
			if (((_a$5 = this.provider) === null || _a$5 === void 0 ? void 0 : _a$5.resolveCodeAction) && !this.action.edit) {
				let action;
				try {
					action = yield this.provider.resolveCodeAction(this.action, token);
				} catch (err) {
					onUnexpectedExternalError(err);
				}
				if (action) this.action.edit = action.edit;
			}
			return this;
		});
	}
};
var ManagedCodeActionSet = class ManagedCodeActionSet extends Disposable {
	constructor(actions, documentation, disposables) {
		super();
		this.documentation = documentation;
		this._register(disposables);
		this.allActions = [...actions].sort(ManagedCodeActionSet.codeActionsComparator);
		this.validActions = this.allActions.filter(({ action }) => !action.disabled);
	}
	static codeActionsComparator({ action: a }, { action: b }) {
		if (a.isPreferred && !b.isPreferred) return -1;
		else if (!a.isPreferred && b.isPreferred) return 1;
		if (isNonEmptyArray(a.diagnostics)) if (isNonEmptyArray(b.diagnostics)) return a.diagnostics[0].message.localeCompare(b.diagnostics[0].message);
		else return -1;
		else if (isNonEmptyArray(b.diagnostics)) return 1;
		else return 0;
	}
	get hasAutoFix() {
		return this.validActions.some(({ action: fix }) => !!fix.kind && CodeActionKind.QuickFix.contains(new CodeActionKind(fix.kind)) && !!fix.isPreferred);
	}
};
var emptyCodeActionsResponse = {
	actions: [],
	documentation: void 0
};
function getCodeActions(registry, model, rangeOrSelection, trigger, progress, token) {
	var _a$5;
	const filter = trigger.filter || {};
	const codeActionContext = {
		only: (_a$5 = filter.include) === null || _a$5 === void 0 ? void 0 : _a$5.value,
		trigger: trigger.type
	};
	const cts = new TextModelCancellationTokenSource(model, token);
	const providers = getCodeActionProviders(registry, model, filter);
	const disposables = new DisposableStore();
	const promises = providers.map((provider) => __awaiter$54(this, void 0, void 0, function* () {
		try {
			progress.report(provider);
			const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
			if (providedCodeActions) disposables.add(providedCodeActions);
			if (cts.token.isCancellationRequested) return emptyCodeActionsResponse;
			const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter((action) => action && filtersAction(filter, action));
			const documentation = getDocumentation(provider, filteredActions, filter.include);
			return {
				actions: filteredActions.map((action) => new CodeActionItem(action, provider)),
				documentation
			};
		} catch (err) {
			if (isCancellationError(err)) throw err;
			onUnexpectedExternalError(err);
			return emptyCodeActionsResponse;
		}
	}));
	const listener = registry.onDidChange(() => {
		if (!equals(registry.all(model), providers)) cts.cancel();
	});
	return Promise.all(promises).then((actions) => {
		return new ManagedCodeActionSet(actions.map((x) => x.actions).flat(), coalesce(actions.map((x) => x.documentation)), disposables);
	}).finally(() => {
		listener.dispose();
		cts.dispose();
	});
}
function getCodeActionProviders(registry, model, filter) {
	return registry.all(model).filter((provider) => {
		if (!provider.providedCodeActionKinds) return true;
		return provider.providedCodeActionKinds.some((kind) => mayIncludeActionsOfKind(filter, new CodeActionKind(kind)));
	});
}
function getDocumentation(provider, providedCodeActions, only) {
	if (!provider.documentation) return;
	const documentation = provider.documentation.map((entry) => ({
		kind: new CodeActionKind(entry.kind),
		command: entry.command
	}));
	if (only) {
		let currentBest;
		for (const entry of documentation) if (entry.kind.contains(only)) {
			if (!currentBest) currentBest = entry;
			else if (currentBest.kind.contains(entry.kind)) currentBest = entry;
		}
		if (currentBest) return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;
	}
	for (const action of providedCodeActions) {
		if (!action.kind) continue;
		for (const entry of documentation) if (entry.kind.contains(new CodeActionKind(action.kind))) return entry.command;
	}
}
CommandsRegistry.registerCommand("_executeCodeActionProvider", function(accessor, resource, rangeOrSelection, kind, itemResolveCount) {
	return __awaiter$54(this, void 0, void 0, function* () {
		if (!(resource instanceof URI)) throw illegalArgument();
		const { codeActionProvider } = accessor.get(ILanguageFeaturesService);
		const model = accessor.get(IModelService).getModel(resource);
		if (!model) throw illegalArgument();
		const validatedRangeOrSelection = Selection$1.isISelection(rangeOrSelection) ? Selection$1.liftSelection(rangeOrSelection) : Range$1.isIRange(rangeOrSelection) ? model.validateRange(rangeOrSelection) : void 0;
		if (!validatedRangeOrSelection) throw illegalArgument();
		const include = typeof kind === "string" ? new CodeActionKind(kind) : void 0;
		const codeActionSet = yield getCodeActions(codeActionProvider, model, validatedRangeOrSelection, {
			type: 1,
			triggerAction: CodeActionTriggerSource.Default,
			filter: {
				includeSourceActions: true,
				include
			}
		}, Progress.None, CancellationToken.None);
		const resolving = [];
		const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === "number" ? itemResolveCount : 0);
		for (let i = 0; i < resolveCount; i++) resolving.push(codeActionSet.validActions[i].resolve(CancellationToken.None));
		try {
			yield Promise.all(resolving);
			return codeActionSet.validActions.map((item) => item.action);
		} finally {
			setTimeout(() => codeActionSet.dispose(), 100);
		}
	});
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/message/browser/messageController.js
var __decorate$80 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$80 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var MessageController = class MessageController$1 {
	constructor(editor$1, contextKeyService) {
		this._messageWidget = new MutableDisposable();
		this._messageListeners = new DisposableStore();
		this._editor = editor$1;
		this._visible = MessageController$1.MESSAGE_VISIBLE.bindTo(contextKeyService);
	}
	static get(editor$1) {
		return editor$1.getContribution(MessageController$1.ID);
	}
	dispose() {
		this._messageListeners.dispose();
		this._messageWidget.dispose();
		this._visible.reset();
	}
	showMessage(message, position) {
		alert(message);
		this._visible.set(true);
		this._messageWidget.clear();
		this._messageListeners.clear();
		this._messageWidget.value = new MessageWidget$1(this._editor, position, message);
		this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage()));
		this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
		this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
		this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
		this._messageListeners.add(new TimeoutTimer(() => this.closeMessage(), 3e3));
		let bounds;
		this._messageListeners.add(this._editor.onMouseMove((e) => {
			if (!e.target.position) return;
			if (!bounds) bounds = new Range$1(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
			else if (!bounds.containsPosition(e.target.position)) this.closeMessage();
		}));
	}
	closeMessage() {
		this._visible.reset();
		this._messageListeners.clear();
		if (this._messageWidget.value) this._messageListeners.add(MessageWidget$1.fadeOut(this._messageWidget.value));
	}
};
MessageController.ID = "editor.contrib.messageController";
MessageController.MESSAGE_VISIBLE = new RawContextKey("messageVisible", false, localize("messageVisible", "Whether the editor is currently showing an inline message"));
MessageController = __decorate$80([__param$80(1, IContextKeyService)], MessageController);
registerEditorCommand(new (EditorCommand.bindToContribution(MessageController.get))({
	id: "leaveEditorMessage",
	precondition: MessageController.MESSAGE_VISIBLE,
	handler: (c) => c.closeMessage(),
	kbOpts: {
		weight: 130,
		primary: 9
	}
}));
var MessageWidget$1 = class {
	constructor(editor$1, { lineNumber, column }, text) {
		this.allowEditorOverflow = true;
		this.suppressMouseDown = false;
		this._editor = editor$1;
		this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0);
		this._position = {
			lineNumber,
			column
		};
		this._domNode = document.createElement("div");
		this._domNode.classList.add("monaco-editor-overlaymessage");
		this._domNode.style.marginLeft = "-6px";
		const anchorTop = document.createElement("div");
		anchorTop.classList.add("anchor", "top");
		this._domNode.appendChild(anchorTop);
		const message = document.createElement("div");
		message.classList.add("message");
		message.textContent = text;
		this._domNode.appendChild(message);
		const anchorBottom = document.createElement("div");
		anchorBottom.classList.add("anchor", "below");
		this._domNode.appendChild(anchorBottom);
		this._editor.addContentWidget(this);
		this._domNode.classList.add("fadeIn");
	}
	static fadeOut(messageWidget) {
		const dispose$1 = () => {
			messageWidget.dispose();
			clearTimeout(handle);
			messageWidget.getDomNode().removeEventListener("animationend", dispose$1);
		};
		const handle = setTimeout(dispose$1, 110);
		messageWidget.getDomNode().addEventListener("animationend", dispose$1);
		messageWidget.getDomNode().classList.add("fadeOut");
		return { dispose: dispose$1 };
	}
	dispose() {
		this._editor.removeContentWidget(this);
	}
	getId() {
		return "messageoverlay";
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		return {
			position: this._position,
			preference: [1, 2],
			positionAffinity: 1
		};
	}
	afterRender(position) {
		this._domNode.classList.toggle("below", position === 2);
	}
};
registerEditorContribution(MessageController.ID, MessageController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionMenu.js
var __decorate$79 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$79 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$53 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const Context$2 = { Visible: new RawContextKey("CodeActionMenuVisible", false, localize("CodeActionMenuVisible", "Whether the code action list widget is visible")) };
var CodeActionAction = class extends Action {
	constructor(action, callback) {
		super(action.command ? action.command.id : action.title, stripNewlines(action.title), void 0, !action.disabled, callback);
		this.action = action;
	}
};
function stripNewlines(str) {
	return str.replace(/\r\n|\r|\n/g, " ");
}
var TEMPLATE_ID = "codeActionWidget";
var codeActionLineHeight = 26;
var CodeMenuRenderer = class CodeMenuRenderer$1 {
	constructor(acceptKeybindings, keybindingService) {
		this.acceptKeybindings = acceptKeybindings;
		this.keybindingService = keybindingService;
	}
	get templateId() {
		return TEMPLATE_ID;
	}
	renderTemplate(container) {
		const data = Object.create(null);
		data.disposables = [];
		data.root = container;
		data.text = document.createElement("span");
		container.append(data.text);
		return data;
	}
	renderElement(element, index, templateData) {
		const data = templateData;
		const text = element.title;
		const isEnabled = element.isEnabled;
		const isSeparator = element.isSeparator;
		const isDocumentation = element.isDocumentation;
		data.text.textContent = text;
		if (!isEnabled) {
			data.root.classList.add("option-disabled");
			data.root.style.backgroundColor = "transparent !important";
		} else data.root.classList.remove("option-disabled");
		if (isSeparator) {
			data.root.classList.add("separator");
			data.root.style.height = "10px";
		}
		if (!isDocumentation) {
			const updateLabel = () => {
				var _a$5, _b$1;
				const [accept, preview] = this.acceptKeybindings;
				data.root.title = localize({
					key: "label",
					comment: ["placeholders are keybindings, e.g \"F2 to Refactor, Shift+F2 to Preview\""]
				}, "{0} to Refactor, {1} to Preview", (_a$5 = this.keybindingService.lookupKeybinding(accept)) === null || _a$5 === void 0 ? void 0 : _a$5.getLabel(), (_b$1 = this.keybindingService.lookupKeybinding(preview)) === null || _b$1 === void 0 ? void 0 : _b$1.getLabel());
			};
			updateLabel();
		}
	}
	disposeTemplate(templateData) {
		templateData.disposables = dispose(templateData.disposables);
	}
};
CodeMenuRenderer = __decorate$79([__param$79(1, IKeybindingService)], CodeMenuRenderer);
var CodeActionMenu = class CodeActionMenu$1 extends Disposable {
	constructor(_editor, _delegate, _contextMenuService, keybindingService, _languageFeaturesService, _telemetryService, _themeService, _configurationService, _contextViewService, _contextKeyService) {
		super();
		this._editor = _editor;
		this._delegate = _delegate;
		this._contextMenuService = _contextMenuService;
		this._languageFeaturesService = _languageFeaturesService;
		this._telemetryService = _telemetryService;
		this._configurationService = _configurationService;
		this._contextViewService = _contextViewService;
		this._contextKeyService = _contextKeyService;
		this._showingActions = this._register(new MutableDisposable());
		this.codeActionList = this._register(new MutableDisposable());
		this.options = [];
		this._visible = false;
		this.viewItems = [];
		this.hasSeperator = false;
		this._keybindingResolver = new CodeActionKeybindingResolver({ getKeybindings: () => keybindingService.getKeybindings() });
		this._ctxMenuWidgetVisible = Context$2.Visible.bindTo(this._contextKeyService);
		this.listRenderer = new CodeMenuRenderer([`onEnterSelectCodeAction`, `onEnterSelectCodeActionWithPreview`], keybindingService);
	}
	get isVisible() {
		return this._visible;
	}
	isCodeActionWidgetEnabled(model) {
		return this._configurationService.getValue("editor.experimental.useCustomCodeActionMenu", { resource: model.uri });
	}
	_onListSelection(e) {
		if (e.elements.length) e.elements.forEach((element) => {
			if (element.isEnabled) {
				element.action.run();
				this.hideCodeActionWidget();
			}
		});
	}
	_onListHover(e) {
		var _a$5, _b$1, _c$1, _d$1;
		if (!e.element) {
			this.currSelectedItem = void 0;
			(_a$5 = this.codeActionList.value) === null || _a$5 === void 0 || _a$5.setFocus([]);
		} else if ((_b$1 = e.element) === null || _b$1 === void 0 ? void 0 : _b$1.isEnabled) {
			(_c$1 = this.codeActionList.value) === null || _c$1 === void 0 || _c$1.setFocus([e.element.index]);
			this.focusedEnabledItem = this.viewItems.indexOf(e.element);
			this.currSelectedItem = e.element.index;
		} else {
			this.currSelectedItem = void 0;
			(_d$1 = this.codeActionList.value) === null || _d$1 === void 0 || _d$1.setFocus([e.element.index]);
		}
	}
	renderCodeActionMenuList(element, inputArray) {
		var _a$5;
		const renderDisposables = new DisposableStore();
		const renderMenu = document.createElement("div");
		const menuBlock = document.createElement("div");
		this.block = element.appendChild(menuBlock);
		this.block.classList.add("context-view-block");
		this.block.style.position = "fixed";
		this.block.style.cursor = "initial";
		this.block.style.left = "0";
		this.block.style.top = "0";
		this.block.style.width = "100%";
		this.block.style.height = "100%";
		this.block.style.zIndex = "-1";
		renderDisposables.add(addDisposableListener(this.block, EventType$1.MOUSE_DOWN, (e) => e.stopPropagation()));
		renderMenu.id = "codeActionMenuWidget";
		renderMenu.classList.add("codeActionMenuWidget");
		element.appendChild(renderMenu);
		this.codeActionList.value = new List("codeActionWidget", renderMenu, {
			getHeight(element$1) {
				if (element$1.isSeparator) return 10;
				return codeActionLineHeight;
			},
			getTemplateId(element$1) {
				return "codeActionWidget";
			}
		}, [this.listRenderer], { keyboardSupport: false });
		renderDisposables.add(this.codeActionList.value.onMouseOver((e) => this._onListHover(e)));
		renderDisposables.add(this.codeActionList.value.onDidChangeFocus((e) => {
			var _a$6;
			return (_a$6 = this.codeActionList.value) === null || _a$6 === void 0 ? void 0 : _a$6.domFocus();
		}));
		renderDisposables.add(this.codeActionList.value.onDidChangeSelection((e) => this._onListSelection(e)));
		renderDisposables.add(this._editor.onDidLayoutChange((e) => this.hideCodeActionWidget()));
		inputArray.forEach((item, index) => {
			const currIsSeparator = item.class === "separator";
			let isDocumentation = false;
			if (item instanceof CodeActionAction) isDocumentation = item.action.kind === CodeActionMenu$1.documentationID;
			if (currIsSeparator) this.hasSeperator = true;
			const menuItem = {
				title: item.label,
				detail: item.tooltip,
				action: inputArray[index],
				isEnabled: item.enabled,
				isSeparator: currIsSeparator,
				index,
				isDocumentation
			};
			if (item.enabled) this.viewItems.push(menuItem);
			this.options.push(menuItem);
		});
		this.codeActionList.value.splice(0, this.codeActionList.value.length, this.options);
		const height = this.hasSeperator ? (inputArray.length - 1) * codeActionLineHeight + 10 : inputArray.length * codeActionLineHeight;
		renderMenu.style.height = String(height) + "px";
		this.codeActionList.value.layout(height);
		const arr = [];
		this.options.forEach((item, index) => {
			var _a$6, _b$1;
			if (!this.codeActionList.value) return;
			const element$1 = (_b$1 = document.getElementById((_a$6 = this.codeActionList.value) === null || _a$6 === void 0 ? void 0 : _a$6.getElementID(index))) === null || _b$1 === void 0 ? void 0 : _b$1.getElementsByTagName("span")[0].offsetWidth;
			arr.push(Number(element$1));
		});
		const maxWidth = Math.max(...arr);
		renderMenu.style.width = maxWidth + 52 + "px";
		(_a$5 = this.codeActionList.value) === null || _a$5 === void 0 || _a$5.layout(height, maxWidth);
		if (this.viewItems.length < 1 || this.viewItems.every((item) => item.isDocumentation)) this.currSelectedItem = void 0;
		else {
			this.focusedEnabledItem = 0;
			this.currSelectedItem = this.viewItems[0].index;
			this.codeActionList.value.setFocus([this.currSelectedItem]);
		}
		this.codeActionList.value.domFocus();
		const focusTracker = trackFocus(element);
		const blurListener = focusTracker.onDidBlur(() => {
			this.hideCodeActionWidget();
		});
		renderDisposables.add(blurListener);
		renderDisposables.add(focusTracker);
		this._ctxMenuWidgetVisible.set(true);
		return renderDisposables;
	}
	focusPrevious() {
		var _a$5;
		if (typeof this.focusedEnabledItem === "undefined") this.focusedEnabledItem = this.viewItems[0].index;
		else if (this.viewItems.length < 1) return false;
		const startIndex = this.focusedEnabledItem;
		let item;
		do {
			this.focusedEnabledItem = this.focusedEnabledItem - 1;
			if (this.focusedEnabledItem < 0) this.focusedEnabledItem = this.viewItems.length - 1;
			item = this.viewItems[this.focusedEnabledItem];
			(_a$5 = this.codeActionList.value) === null || _a$5 === void 0 || _a$5.setFocus([item.index]);
			this.currSelectedItem = item.index;
		} while (this.focusedEnabledItem !== startIndex && (!item.isEnabled || item.action.id === Separator.ID));
		return true;
	}
	focusNext() {
		var _a$5;
		if (typeof this.focusedEnabledItem === "undefined") this.focusedEnabledItem = this.viewItems.length - 1;
		else if (this.viewItems.length < 1) return false;
		const startIndex = this.focusedEnabledItem;
		let item;
		do {
			this.focusedEnabledItem = (this.focusedEnabledItem + 1) % this.viewItems.length;
			item = this.viewItems[this.focusedEnabledItem];
			(_a$5 = this.codeActionList.value) === null || _a$5 === void 0 || _a$5.setFocus([item.index]);
			this.currSelectedItem = item.index;
		} while (this.focusedEnabledItem !== startIndex && (!item.isEnabled || item.action.id === Separator.ID));
		return true;
	}
	navigateListWithKeysUp() {
		this.focusPrevious();
	}
	navigateListWithKeysDown() {
		this.focusNext();
	}
	onEnterSet() {
		var _a$5;
		if (typeof this.currSelectedItem === "number") (_a$5 = this.codeActionList.value) === null || _a$5 === void 0 || _a$5.setSelection([this.currSelectedItem]);
	}
	dispose() {
		super.dispose();
	}
	hideCodeActionWidget() {
		this._ctxMenuWidgetVisible.reset();
		this.options = [];
		this.viewItems = [];
		this.focusedEnabledItem = 0;
		this.currSelectedItem = void 0;
		this.hasSeperator = false;
		this._contextViewService.hideContextView({ source: this });
	}
	codeActionTelemetry(openedFromString, didCancel, CodeActions) {
		this._telemetryService.publicLog2("codeAction.applyCodeAction", {
			codeActionFrom: openedFromString,
			validCodeActions: CodeActions.validActions.length,
			cancelled: didCancel
		});
	}
	show(trigger, codeActions, at, options) {
		return __awaiter$53(this, void 0, void 0, function* () {
			const model = this._editor.getModel();
			if (!model) return;
			const actionsToShow = options.includeDisabledActions ? codeActions.allActions : codeActions.validActions;
			if (!actionsToShow.length) {
				this._visible = false;
				return;
			}
			if (!this._editor.getDomNode()) {
				this._visible = false;
				throw canceled();
			}
			this._visible = true;
			this._showingActions.value = codeActions;
			const menuActions = this.getMenuActions(trigger, actionsToShow, codeActions.documentation);
			const anchor = Position$1.isIPosition(at) ? this._toCoords(at) : at || {
				x: 0,
				y: 0
			};
			const resolver = this._keybindingResolver.getResolver();
			const useShadowDOM = this._editor.getOption(117);
			if (this.isCodeActionWidgetEnabled(model)) this._contextViewService.showContextView({
				getAnchor: () => anchor,
				render: (container) => this.renderCodeActionMenuList(container, menuActions),
				onHide: (didCancel) => {
					const openedFromString = options.fromLightbulb ? CodeActionTriggerSource.Lightbulb : trigger.triggerAction;
					this.codeActionTelemetry(openedFromString, didCancel, codeActions);
					this._visible = false;
					this._editor.focus();
				}
			}, this._editor.getDomNode(), false);
			else this._contextMenuService.showContextMenu({
				domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
				getAnchor: () => anchor,
				getActions: () => menuActions,
				onHide: (didCancel) => {
					const openedFromString = options.fromLightbulb ? CodeActionTriggerSource.Lightbulb : trigger.triggerAction;
					this.codeActionTelemetry(openedFromString, didCancel, codeActions);
					this._visible = false;
					this._editor.focus();
				},
				autoSelectFirstItem: true,
				getKeyBinding: (action) => action instanceof CodeActionAction ? resolver(action.action) : void 0
			});
		});
	}
	getMenuActions(trigger, actionsToShow, documentation) {
		var _a$5, _b$1;
		const toCodeActionAction = (item) => new CodeActionAction(item.action, () => this._delegate.onSelectCodeAction(item, trigger));
		const result = actionsToShow.map(toCodeActionAction);
		const allDocumentation = [...documentation];
		const model = this._editor.getModel();
		if (model && result.length) {
			for (const provider of this._languageFeaturesService.codeActionProvider.all(model)) if (provider._getAdditionalMenuItems) allDocumentation.push(...provider._getAdditionalMenuItems({
				trigger: trigger.type,
				only: (_b$1 = (_a$5 = trigger.filter) === null || _a$5 === void 0 ? void 0 : _a$5.include) === null || _b$1 === void 0 ? void 0 : _b$1.value
			}, actionsToShow.map((item) => item.action)));
		}
		if (allDocumentation.length) result.push(new Separator(), ...allDocumentation.map((command) => toCodeActionAction(new CodeActionItem({
			title: command.title,
			command,
			kind: CodeActionMenu$1.documentationID
		}, void 0))));
		return result;
	}
	_toCoords(position) {
		if (!this._editor.hasModel()) return {
			x: 0,
			y: 0
		};
		this._editor.revealPosition(position, 1);
		this._editor.render();
		const cursorCoords = this._editor.getScrolledVisiblePosition(position);
		const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
		return {
			x: editorCoords.left + cursorCoords.left,
			y: editorCoords.top + cursorCoords.top + cursorCoords.height
		};
	}
};
CodeActionMenu.documentationID = "_documentation";
CodeActionMenu = __decorate$79([
	__param$79(2, IContextMenuService),
	__param$79(3, IKeybindingService),
	__param$79(4, ILanguageFeaturesService),
	__param$79(5, ITelemetryService),
	__param$79(6, IThemeService),
	__param$79(7, IConfigurationService),
	__param$79(8, IContextViewService),
	__param$79(9, IContextKeyService)
], CodeActionMenu);
var CodeActionKeybindingResolver = class CodeActionKeybindingResolver {
	constructor(_keybindingProvider) {
		this._keybindingProvider = _keybindingProvider;
	}
	getResolver() {
		const allCodeActionBindings = new Lazy(() => this._keybindingProvider.getKeybindings().filter((item) => CodeActionKeybindingResolver.codeActionCommands.indexOf(item.command) >= 0).filter((item) => item.resolvedKeybinding).map((item) => {
			let commandArgs = item.commandArgs;
			if (item.command === organizeImportsCommandId) commandArgs = { kind: CodeActionKind.SourceOrganizeImports.value };
			else if (item.command === fixAllCommandId) commandArgs = { kind: CodeActionKind.SourceFixAll.value };
			return Object.assign({ resolvedKeybinding: item.resolvedKeybinding }, CodeActionCommandArgs.fromUser(commandArgs, {
				kind: CodeActionKind.None,
				apply: "never"
			}));
		}));
		return (action) => {
			if (action.kind) {
				const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.getValue());
				return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;
			}
		};
	}
	bestKeybindingForCodeAction(action, candidates) {
		if (!action.kind) return;
		const kind = new CodeActionKind(action.kind);
		return candidates.filter((candidate) => candidate.kind.contains(kind)).filter((candidate) => {
			if (candidate.preferred) return action.isPreferred;
			return true;
		}).reduceRight((currentBest, candidate) => {
			if (!currentBest) return candidate;
			return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;
		}, void 0);
	}
};
CodeActionKeybindingResolver.codeActionCommands = [
	refactorCommandId,
	codeActionCommandId,
	sourceActionCommandId,
	organizeImportsCommandId,
	fixAllCommandId
];

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/lightBulbWidget.js
var __decorate$78 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$78 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var LightBulbState;
(function(LightBulbState$1) {
	LightBulbState$1.Hidden = { type: 0 };
	class Showing {
		constructor(actions, trigger, editorPosition, widgetPosition) {
			this.actions = actions;
			this.trigger = trigger;
			this.editorPosition = editorPosition;
			this.widgetPosition = widgetPosition;
			this.type = 1;
		}
	}
	LightBulbState$1.Showing = Showing;
})(LightBulbState || (LightBulbState = {}));
var LightBulbWidget = class LightBulbWidget$1 extends Disposable {
	constructor(_editor, _quickFixActionId, _preferredFixActionId, _keybindingService) {
		super();
		this._editor = _editor;
		this._quickFixActionId = _quickFixActionId;
		this._preferredFixActionId = _preferredFixActionId;
		this._keybindingService = _keybindingService;
		this._onClick = this._register(new Emitter$1());
		this.onClick = this._onClick.event;
		this._state = LightBulbState.Hidden;
		this._domNode = document.createElement("div");
		this._domNode.className = Codicon.lightBulb.classNames;
		this._editor.addContentWidget(this);
		this._register(this._editor.onDidChangeModelContent((_) => {
			const editorModel = this._editor.getModel();
			if (this.state.type !== 1 || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) this.hide();
		}));
		Gesture.ignoreTarget(this._domNode);
		this._register(addStandardDisposableGenericMouseDownListener(this._domNode, (e) => {
			if (this.state.type !== 1) return;
			this._editor.focus();
			e.preventDefault();
			const { top, height } = getDomNodePagePosition(this._domNode);
			const lineHeight = this._editor.getOption(61);
			let pad = Math.floor(lineHeight / 3);
			if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) pad += lineHeight;
			this._onClick.fire({
				x: e.posx,
				y: top + height + pad,
				actions: this.state.actions,
				trigger: this.state.trigger
			});
		}));
		this._register(addDisposableListener(this._domNode, "mouseenter", (e) => {
			if ((e.buttons & 1) !== 1) return;
			this.hide();
		}));
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(59) && !this._editor.getOption(59).enabled) this.hide();
		}));
		this._updateLightBulbTitleAndIcon();
		this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));
	}
	dispose() {
		super.dispose();
		this._editor.removeContentWidget(this);
	}
	getId() {
		return "LightBulbWidget";
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		return this._state.type === 1 ? this._state.widgetPosition : null;
	}
	update(actions, trigger, atPosition) {
		if (actions.validActions.length <= 0) return this.hide();
		const options = this._editor.getOptions();
		if (!options.get(59).enabled) return this.hide();
		const model = this._editor.getModel();
		if (!model) return this.hide();
		const { lineNumber, column } = model.validatePosition(atPosition);
		const tabSize = model.getOptions().tabSize;
		const fontInfo = options.get(46);
		const indent = computeIndentLevel(model.getLineContent(lineNumber), tabSize);
		const lineHasSpace = fontInfo.spaceWidth * indent > 22;
		const isFolded = (lineNumber$1) => {
			return lineNumber$1 > 2 && this._editor.getTopForLineNumber(lineNumber$1) === this._editor.getTopForLineNumber(lineNumber$1 - 1);
		};
		let effectiveLineNumber = lineNumber;
		if (!lineHasSpace) {
			if (lineNumber > 1 && !isFolded(lineNumber - 1)) effectiveLineNumber -= 1;
			else if (!isFolded(lineNumber + 1)) effectiveLineNumber += 1;
			else if (column * fontInfo.spaceWidth < 22) return this.hide();
		}
		this.state = new LightBulbState.Showing(actions, trigger, atPosition, {
			position: {
				lineNumber: effectiveLineNumber,
				column: 1
			},
			preference: LightBulbWidget$1._posPref
		});
		this._editor.layoutContentWidget(this);
	}
	hide() {
		this.state = LightBulbState.Hidden;
		this._editor.layoutContentWidget(this);
	}
	get state() {
		return this._state;
	}
	set state(value) {
		this._state = value;
		this._updateLightBulbTitleAndIcon();
	}
	_updateLightBulbTitleAndIcon() {
		if (this.state.type === 1 && this.state.actions.hasAutoFix) {
			this._domNode.classList.remove(...Codicon.lightBulb.classNamesArray);
			this._domNode.classList.add(...Codicon.lightbulbAutofix.classNamesArray);
			const preferredKb = this._keybindingService.lookupKeybinding(this._preferredFixActionId);
			if (preferredKb) {
				this.title = localize("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", preferredKb.getLabel());
				return;
			}
		}
		this._domNode.classList.remove(...Codicon.lightbulbAutofix.classNamesArray);
		this._domNode.classList.add(...Codicon.lightBulb.classNamesArray);
		const kb = this._keybindingService.lookupKeybinding(this._quickFixActionId);
		if (kb) this.title = localize("codeActionWithKb", "Show Code Actions ({0})", kb.getLabel());
		else this.title = localize("codeAction", "Show Code Actions");
	}
	set title(value) {
		this._domNode.title = value;
	}
};
LightBulbWidget._posPref = [0];
LightBulbWidget = __decorate$78([__param$78(3, IKeybindingService)], LightBulbWidget);
registerThemingParticipant((theme, collector) => {
	var _a$5;
	const editorBackgroundColor = (_a$5 = theme.getColor(editorBackground)) === null || _a$5 === void 0 ? void 0 : _a$5.transparent(.7);
	const editorLightBulbForegroundColor = theme.getColor(editorLightBulbForeground);
	if (editorLightBulbForegroundColor) collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightBulb.cssSelector} {
			color: ${editorLightBulbForegroundColor};
			background-color: ${editorBackgroundColor};
		}`);
	const editorLightBulbAutoFixForegroundColor = theme.getColor(editorLightBulbAutoFixForeground);
	if (editorLightBulbAutoFixForegroundColor) collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightbulbAutofix.cssSelector} {
			color: ${editorLightBulbAutoFixForegroundColor};
			background-color: ${editorBackgroundColor};
		}`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionUi.js
var __decorate$77 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$77 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$52 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var __classPrivateFieldSet$1 = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CodeActionUi_disposed;
var CodeActionUi = class CodeActionUi$1 extends Disposable {
	constructor(_editor, quickFixActionId, preferredFixActionId, delegate, instantiationService) {
		super();
		this._editor = _editor;
		this.delegate = delegate;
		this._activeCodeActions = this._register(new MutableDisposable());
		this.previewOn = false;
		_CodeActionUi_disposed.set(this, false);
		this._codeActionWidget = new Lazy(() => {
			return this._register(instantiationService.createInstance(CodeActionMenu, this._editor, { onSelectCodeAction: (action, trigger) => __awaiter$52(this, void 0, void 0, function* () {
				if (this.previewOn) this.delegate.applyCodeAction(action, true, Boolean(this.previewOn));
				else this.delegate.applyCodeAction(action, true, Boolean(trigger.preview));
				this.previewOn = false;
			}) }));
		});
		this._lightBulbWidget = new Lazy(() => {
			const widget = this._register(instantiationService.createInstance(LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));
			this._register(widget.onClick((e) => this.showCodeActionList(e.trigger, e.actions, e, {
				includeDisabledActions: false,
				fromLightbulb: true
			})));
			return widget;
		});
	}
	dispose() {
		__classPrivateFieldSet$1(this, _CodeActionUi_disposed, true, "f");
		super.dispose();
	}
	hideCodeActionWidget() {
		if (this._codeActionWidget.hasValue()) this._codeActionWidget.getValue().hideCodeActionWidget();
	}
	onEnter() {
		if (this._codeActionWidget.hasValue()) this._codeActionWidget.getValue().onEnterSet();
	}
	onPreviewEnter() {
		this.previewOn = true;
		this.onEnter();
	}
	navigateList(navUp) {
		if (this._codeActionWidget.hasValue()) if (navUp) this._codeActionWidget.getValue().navigateListWithKeysUp();
		else this._codeActionWidget.getValue().navigateListWithKeysDown();
	}
	update(newState) {
		var _a$5, _b$1, _c$1, _d$1, _e$1;
		return __awaiter$52(this, void 0, void 0, function* () {
			if (newState.type !== 1) {
				(_a$5 = this._lightBulbWidget.rawValue) === null || _a$5 === void 0 || _a$5.hide();
				return;
			}
			let actions;
			try {
				actions = yield newState.actions;
			} catch (e) {
				onUnexpectedError(e);
				return;
			}
			if (__classPrivateFieldGet$1(this, _CodeActionUi_disposed, "f")) return;
			this._lightBulbWidget.getValue().update(actions, newState.trigger, newState.position);
			if (newState.trigger.type === 1) {
				if ((_b$1 = newState.trigger.filter) === null || _b$1 === void 0 ? void 0 : _b$1.include) {
					const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
					if (validActionToApply) {
						try {
							this._lightBulbWidget.getValue().hide();
							yield this.delegate.applyCodeAction(validActionToApply, false, false);
						} finally {
							actions.dispose();
						}
						return;
					}
					if (newState.trigger.context) {
						const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
						if (invalidAction && invalidAction.action.disabled) {
							(_c$1 = MessageController.get(this._editor)) === null || _c$1 === void 0 || _c$1.showMessage(invalidAction.action.disabled, newState.trigger.context.position);
							actions.dispose();
							return;
						}
					}
				}
				const includeDisabledActions = !!((_d$1 = newState.trigger.filter) === null || _d$1 === void 0 ? void 0 : _d$1.include);
				if (newState.trigger.context) {
					if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
						(_e$1 = MessageController.get(this._editor)) === null || _e$1 === void 0 || _e$1.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
						this._activeCodeActions.value = actions;
						actions.dispose();
						return;
					}
				}
				this._activeCodeActions.value = actions;
				this._codeActionWidget.getValue().show(newState.trigger, actions, newState.position, {
					includeDisabledActions,
					fromLightbulb: false
				});
			} else if (this._codeActionWidget.getValue().isVisible) actions.dispose();
			else this._activeCodeActions.value = actions;
		});
	}
	getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
		if (!actions.allActions.length) return;
		if (trigger.autoApply === "first" && actions.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions.allActions.length === 1) return actions.allActions.find(({ action }) => action.disabled);
	}
	tryGetValidActionToApply(trigger, actions) {
		if (!actions.validActions.length) return;
		if (trigger.autoApply === "first" && actions.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions.validActions.length === 1) return actions.validActions[0];
	}
	showCodeActionList(trigger, actions, at, options) {
		return __awaiter$52(this, void 0, void 0, function* () {
			this._codeActionWidget.getValue().show(trigger, actions, at, options);
		});
	}
};
_CodeActionUi_disposed = /* @__PURE__ */ new WeakMap();
CodeActionUi = __decorate$77([__param$77(4, IInstantiationService)], CodeActionUi);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionModel.js
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _CodeActionModel_isDisposed;
const SUPPORTED_CODE_ACTIONS = new RawContextKey("supportedCodeAction", "");
var CodeActionOracle = class extends Disposable {
	constructor(_editor, _markerService, _signalChange, _delay = 250) {
		super();
		this._editor = _editor;
		this._markerService = _markerService;
		this._signalChange = _signalChange;
		this._delay = _delay;
		this._autoTriggerTimer = this._register(new TimeoutTimer());
		this._register(this._markerService.onMarkerChanged((e) => this._onMarkerChanges(e)));
		this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));
	}
	trigger(trigger) {
		const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);
		return this._createEventAndSignalChange(trigger, selection);
	}
	_onMarkerChanges(resources) {
		const model = this._editor.getModel();
		if (!model) return;
		if (resources.some((resource) => isEqual(resource, model.uri))) this._autoTriggerTimer.cancelAndSet(() => {
			this.trigger({
				type: 2,
				triggerAction: CodeActionTriggerSource.Default
			});
		}, this._delay);
	}
	_onCursorChange() {
		this._autoTriggerTimer.cancelAndSet(() => {
			this.trigger({
				type: 2,
				triggerAction: CodeActionTriggerSource.Default
			});
		}, this._delay);
	}
	_getRangeOfMarker(selection) {
		const model = this._editor.getModel();
		if (!model) return;
		for (const marker of this._markerService.read({ resource: model.uri })) {
			const markerRange = model.validateRange(marker);
			if (Range$1.intersectRanges(markerRange, selection)) return Range$1.lift(markerRange);
		}
	}
	_getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {
		if (!this._editor.hasModel()) return;
		const model = this._editor.getModel();
		const selection = this._editor.getSelection();
		if (selection.isEmpty() && trigger.type === 2) {
			const { lineNumber, column } = selection.getPosition();
			const line = model.getLineContent(lineNumber);
			if (line.length === 0) return;
			else if (column === 1) {
				if (/\s/.test(line[0])) return;
			} else if (column === model.getLineMaxColumn(lineNumber)) {
				if (/\s/.test(line[line.length - 1])) return;
			} else if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) return;
		}
		return selection;
	}
	_createEventAndSignalChange(trigger, selection) {
		const model = this._editor.getModel();
		if (!selection || !model) {
			this._signalChange(void 0);
			return;
		}
		const markerRange = this._getRangeOfMarker(selection);
		const e = {
			trigger,
			selection,
			position: markerRange ? markerRange.getStartPosition() : selection.getStartPosition()
		};
		this._signalChange(e);
		return e;
	}
};
var CodeActionsState;
(function(CodeActionsState$1) {
	CodeActionsState$1.Empty = { type: 0 };
	class Triggered {
		constructor(trigger, rangeOrSelection, position, _cancellablePromise) {
			this.trigger = trigger;
			this.rangeOrSelection = rangeOrSelection;
			this.position = position;
			this._cancellablePromise = _cancellablePromise;
			this.type = 1;
			this.actions = _cancellablePromise.catch((e) => {
				if (isCancellationError(e)) return emptyCodeActionSet;
				throw e;
			});
		}
		cancel() {
			this._cancellablePromise.cancel();
		}
	}
	CodeActionsState$1.Triggered = Triggered;
})(CodeActionsState || (CodeActionsState = {}));
var emptyCodeActionSet = {
	allActions: [],
	validActions: [],
	dispose: () => {},
	documentation: [],
	hasAutoFix: false
};
var CodeActionModel = class extends Disposable {
	constructor(_editor, _registry, _markerService, contextKeyService, _progressService) {
		super();
		this._editor = _editor;
		this._registry = _registry;
		this._markerService = _markerService;
		this._progressService = _progressService;
		this._codeActionOracle = this._register(new MutableDisposable());
		this._state = CodeActionsState.Empty;
		this._onDidChangeState = this._register(new Emitter$1());
		this.onDidChangeState = this._onDidChangeState.event;
		_CodeActionModel_isDisposed.set(this, false);
		this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
		this._register(this._editor.onDidChangeModel(() => this._update()));
		this._register(this._editor.onDidChangeModelLanguage(() => this._update()));
		this._register(this._registry.onDidChange(() => this._update()));
		this._update();
	}
	dispose() {
		if (__classPrivateFieldGet(this, _CodeActionModel_isDisposed, "f")) return;
		__classPrivateFieldSet(this, _CodeActionModel_isDisposed, true, "f");
		super.dispose();
		this.setState(CodeActionsState.Empty, true);
	}
	_update() {
		if (__classPrivateFieldGet(this, _CodeActionModel_isDisposed, "f")) return;
		this._codeActionOracle.value = void 0;
		this.setState(CodeActionsState.Empty);
		const model = this._editor.getModel();
		if (model && this._registry.has(model) && !this._editor.getOption(83)) {
			const supportedActions = [];
			for (const provider of this._registry.all(model)) if (Array.isArray(provider.providedCodeActionKinds)) supportedActions.push(...provider.providedCodeActionKinds);
			this._supportedCodeActions.set(supportedActions.join(" "));
			this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, (trigger) => {
				var _a$5;
				if (!trigger) {
					this.setState(CodeActionsState.Empty);
					return;
				}
				const actions = createCancelablePromise((token) => getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token));
				if (trigger.trigger.type === 1) (_a$5 = this._progressService) === null || _a$5 === void 0 || _a$5.showWhile(actions, 250);
				this.setState(new CodeActionsState.Triggered(trigger.trigger, trigger.selection, trigger.position, actions));
			}, void 0);
			this._codeActionOracle.value.trigger({
				type: 2,
				triggerAction: CodeActionTriggerSource.Default
			});
		} else this._supportedCodeActions.reset();
	}
	trigger(trigger) {
		var _a$5;
		(_a$5 = this._codeActionOracle.value) === null || _a$5 === void 0 || _a$5.trigger(trigger);
	}
	setState(newState, skipNotify) {
		if (newState === this._state) return;
		if (this._state.type === 1) this._state.cancel();
		this._state = newState;
		if (!skipNotify && !__classPrivateFieldGet(this, _CodeActionModel_isDisposed, "f")) this._onDidChangeState.fire(newState);
	}
};
_CodeActionModel_isDisposed = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
var __decorate$76 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$76 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$51 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
function contextKeyForSupportedActions(kind) {
	return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], /* @__PURE__ */ new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
function refactorTrigger(editor$1, userArgs, preview, codeActionFrom) {
	const args = CodeActionCommandArgs.fromUser(userArgs, {
		kind: CodeActionKind.Refactor,
		apply: "never"
	});
	return triggerCodeActionsForEditorSelection(editor$1, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
		include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
		onlyIncludePreferredActions: args.preferred
	}, args.apply, preview, codeActionFrom);
}
var argsSchema = {
	type: "object",
	defaultSnippets: [{ body: { kind: "" } }],
	properties: {
		"kind": {
			type: "string",
			description: localize("args.schema.kind", "Kind of the code action to run.")
		},
		"apply": {
			type: "string",
			description: localize("args.schema.apply", "Controls when the returned actions are applied."),
			default: "ifSingle",
			enum: [
				"first",
				"ifSingle",
				"never"
			],
			enumDescriptions: [
				localize("args.schema.apply.first", "Always apply the first returned code action."),
				localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
				localize("args.schema.apply.never", "Do not apply the returned code actions.")
			]
		},
		"preferred": {
			type: "boolean",
			default: false,
			description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
		}
	}
};
var QuickFixController = class QuickFixController$1 extends Disposable {
	constructor(editor$1, markerService, contextKeyService, progressService, _instantiationService, languageFeaturesService) {
		super();
		this._instantiationService = _instantiationService;
		this._editor = editor$1;
		this._model = this._register(new CodeActionModel(this._editor, languageFeaturesService.codeActionProvider, markerService, contextKeyService, progressService));
		this._register(this._model.onDidChangeState((newState) => this.update(newState)));
		this._ui = new Lazy(() => this._register(new CodeActionUi(editor$1, QuickFixAction.Id, AutoFixAction.Id, { applyCodeAction: (action, retrigger, preview) => __awaiter$51(this, void 0, void 0, function* () {
			try {
				yield this._applyCodeAction(action, preview);
			} finally {
				if (retrigger) this._trigger({
					type: 2,
					triggerAction: CodeActionTriggerSource.QuickFix,
					filter: {}
				});
			}
		}) }, this._instantiationService)));
	}
	static get(editor$1) {
		return editor$1.getContribution(QuickFixController$1.ID);
	}
	update(newState) {
		this._ui.getValue().update(newState);
	}
	hideCodeActionMenu() {
		if (this._ui.hasValue()) this._ui.getValue().hideCodeActionWidget();
	}
	navigateCodeActionList(navUp) {
		if (this._ui.hasValue()) this._ui.getValue().navigateList(navUp);
	}
	selectedOption() {
		if (this._ui.hasValue()) this._ui.getValue().onEnter();
	}
	selectedOptionWithPreview() {
		if (this._ui.hasValue()) this._ui.getValue().onPreviewEnter();
	}
	showCodeActions(trigger, actions, at) {
		return this._ui.getValue().showCodeActionList(trigger, actions, at, {
			includeDisabledActions: false,
			fromLightbulb: false
		});
	}
	manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply, preview) {
		var _a$5;
		if (!this._editor.hasModel()) return;
		(_a$5 = MessageController.get(this._editor)) === null || _a$5 === void 0 || _a$5.closeMessage();
		const triggerPosition = this._editor.getPosition();
		this._trigger({
			type: 1,
			triggerAction,
			filter,
			autoApply,
			context: {
				notAvailableMessage,
				position: triggerPosition
			},
			preview
		});
	}
	_trigger(trigger) {
		return this._model.trigger(trigger);
	}
	_applyCodeAction(action, preview) {
		return this._instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.FromCodeActions, {
			preview,
			editor: this._editor
		});
	}
};
QuickFixController.ID = "editor.contrib.quickFixController";
QuickFixController = __decorate$76([
	__param$76(1, IMarkerService),
	__param$76(2, IContextKeyService),
	__param$76(3, IEditorProgressService),
	__param$76(4, IInstantiationService),
	__param$76(5, ILanguageFeaturesService)
], QuickFixController);
var ApplyCodeActionReason;
(function(ApplyCodeActionReason$1) {
	ApplyCodeActionReason$1["OnSave"] = "onSave";
	ApplyCodeActionReason$1["FromProblemsView"] = "fromProblemsView";
	ApplyCodeActionReason$1["FromCodeActions"] = "fromCodeActions";
})(ApplyCodeActionReason || (ApplyCodeActionReason = {}));
function applyCodeAction(accessor, item, codeActionReason, options) {
	return __awaiter$51(this, void 0, void 0, function* () {
		const bulkEditService = accessor.get(IBulkEditService);
		const commandService = accessor.get(ICommandService);
		const telemetryService = accessor.get(ITelemetryService);
		const notificationService = accessor.get(INotificationService);
		telemetryService.publicLog2("codeAction.applyCodeAction", {
			codeActionTitle: item.action.title,
			codeActionKind: item.action.kind,
			codeActionIsPreferred: !!item.action.isPreferred,
			reason: codeActionReason
		});
		yield item.resolve(CancellationToken.None);
		if (item.action.edit) yield bulkEditService.apply(ResourceEdit.convert(item.action.edit), {
			editor: options === null || options === void 0 ? void 0 : options.editor,
			label: item.action.title,
			quotableLabel: item.action.title,
			code: "undoredo.codeAction",
			respectAutoSaveConfig: true,
			showPreview: options === null || options === void 0 ? void 0 : options.preview
		});
		if (item.action.command) try {
			yield commandService.executeCommand(item.action.command.id, ...item.action.command.arguments || []);
		} catch (err) {
			const message = asMessage(err);
			notificationService.error(typeof message === "string" ? message : localize("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
		}
	});
}
function asMessage(err) {
	if (typeof err === "string") return err;
	else if (err instanceof Error && typeof err.message === "string") return err.message;
	else return;
}
function triggerCodeActionsForEditorSelection(editor$1, notAvailableMessage, filter, autoApply, preview = false, triggerAction = CodeActionTriggerSource.Default) {
	if (editor$1.hasModel()) {
		const controller = QuickFixController.get(editor$1);
		controller === null || controller === void 0 || controller.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply, preview);
	}
}
var QuickFixAction = class QuickFixAction extends EditorAction {
	constructor() {
		super({
			id: QuickFixAction.Id,
			label: localize("quickfix.trigger.label", "Quick Fix..."),
			alias: "Quick Fix...",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2132,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		return triggerCodeActionsForEditorSelection(editor$1, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0, false, CodeActionTriggerSource.QuickFix);
	}
};
QuickFixAction.Id = "editor.action.quickFix";
var CodeActionCommand = class extends EditorCommand {
	constructor() {
		super({
			id: codeActionCommandId,
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
			description: {
				description: "Trigger a code action",
				args: [{
					name: "args",
					schema: argsSchema
				}]
			}
		});
	}
	runEditorCommand(_accessor, editor$1, userArgs) {
		const args = CodeActionCommandArgs.fromUser(userArgs, {
			kind: CodeActionKind.Empty,
			apply: "ifSingle"
		});
		return triggerCodeActionsForEditorSelection(editor$1, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
			include: args.kind,
			includeSourceActions: true,
			onlyIncludePreferredActions: args.preferred
		}, args.apply);
	}
};
var RefactorAction = class extends EditorAction {
	constructor() {
		super({
			id: refactorCommandId,
			label: localize("refactor.label", "Refactor..."),
			alias: "Refactor...",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3120,
				mac: { primary: 1328 },
				weight: 100
			},
			contextMenuOpts: {
				group: "1_modification",
				order: 2,
				when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
			},
			description: {
				description: "Refactor...",
				args: [{
					name: "args",
					schema: argsSchema
				}]
			}
		});
	}
	run(_accessor, editor$1, userArgs) {
		return refactorTrigger(editor$1, userArgs, false, CodeActionTriggerSource.Refactor);
	}
};
var RefactorPreview = class extends EditorAction {
	constructor() {
		super({
			id: refactorPreviewCommandId,
			label: localize("refactor.preview.label", "Refactor with Preview..."),
			alias: "Refactor Preview...",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
			description: {
				description: "Refactor Preview...",
				args: [{
					name: "args",
					schema: argsSchema
				}]
			}
		});
	}
	run(_accessor, editor$1, userArgs) {
		return refactorTrigger(editor$1, userArgs, true, CodeActionTriggerSource.RefactorPreview);
	}
};
var SourceAction = class extends EditorAction {
	constructor() {
		super({
			id: sourceActionCommandId,
			label: localize("source.label", "Source Action..."),
			alias: "Source Action...",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
			contextMenuOpts: {
				group: "1_modification",
				order: 2.1,
				when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
			},
			description: {
				description: "Source Action...",
				args: [{
					name: "args",
					schema: argsSchema
				}]
			}
		});
	}
	run(_accessor, editor$1, userArgs) {
		const args = CodeActionCommandArgs.fromUser(userArgs, {
			kind: CodeActionKind.Source,
			apply: "never"
		});
		return triggerCodeActionsForEditorSelection(editor$1, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
			include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
			includeSourceActions: true,
			onlyIncludePreferredActions: args.preferred
		}, args.apply, void 0, CodeActionTriggerSource.SourceAction);
	}
};
var OrganizeImportsAction = class extends EditorAction {
	constructor() {
		super({
			id: organizeImportsCommandId,
			label: localize("organizeImports.label", "Organize Imports"),
			alias: "Organize Imports",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1581,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		return triggerCodeActionsForEditorSelection(editor$1, localize("editor.action.organize.noneMessage", "No organize imports action available"), {
			include: CodeActionKind.SourceOrganizeImports,
			includeSourceActions: true
		}, "ifSingle", void 0, CodeActionTriggerSource.OrganizeImports);
	}
};
var FixAllAction = class extends EditorAction {
	constructor() {
		super({
			id: fixAllCommandId,
			label: localize("fixAll.label", "Fix All"),
			alias: "Fix All",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
		});
	}
	run(_accessor, editor$1) {
		return triggerCodeActionsForEditorSelection(editor$1, localize("fixAll.noneMessage", "No fix all action available"), {
			include: CodeActionKind.SourceFixAll,
			includeSourceActions: true
		}, "ifSingle", void 0, CodeActionTriggerSource.FixAll);
	}
};
var AutoFixAction = class AutoFixAction extends EditorAction {
	constructor() {
		super({
			id: AutoFixAction.Id,
			label: localize("autoFix.label", "Auto Fix..."),
			alias: "Auto Fix...",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1620,
				mac: { primary: 2644 },
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		return triggerCodeActionsForEditorSelection(editor$1, localize("editor.action.autoFix.noneMessage", "No auto fixes available"), {
			include: CodeActionKind.QuickFix,
			onlyIncludePreferredActions: true
		}, "ifSingle", void 0, CodeActionTriggerSource.AutoFix);
	}
};
AutoFixAction.Id = "editor.action.autoFix";
var CodeActionContribution = EditorCommand.bindToContribution(QuickFixController.get);
var weight$2 = 190;
registerEditorCommand(new CodeActionContribution({
	id: "hideCodeActionMenuWidget",
	precondition: Context$2.Visible,
	handler(x) {
		x.hideCodeActionMenu();
	},
	kbOpts: {
		weight: weight$2,
		primary: 9,
		secondary: [1033]
	}
}));
registerEditorCommand(new CodeActionContribution({
	id: "focusPreviousCodeAction",
	precondition: Context$2.Visible,
	handler(x) {
		x.navigateCodeActionList(true);
	},
	kbOpts: {
		weight: weight$2 + 1e5,
		primary: 16,
		secondary: [2064]
	}
}));
registerEditorCommand(new CodeActionContribution({
	id: "focusNextCodeAction",
	precondition: Context$2.Visible,
	handler(x) {
		x.navigateCodeActionList(false);
	},
	kbOpts: {
		weight: weight$2 + 1e5,
		primary: 18,
		secondary: [2066]
	}
}));
registerEditorCommand(new CodeActionContribution({
	id: "onEnterSelectCodeAction",
	precondition: Context$2.Visible,
	handler(x) {
		x.selectedOption();
	},
	kbOpts: {
		weight: weight$2 + 1e5,
		primary: 3,
		secondary: [1026]
	}
}));
registerEditorCommand(new CodeActionContribution({
	id: "onEnterSelectCodeActionWithPreview",
	precondition: Context$2.Visible,
	handler(x) {
		x.selectedOptionWithPreview();
	},
	kbOpts: {
		weight: weight$2 + 1e5,
		primary: 2051
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionWidgetContribution.js
Registry.as(Extensions$1.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: { "editor.experimental.useCustomCodeActionMenu": {
	type: "boolean",
	tags: ["experimental"],
	scope: 5,
	description: localize("codeActionWidget", "Enabling this adjusts how the code action menu is rendered."),
	default: false
} } }));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
registerEditorContribution(QuickFixController.ID, QuickFixController);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(RefactorPreview);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelens.js
var __awaiter$50 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var CodeLensModel = class {
	constructor() {
		this.lenses = [];
		this._disposables = new DisposableStore();
	}
	dispose() {
		this._disposables.dispose();
	}
	get isDisposed() {
		return this._disposables.isDisposed;
	}
	add(list, provider) {
		this._disposables.add(list);
		for (const symbol of list.lenses) this.lenses.push({
			symbol,
			provider
		});
	}
};
function getCodeLensModel(registry, model, token) {
	return __awaiter$50(this, void 0, void 0, function* () {
		const provider = registry.ordered(model);
		const providerRanks = /* @__PURE__ */ new Map();
		const result = new CodeLensModel();
		const promises = provider.map((provider$1, i) => __awaiter$50(this, void 0, void 0, function* () {
			providerRanks.set(provider$1, i);
			try {
				const list = yield Promise.resolve(provider$1.provideCodeLenses(model, token));
				if (list) result.add(list, provider$1);
			} catch (err) {
				onUnexpectedExternalError(err);
			}
		}));
		yield Promise.all(promises);
		result.lenses = result.lenses.sort((a, b) => {
			if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) return -1;
			else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) return 1;
			else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) return -1;
			else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) return 1;
			else if (a.symbol.range.startColumn < b.symbol.range.startColumn) return -1;
			else if (a.symbol.range.startColumn > b.symbol.range.startColumn) return 1;
			else return 0;
		});
		return result;
	});
}
CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
	let [uri, itemResolveCount] = args;
	assertType(URI.isUri(uri));
	assertType(typeof itemResolveCount === "number" || !itemResolveCount);
	const { codeLensProvider } = accessor.get(ILanguageFeaturesService);
	const model = accessor.get(IModelService).getModel(uri);
	if (!model) throw illegalArgument();
	const result = [];
	const disposables = new DisposableStore();
	return getCodeLensModel(codeLensProvider, model, CancellationToken.None).then((value) => {
		disposables.add(value);
		const resolve = [];
		for (const item of value.lenses) if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) result.push(item.symbol);
		else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
		return Promise.all(resolve);
	}).then(() => {
		return result;
	}).finally(() => {
		setTimeout(() => disposables.dispose(), 100);
	});
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codeLensCache.js
var __decorate$75 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$75 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
const ICodeLensCache = createDecorator("ICodeLensCache");
var CacheItem = class {
	constructor(lineCount, data) {
		this.lineCount = lineCount;
		this.data = data;
	}
};
var CodeLensCache = class CodeLensCache$1 {
	constructor(storageService) {
		this._fakeProvider = new class {
			provideCodeLenses() {
				throw new Error("not supported");
			}
		}();
		this._cache = new LRUCache(20, .75);
		const oldkey = "codelens/cache";
		runWhenIdle(() => storageService.remove(oldkey, 1));
		const key = "codelens/cache2";
		const raw = storageService.get(key, 1, "{}");
		this._deserialize(raw);
		once(storageService.onWillSaveState)((e) => {
			if (e.reason === WillSaveStateReason.SHUTDOWN) storageService.store(key, this._serialize(), 1, 1);
		});
	}
	put(model, data) {
		const copyItems = data.lenses.map((item$1) => {
			var _a$5;
			return {
				range: item$1.symbol.range,
				command: item$1.symbol.command && {
					id: "",
					title: (_a$5 = item$1.symbol.command) === null || _a$5 === void 0 ? void 0 : _a$5.title
				}
			};
		});
		const copyModel = new CodeLensModel();
		copyModel.add({
			lenses: copyItems,
			dispose: () => {}
		}, this._fakeProvider);
		const item = new CacheItem(model.getLineCount(), copyModel);
		this._cache.set(model.uri.toString(), item);
	}
	get(model) {
		const item = this._cache.get(model.uri.toString());
		return item && item.lineCount === model.getLineCount() ? item.data : void 0;
	}
	delete(model) {
		this._cache.delete(model.uri.toString());
	}
	_serialize() {
		const data = Object.create(null);
		for (const [key, value] of this._cache) {
			const lines = /* @__PURE__ */ new Set();
			for (const d of value.data.lenses) lines.add(d.symbol.range.startLineNumber);
			data[key] = {
				lineCount: value.lineCount,
				lines: [...lines.values()]
			};
		}
		return JSON.stringify(data);
	}
	_deserialize(raw) {
		try {
			const data = JSON.parse(raw);
			for (const key in data) {
				const element = data[key];
				const lenses = [];
				for (const line of element.lines) lenses.push({ range: new Range$1(line, 1, line, 11) });
				const model = new CodeLensModel();
				model.add({
					lenses,
					dispose() {}
				}, this._fakeProvider);
				this._cache.set(key, new CacheItem(element.lineCount, model));
			}
		} catch (_a$5) {}
	}
};
CodeLensCache = __decorate$75([__param$75(0, IStorageService)], CodeLensCache);
registerSingleton(ICodeLensCache, CodeLensCache);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.js
var CodeLensViewZone = class {
	constructor(afterLineNumber, heightInPx, onHeight) {
		/**
		* We want that this view zone, which reserves space for a code lens appears
		* as close as possible to the next line, so we use a very large value here.
		*/
		this.afterColumn = 1073741824;
		this.afterLineNumber = afterLineNumber;
		this.heightInPx = heightInPx;
		this._onHeight = onHeight;
		this.suppressMouseDown = true;
		this.domNode = document.createElement("div");
	}
	onComputedHeight(height) {
		if (this._lastHeight === void 0) this._lastHeight = height;
		else if (this._lastHeight !== height) {
			this._lastHeight = height;
			this._onHeight();
		}
	}
	isVisible() {
		return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
	}
};
var CodeLensContentWidget = class CodeLensContentWidget {
	constructor(editor$1, className, line) {
		this.allowEditorOverflow = false;
		this.suppressMouseDown = true;
		this._commands = /* @__PURE__ */ new Map();
		this._isEmpty = true;
		this._editor = editor$1;
		this._id = `codelens.widget-${CodeLensContentWidget._idPool++}`;
		this.updatePosition(line);
		this._domNode = document.createElement("span");
		this._domNode.className = `codelens-decoration ${className}`;
	}
	withCommands(lenses, animate) {
		this._commands.clear();
		const children = [];
		let hasSymbol = false;
		for (let i = 0; i < lenses.length; i++) {
			const lens = lenses[i];
			if (!lens) continue;
			hasSymbol = true;
			if (lens.command) {
				const title = renderLabelWithIcons(lens.command.title.trim());
				if (lens.command.id) {
					children.push($("a", {
						id: String(i),
						title: lens.command.tooltip,
						role: "button"
					}, ...title));
					this._commands.set(String(i), lens.command);
				} else children.push($("span", { title: lens.command.tooltip }, ...title));
				if (i + 1 < lenses.length) children.push($("span", void 0, "\xA0|\xA0"));
			}
		}
		if (!hasSymbol) reset(this._domNode, $("span", void 0, "no commands"));
		else {
			reset(this._domNode, ...children);
			if (this._isEmpty && animate) this._domNode.classList.add("fadein");
			this._isEmpty = false;
		}
	}
	getCommand(link) {
		return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
	}
	getId() {
		return this._id;
	}
	getDomNode() {
		return this._domNode;
	}
	updatePosition(line) {
		this._widgetPosition = {
			position: {
				lineNumber: line,
				column: this._editor.getModel().getLineFirstNonWhitespaceColumn(line)
			},
			preference: [1]
		};
	}
	getPosition() {
		return this._widgetPosition || null;
	}
};
CodeLensContentWidget._idPool = 0;
var CodeLensHelper = class {
	constructor() {
		this._removeDecorations = [];
		this._addDecorations = [];
		this._addDecorationsCallbacks = [];
	}
	addDecoration(decoration$1, callback) {
		this._addDecorations.push(decoration$1);
		this._addDecorationsCallbacks.push(callback);
	}
	removeDecoration(decorationId) {
		this._removeDecorations.push(decorationId);
	}
	commit(changeAccessor) {
		const resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
		for (let i = 0, len = resultingDecorations.length; i < len; i++) this._addDecorationsCallbacks[i](resultingDecorations[i]);
	}
};
var CodeLensWidget = class {
	constructor(data, editor$1, className, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
		this._isDisposed = false;
		this._editor = editor$1;
		this._className = className;
		this._data = data;
		this._decorationIds = [];
		let range;
		const lenses = [];
		this._data.forEach((codeLensData, i) => {
			if (codeLensData.symbol.command) lenses.push(codeLensData.symbol);
			helper.addDecoration({
				range: codeLensData.symbol.range,
				options: ModelDecorationOptions.EMPTY
			}, (id) => this._decorationIds[i] = id);
			if (!range) range = Range$1.lift(codeLensData.symbol.range);
			else range = Range$1.plusRange(range, codeLensData.symbol.range);
		});
		this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
		this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
		if (lenses.length > 0) {
			this._createContentWidgetIfNecessary();
			this._contentWidget.withCommands(lenses, false);
		}
	}
	_createContentWidgetIfNecessary() {
		if (!this._contentWidget) {
			this._contentWidget = new CodeLensContentWidget(this._editor, this._className, this._viewZone.afterLineNumber + 1);
			this._editor.addContentWidget(this._contentWidget);
		} else this._editor.layoutContentWidget(this._contentWidget);
	}
	dispose(helper, viewZoneChangeAccessor) {
		this._decorationIds.forEach(helper.removeDecoration, helper);
		this._decorationIds = [];
		viewZoneChangeAccessor === null || viewZoneChangeAccessor === void 0 || viewZoneChangeAccessor.removeZone(this._viewZoneId);
		if (this._contentWidget) {
			this._editor.removeContentWidget(this._contentWidget);
			this._contentWidget = void 0;
		}
		this._isDisposed = true;
	}
	isDisposed() {
		return this._isDisposed;
	}
	isValid() {
		return this._decorationIds.some((id, i) => {
			const range = this._editor.getModel().getDecorationRange(id);
			const symbol = this._data[i].symbol;
			return !!(range && Range$1.isEmpty(symbol.range) === range.isEmpty());
		});
	}
	updateCodeLensSymbols(data, helper) {
		this._decorationIds.forEach(helper.removeDecoration, helper);
		this._decorationIds = [];
		this._data = data;
		this._data.forEach((codeLensData, i) => {
			helper.addDecoration({
				range: codeLensData.symbol.range,
				options: ModelDecorationOptions.EMPTY
			}, (id) => this._decorationIds[i] = id);
		});
	}
	updateHeight(height, viewZoneChangeAccessor) {
		this._viewZone.heightInPx = height;
		viewZoneChangeAccessor.layoutZone(this._viewZoneId);
		if (this._contentWidget) this._editor.layoutContentWidget(this._contentWidget);
	}
	computeIfNecessary(model) {
		if (!this._viewZone.isVisible()) return null;
		for (let i = 0; i < this._decorationIds.length; i++) {
			const range = model.getDecorationRange(this._decorationIds[i]);
			if (range) this._data[i].symbol.range = range;
		}
		return this._data;
	}
	updateCommands(symbols) {
		this._createContentWidgetIfNecessary();
		this._contentWidget.withCommands(symbols, true);
		for (let i = 0; i < this._data.length; i++) {
			const resolved = symbols[i];
			if (resolved) {
				const { symbol } = this._data[i];
				symbol.command = resolved.command || symbol.command;
			}
		}
	}
	getCommand(link) {
		var _a$5;
		return (_a$5 = this._contentWidget) === null || _a$5 === void 0 ? void 0 : _a$5.getCommand(link);
	}
	getLineNumber() {
		const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
		if (range) return range.startLineNumber;
		return -1;
	}
	update(viewZoneChangeAccessor) {
		if (this.isValid()) {
			const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
			if (range) {
				this._viewZone.afterLineNumber = range.startLineNumber - 1;
				viewZoneChangeAccessor.layoutZone(this._viewZoneId);
				if (this._contentWidget) {
					this._contentWidget.updatePosition(range.startLineNumber);
					this._editor.layoutContentWidget(this._contentWidget);
				}
			}
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
var __decorate$74 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$74 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$49 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var CodeLensContribution = class CodeLensContribution$1 {
	constructor(_editor, _languageFeaturesService, debounceService, _commandService, _notificationService, _codeLensCache) {
		this._editor = _editor;
		this._languageFeaturesService = _languageFeaturesService;
		this._commandService = _commandService;
		this._notificationService = _notificationService;
		this._codeLensCache = _codeLensCache;
		this._disposables = new DisposableStore();
		this._localToDispose = new DisposableStore();
		this._lenses = [];
		this._oldCodeLensModels = new DisposableStore();
		this._provideCodeLensDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensProvide", { min: 250 });
		this._resolveCodeLensesDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensResolve", {
			min: 250,
			salt: "resolve"
		});
		this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default());
		this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
		this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
		this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(46) || e.hasChanged(16) || e.hasChanged(15)) this._updateLensStyle();
			if (e.hasChanged(14)) this._onModelChange();
		}));
		this._disposables.add(_languageFeaturesService.codeLensProvider.onDidChange(this._onModelChange, this));
		this._onModelChange();
		this._styleClassName = "_" + hash(this._editor.getId()).toString(16);
		this._styleElement = createStyleSheet(isInShadowDOM(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0);
		this._updateLensStyle();
	}
	dispose() {
		var _a$5;
		this._localDispose();
		this._disposables.dispose();
		this._oldCodeLensModels.dispose();
		(_a$5 = this._currentCodeLensModel) === null || _a$5 === void 0 || _a$5.dispose();
		this._styleElement.remove();
	}
	_getLayoutInfo() {
		const lineHeightFactor = Math.max(1.3, this._editor.getOption(61) / this._editor.getOption(48));
		let fontSize = this._editor.getOption(16);
		if (!fontSize || fontSize < 5) fontSize = this._editor.getOption(48) * .9 | 0;
		return {
			fontSize,
			codeLensHeight: fontSize * lineHeightFactor | 0
		};
	}
	_updateLensStyle() {
		const { codeLensHeight, fontSize } = this._getLayoutInfo();
		const fontFamily = this._editor.getOption(15);
		const editorFontInfo = this._editor.getOption(46);
		const fontFamilyVar = `--codelens-font-family${this._styleClassName}`;
		const fontFeaturesVar = `--codelens-font-features${this._styleClassName}`;
		let newStyle = `
		.monaco-editor .codelens-decoration.${this._styleClassName} { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; padding-right: ${Math.round(fontSize * .5)}px; font-feature-settings: var(${fontFeaturesVar}) }
		.monaco-editor .codelens-decoration.${this._styleClassName} span.codicon { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; }
		`;
		if (fontFamily) newStyle += `.monaco-editor .codelens-decoration.${this._styleClassName} { font-family: var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}}`;
		this._styleElement.textContent = newStyle;
		this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily !== null && fontFamily !== void 0 ? fontFamily : "inherit");
		this._editor.getContainerDomNode().style.setProperty(fontFeaturesVar, editorFontInfo.fontFeatureSettings);
		this._editor.changeViewZones((accessor) => {
			for (const lens of this._lenses) lens.updateHeight(codeLensHeight, accessor);
		});
	}
	_localDispose() {
		var _a$5, _b$1, _c$1;
		(_a$5 = this._getCodeLensModelPromise) === null || _a$5 === void 0 || _a$5.cancel();
		this._getCodeLensModelPromise = void 0;
		(_b$1 = this._resolveCodeLensesPromise) === null || _b$1 === void 0 || _b$1.cancel();
		this._resolveCodeLensesPromise = void 0;
		this._localToDispose.clear();
		this._oldCodeLensModels.clear();
		(_c$1 = this._currentCodeLensModel) === null || _c$1 === void 0 || _c$1.dispose();
	}
	_onModelChange() {
		this._localDispose();
		const model = this._editor.getModel();
		if (!model) return;
		if (!this._editor.getOption(14)) return;
		const cachedLenses = this._codeLensCache.get(model);
		if (cachedLenses) this._renderCodeLensSymbols(cachedLenses);
		if (!this._languageFeaturesService.codeLensProvider.has(model)) {
			if (cachedLenses) this._localToDispose.add(disposableTimeout(() => {
				if (cachedLenses === this._codeLensCache.get(model)) {
					this._codeLensCache.delete(model);
					this._onModelChange();
				}
			}, 30 * 1e3));
			return;
		}
		for (const provider of this._languageFeaturesService.codeLensProvider.all(model)) if (typeof provider.onDidChange === "function") {
			const registration = provider.onDidChange(() => scheduler.schedule());
			this._localToDispose.add(registration);
		}
		const scheduler = new RunOnceScheduler(() => {
			var _a$5;
			const t1 = Date.now();
			(_a$5 = this._getCodeLensModelPromise) === null || _a$5 === void 0 || _a$5.cancel();
			this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));
			this._getCodeLensModelPromise.then((result) => {
				if (this._currentCodeLensModel) this._oldCodeLensModels.add(this._currentCodeLensModel);
				this._currentCodeLensModel = result;
				this._codeLensCache.put(model, result);
				scheduler.delay = this._provideCodeLensDebounce.update(model, Date.now() - t1);
				this._renderCodeLensSymbols(result);
				this._resolveCodeLensesInViewportSoon();
			}, onUnexpectedError);
		}, this._provideCodeLensDebounce.get(model));
		this._localToDispose.add(scheduler);
		this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
		this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
			this._editor.changeDecorations((decorationsAccessor) => {
				this._editor.changeViewZones((viewZonesAccessor) => {
					const toDispose = [];
					let lastLensLineNumber = -1;
					this._lenses.forEach((lens) => {
						if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) toDispose.push(lens);
						else {
							lens.update(viewZonesAccessor);
							lastLensLineNumber = lens.getLineNumber();
						}
					});
					const helper = new CodeLensHelper();
					toDispose.forEach((l) => {
						l.dispose(helper, viewZonesAccessor);
						this._lenses.splice(this._lenses.indexOf(l), 1);
					});
					helper.commit(decorationsAccessor);
				});
			});
			scheduler.schedule();
		}));
		this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
			scheduler.schedule();
		}));
		this._localToDispose.add(this._editor.onDidScrollChange((e) => {
			if (e.scrollTopChanged && this._lenses.length > 0) this._resolveCodeLensesInViewportSoon();
		}));
		this._localToDispose.add(this._editor.onDidLayoutChange(() => {
			this._resolveCodeLensesInViewportSoon();
		}));
		this._localToDispose.add(toDisposable(() => {
			if (this._editor.getModel()) {
				const scrollState = StableEditorScrollState.capture(this._editor);
				this._editor.changeDecorations((decorationsAccessor) => {
					this._editor.changeViewZones((viewZonesAccessor) => {
						this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
					});
				});
				scrollState.restore(this._editor);
			} else this._disposeAllLenses(void 0, void 0);
		}));
		this._localToDispose.add(this._editor.onMouseDown((e) => {
			if (e.target.type !== 9) return;
			let target = e.target.element;
			if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") target = target.parentElement;
			if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") for (const lens of this._lenses) {
				const command = lens.getCommand(target);
				if (command) {
					this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
					break;
				}
			}
		}));
		scheduler.schedule();
	}
	_disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
		const helper = new CodeLensHelper();
		for (const lens of this._lenses) lens.dispose(helper, viewZoneChangeAccessor);
		if (decChangeAccessor) helper.commit(decChangeAccessor);
		this._lenses.length = 0;
	}
	_renderCodeLensSymbols(symbols) {
		if (!this._editor.hasModel()) return;
		const maxLineNumber = this._editor.getModel().getLineCount();
		const groups = [];
		let lastGroup;
		for (const symbol of symbols.lenses) {
			const line = symbol.symbol.range.startLineNumber;
			if (line < 1 || line > maxLineNumber) continue;
			else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) lastGroup.push(symbol);
			else {
				lastGroup = [symbol];
				groups.push(lastGroup);
			}
		}
		const scrollState = StableEditorScrollState.capture(this._editor);
		const layoutInfo = this._getLayoutInfo();
		this._editor.changeDecorations((decorationsAccessor) => {
			this._editor.changeViewZones((viewZoneAccessor) => {
				const helper = new CodeLensHelper();
				let codeLensIndex = 0;
				let groupsIndex = 0;
				while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
					const symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
					const codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
					if (codeLensLineNumber < symbolsLineNumber) {
						this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
						this._lenses.splice(codeLensIndex, 1);
					} else if (codeLensLineNumber === symbolsLineNumber) {
						this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
						groupsIndex++;
						codeLensIndex++;
					} else {
						this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
						codeLensIndex++;
						groupsIndex++;
					}
				}
				while (codeLensIndex < this._lenses.length) {
					this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
					this._lenses.splice(codeLensIndex, 1);
				}
				while (groupsIndex < groups.length) {
					this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
					groupsIndex++;
				}
				helper.commit(decorationsAccessor);
			});
		});
		scrollState.restore(this._editor);
	}
	_resolveCodeLensesInViewportSoon() {
		if (this._editor.getModel()) this._resolveCodeLensesScheduler.schedule();
	}
	_resolveCodeLensesInViewport() {
		var _a$5;
		(_a$5 = this._resolveCodeLensesPromise) === null || _a$5 === void 0 || _a$5.cancel();
		this._resolveCodeLensesPromise = void 0;
		const model = this._editor.getModel();
		if (!model) return;
		const toResolve = [];
		const lenses = [];
		this._lenses.forEach((lens) => {
			const request = lens.computeIfNecessary(model);
			if (request) {
				toResolve.push(request);
				lenses.push(lens);
			}
		});
		if (toResolve.length === 0) return;
		const t1 = Date.now();
		const resolvePromise = createCancelablePromise((token) => {
			const promises = toResolve.map((request, i) => {
				const resolvedSymbols = new Array(request.length);
				const promises$1 = request.map((request$1, i$1) => {
					if (!request$1.symbol.command && typeof request$1.provider.resolveCodeLens === "function") return Promise.resolve(request$1.provider.resolveCodeLens(model, request$1.symbol, token)).then((symbol) => {
						resolvedSymbols[i$1] = symbol;
					}, onUnexpectedExternalError);
					else {
						resolvedSymbols[i$1] = request$1.symbol;
						return Promise.resolve(void 0);
					}
				});
				return Promise.all(promises$1).then(() => {
					if (!token.isCancellationRequested && !lenses[i].isDisposed()) lenses[i].updateCommands(resolvedSymbols);
				});
			});
			return Promise.all(promises);
		});
		this._resolveCodeLensesPromise = resolvePromise;
		this._resolveCodeLensesPromise.then(() => {
			const newDelay = this._resolveCodeLensesDebounce.update(model, Date.now() - t1);
			this._resolveCodeLensesScheduler.delay = newDelay;
			if (this._currentCodeLensModel) this._codeLensCache.put(model, this._currentCodeLensModel);
			this._oldCodeLensModels.clear();
			if (resolvePromise === this._resolveCodeLensesPromise) this._resolveCodeLensesPromise = void 0;
		}, (err) => {
			onUnexpectedError(err);
			if (resolvePromise === this._resolveCodeLensesPromise) this._resolveCodeLensesPromise = void 0;
		});
	}
	getModel() {
		return this._currentCodeLensModel;
	}
};
CodeLensContribution.ID = "css.editor.codeLens";
CodeLensContribution = __decorate$74([
	__param$74(1, ILanguageFeaturesService),
	__param$74(2, ILanguageFeatureDebounceService),
	__param$74(3, ICommandService),
	__param$74(4, INotificationService),
	__param$74(5, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(CodeLensContribution.ID, CodeLensContribution);
registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
	constructor() {
		super({
			id: "codelens.showLensesInCurrentLine",
			precondition: EditorContextKeys.hasCodeLensProvider,
			label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
			alias: "Show CodeLens Commands For Current Line"
		});
	}
	run(accessor, editor$1) {
		return __awaiter$49(this, void 0, void 0, function* () {
			if (!editor$1.hasModel()) return;
			const quickInputService = accessor.get(IQuickInputService);
			const commandService = accessor.get(ICommandService);
			const notificationService = accessor.get(INotificationService);
			const lineNumber = editor$1.getSelection().positionLineNumber;
			const codelensController = editor$1.getContribution(CodeLensContribution.ID);
			if (!codelensController) return;
			const model = codelensController.getModel();
			if (!model) return;
			const items = [];
			for (const lens of model.lenses) if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) items.push({
				label: lens.symbol.command.title,
				command: lens.symbol.command
			});
			if (items.length === 0) return;
			const item = yield quickInputService.pick(items, { canPickMany: false });
			if (!item) return;
			if (model.isDisposed) return yield commandService.executeCommand(this.id);
			try {
				yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
			} catch (err) {
				notificationService.error(err);
			}
		});
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/color.js
function getColors(registry, model, token) {
	const colors = [];
	const promises = registry.ordered(model).reverse().map((provider) => Promise.resolve(provider.provideDocumentColors(model, token)).then((result) => {
		if (Array.isArray(result)) for (const colorInfo of result) colors.push({
			colorInfo,
			provider
		});
	}));
	return Promise.all(promises).then(() => colors);
}
function getColorPresentations(model, colorInfo, provider, token) {
	return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
	const [resource] = args;
	if (!(resource instanceof URI)) throw illegalArgument();
	const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
	const model = accessor.get(IModelService).getModel(resource);
	if (!model) throw illegalArgument();
	const rawCIs = [];
	const promises = colorProviderRegistry.ordered(model).reverse().map((provider) => Promise.resolve(provider.provideDocumentColors(model, CancellationToken.None)).then((result) => {
		if (Array.isArray(result)) for (const ci of result) rawCIs.push({
			range: ci.range,
			color: [
				ci.color.red,
				ci.color.green,
				ci.color.blue,
				ci.color.alpha
			]
		});
	}));
	return Promise.all(promises).then(() => rawCIs);
});
CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
	const [color, context] = args;
	const { uri, range } = context;
	if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range$1.isIRange(range)) throw illegalArgument();
	const [red, green, blue, alpha] = color;
	const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
	const model = accessor.get(IModelService).getModel(uri);
	if (!model) throw illegalArgument();
	const colorInfo = {
		range,
		color: {
			red,
			green,
			blue,
			alpha
		}
	};
	const presentations = [];
	const promises = colorProviderRegistry.ordered(model).reverse().map((provider) => Promise.resolve(provider.provideColorPresentations(model, colorInfo, CancellationToken.None)).then((result) => {
		if (Array.isArray(result)) presentations.push(...result);
	}));
	return Promise.all(promises).then(() => presentations);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorDetector.js
var __decorate$73 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$73 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$48 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const ColorDecorationInjectedTextMarker = Object.create({});
var MAX_DECORATORS = 500;
var ColorDetector = class ColorDetector$1 extends Disposable {
	constructor(_editor, _configurationService, _languageFeaturesService, languageFeatureDebounceService) {
		super();
		this._editor = _editor;
		this._configurationService = _configurationService;
		this._languageFeaturesService = _languageFeaturesService;
		this._localToDispose = this._register(new DisposableStore());
		this._decorationsIds = [];
		this._colorDatas = /* @__PURE__ */ new Map();
		this._colorDecoratorIds = this._editor.createDecorationsCollection();
		this._ruleFactory = new DynamicCssRules(this._editor);
		this._colorDecorationClassRefs = this._register(new DisposableStore());
		this._debounceInformation = languageFeatureDebounceService.for(_languageFeaturesService.colorProvider, "Document Colors", { min: ColorDetector$1.RECOMPUTE_TIME });
		this._register(_editor.onDidChangeModel(() => {
			this._isEnabled = this.isEnabled();
			this.onModelChanged();
		}));
		this._register(_editor.onDidChangeModelLanguage(() => this.onModelChanged()));
		this._register(_languageFeaturesService.colorProvider.onDidChange(() => this.onModelChanged()));
		this._register(_editor.onDidChangeConfiguration(() => {
			const prevIsEnabled = this._isEnabled;
			this._isEnabled = this.isEnabled();
			if (prevIsEnabled !== this._isEnabled) if (this._isEnabled) this.onModelChanged();
			else this.removeAllDecorations();
		}));
		this._timeoutTimer = null;
		this._computePromise = null;
		this._isEnabled = this.isEnabled();
		this.onModelChanged();
	}
	isEnabled() {
		const model = this._editor.getModel();
		if (!model) return false;
		const languageId = model.getLanguageId();
		const deprecatedConfig = this._configurationService.getValue(languageId);
		if (deprecatedConfig && typeof deprecatedConfig === "object") {
			const colorDecorators = deprecatedConfig["colorDecorators"];
			if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) return colorDecorators["enable"];
		}
		return this._editor.getOption(17);
	}
	static get(editor$1) {
		return editor$1.getContribution(this.ID);
	}
	dispose() {
		this.stop();
		this.removeAllDecorations();
		super.dispose();
	}
	onModelChanged() {
		this.stop();
		if (!this._isEnabled) return;
		const model = this._editor.getModel();
		if (!model || !this._languageFeaturesService.colorProvider.has(model)) return;
		this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
			if (!this._timeoutTimer) {
				this._timeoutTimer = new TimeoutTimer();
				this._timeoutTimer.cancelAndSet(() => {
					this._timeoutTimer = null;
					this.beginCompute();
				}, this._debounceInformation.get(model));
			}
		}));
		this.beginCompute();
	}
	beginCompute() {
		this._computePromise = createCancelablePromise((token) => __awaiter$48(this, void 0, void 0, function* () {
			const model = this._editor.getModel();
			if (!model) return Promise.resolve([]);
			const sw = new StopWatch(false);
			const colors = yield getColors(this._languageFeaturesService.colorProvider, model, token);
			this._debounceInformation.update(model, sw.elapsed());
			return colors;
		}));
		this._computePromise.then((colorInfos) => {
			this.updateDecorations(colorInfos);
			this.updateColorDecorators(colorInfos);
			this._computePromise = null;
		}, onUnexpectedError);
	}
	stop() {
		if (this._timeoutTimer) {
			this._timeoutTimer.cancel();
			this._timeoutTimer = null;
		}
		if (this._computePromise) {
			this._computePromise.cancel();
			this._computePromise = null;
		}
		this._localToDispose.clear();
	}
	updateDecorations(colorDatas) {
		const decorations = colorDatas.map((c) => ({
			range: {
				startLineNumber: c.colorInfo.range.startLineNumber,
				startColumn: c.colorInfo.range.startColumn,
				endLineNumber: c.colorInfo.range.endLineNumber,
				endColumn: c.colorInfo.range.endColumn
			},
			options: ModelDecorationOptions.EMPTY
		}));
		this._editor.changeDecorations((changeAccessor) => {
			this._decorationsIds = changeAccessor.deltaDecorations(this._decorationsIds, decorations);
			this._colorDatas = /* @__PURE__ */ new Map();
			this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
		});
	}
	updateColorDecorators(colorData) {
		this._colorDecorationClassRefs.clear();
		const decorations = [];
		for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {
			const { red, green, blue, alpha } = colorData[i].colorInfo.color;
			const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
			const color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
			const ref = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({ backgroundColor: color }));
			decorations.push({
				range: {
					startLineNumber: colorData[i].colorInfo.range.startLineNumber,
					startColumn: colorData[i].colorInfo.range.startColumn,
					endLineNumber: colorData[i].colorInfo.range.endLineNumber,
					endColumn: colorData[i].colorInfo.range.endColumn
				},
				options: {
					description: "colorDetector",
					before: {
						content: noBreakWhitespace,
						inlineClassName: `${ref.className} colorpicker-color-decoration`,
						inlineClassNameAffectsLetterSpacing: true,
						attachedData: ColorDecorationInjectedTextMarker
					}
				}
			});
		}
		this._colorDecoratorIds.set(decorations);
	}
	removeAllDecorations() {
		this._editor.removeDecorations(this._decorationsIds);
		this._decorationsIds = [];
		this._colorDecoratorIds.clear();
		this._colorDecorationClassRefs.clear();
	}
	getColorData(position) {
		const model = this._editor.getModel();
		if (!model) return null;
		const decorations = model.getDecorationsInRange(Range$1.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
		if (decorations.length === 0) return null;
		return this._colorDatas.get(decorations[0].id);
	}
	isColorDecoration(decoration$1) {
		return this._colorDecoratorIds.has(decoration$1);
	}
};
ColorDetector.ID = "editor.contrib.colorDetector";
ColorDetector.RECOMPUTE_TIME = 1e3;
ColorDetector = __decorate$73([
	__param$73(1, IConfigurationService),
	__param$73(2, ILanguageFeaturesService),
	__param$73(3, ILanguageFeatureDebounceService)
], ColorDetector);
registerEditorContribution(ColorDetector.ID, ColorDetector);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerModel.js
var ColorPickerModel = class {
	constructor(color, availableColorPresentations, presentationIndex) {
		this.presentationIndex = presentationIndex;
		this._onColorFlushed = new Emitter$1();
		this.onColorFlushed = this._onColorFlushed.event;
		this._onDidChangeColor = new Emitter$1();
		this.onDidChangeColor = this._onDidChangeColor.event;
		this._onDidChangePresentation = new Emitter$1();
		this.onDidChangePresentation = this._onDidChangePresentation.event;
		this.originalColor = color;
		this._color = color;
		this._colorPresentations = availableColorPresentations;
	}
	get color() {
		return this._color;
	}
	set color(color) {
		if (this._color.equals(color)) return;
		this._color = color;
		this._onDidChangeColor.fire(color);
	}
	get presentation() {
		return this.colorPresentations[this.presentationIndex];
	}
	get colorPresentations() {
		return this._colorPresentations;
	}
	set colorPresentations(colorPresentations) {
		this._colorPresentations = colorPresentations;
		if (this.presentationIndex > colorPresentations.length - 1) this.presentationIndex = 0;
		this._onDidChangePresentation.fire(this.presentation);
	}
	selectNextColorPresentation() {
		this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
		this.flushColor();
		this._onDidChangePresentation.fire(this.presentation);
	}
	guessColorPresentation(color, originalText) {
		for (let i = 0; i < this.colorPresentations.length; i++) if (originalText.toLowerCase() === this.colorPresentations[i].label) {
			this.presentationIndex = i;
			this._onDidChangePresentation.fire(this.presentation);
			break;
		}
	}
	flushColor() {
		this._onColorFlushed.fire(this._color);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
var $$7 = $;
var ColorPickerHeader = class extends Disposable {
	constructor(container, model, themeService) {
		super();
		this.model = model;
		this.domNode = $$7(".colorpicker-header");
		append(container, this.domNode);
		this.pickedColorNode = append(this.domNode, $$7(".picked-color"));
		const tooltip = localize("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
		this.pickedColorNode.setAttribute("title", tooltip);
		const colorBox = append(this.domNode, $$7(".original-color"));
		colorBox.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
		this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
		this._register(registerThemingParticipant((theme, collector) => {
			this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
		}));
		this._register(addDisposableListener(this.pickedColorNode, EventType$1.CLICK, () => this.model.selectNextColorPresentation()));
		this._register(addDisposableListener(colorBox, EventType$1.CLICK, () => {
			this.model.color = this.model.originalColor;
			this.model.flushColor();
		}));
		this._register(model.onDidChangeColor(this.onDidChangeColor, this));
		this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
		this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
		this.pickedColorNode.classList.toggle("light", model.color.rgba.a < .5 ? this.backgroundColor.isLighter() : model.color.isLighter());
		this.onDidChangeColor(this.model.color);
	}
	onDidChangeColor(color) {
		this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
		this.pickedColorNode.classList.toggle("light", color.rgba.a < .5 ? this.backgroundColor.isLighter() : color.isLighter());
		this.onDidChangePresentation();
	}
	onDidChangePresentation() {
		this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : "";
		this.pickedColorNode.prepend($$7(".codicon.codicon-color-mode"));
	}
};
var ColorPickerBody = class extends Disposable {
	constructor(container, model, pixelRatio) {
		super();
		this.model = model;
		this.pixelRatio = pixelRatio;
		this.domNode = $$7(".colorpicker-body");
		append(container, this.domNode);
		this.saturationBox = new SaturationBox(this.domNode, this.model, this.pixelRatio);
		this._register(this.saturationBox);
		this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this));
		this._register(this.saturationBox.onColorFlushed(this.flushColor, this));
		this.opacityStrip = new OpacityStrip(this.domNode, this.model);
		this._register(this.opacityStrip);
		this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this));
		this._register(this.opacityStrip.onColorFlushed(this.flushColor, this));
		this.hueStrip = new HueStrip(this.domNode, this.model);
		this._register(this.hueStrip);
		this._register(this.hueStrip.onDidChange(this.onDidHueChange, this));
		this._register(this.hueStrip.onColorFlushed(this.flushColor, this));
	}
	flushColor() {
		this.model.flushColor();
	}
	onDidSaturationValueChange({ s, v }) {
		const hsva = this.model.color.hsva;
		this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
	}
	onDidOpacityChange(a) {
		const hsva = this.model.color.hsva;
		this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
	}
	onDidHueChange(value) {
		const hsva = this.model.color.hsva;
		const h = (1 - value) * 360;
		this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
	}
	layout() {
		this.saturationBox.layout();
		this.opacityStrip.layout();
		this.hueStrip.layout();
	}
};
var SaturationBox = class extends Disposable {
	constructor(container, model, pixelRatio) {
		super();
		this.model = model;
		this.pixelRatio = pixelRatio;
		this._onDidChange = new Emitter$1();
		this.onDidChange = this._onDidChange.event;
		this._onColorFlushed = new Emitter$1();
		this.onColorFlushed = this._onColorFlushed.event;
		this.domNode = $$7(".saturation-wrap");
		append(container, this.domNode);
		this.canvas = document.createElement("canvas");
		this.canvas.className = "saturation-box";
		append(this.domNode, this.canvas);
		this.selection = $$7(".saturation-selection");
		append(this.domNode, this.selection);
		this.layout();
		this._register(addDisposableListener(this.domNode, EventType$1.POINTER_DOWN, (e) => this.onPointerDown(e)));
		this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
		this.monitor = null;
	}
	onPointerDown(e) {
		if (!e.target || !(e.target instanceof Element)) return;
		this.monitor = this._register(new GlobalPointerMoveMonitor());
		const origin = getDomNodePagePosition(this.domNode);
		if (e.target !== this.selection) this.onDidChangePosition(e.offsetX, e.offsetY);
		this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangePosition(event.pageX - origin.left, event.pageY - origin.top), () => null);
		const pointerUpListener = addDisposableListener(document, EventType$1.POINTER_UP, () => {
			this._onColorFlushed.fire();
			pointerUpListener.dispose();
			if (this.monitor) {
				this.monitor.stopMonitoring(true);
				this.monitor = null;
			}
		}, true);
	}
	onDidChangePosition(left, top) {
		const s = Math.max(0, Math.min(1, left / this.width));
		const v = Math.max(0, Math.min(1, 1 - top / this.height));
		this.paintSelection(s, v);
		this._onDidChange.fire({
			s,
			v
		});
	}
	layout() {
		this.width = this.domNode.offsetWidth;
		this.height = this.domNode.offsetHeight;
		this.canvas.width = this.width * this.pixelRatio;
		this.canvas.height = this.height * this.pixelRatio;
		this.paint();
		const hsva = this.model.color.hsva;
		this.paintSelection(hsva.s, hsva.v);
	}
	paint() {
		const hsva = this.model.color.hsva;
		const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
		const ctx = this.canvas.getContext("2d");
		const whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);
		whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
		whiteGradient.addColorStop(.5, "rgba(255, 255, 255, 0.5)");
		whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
		const blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
		blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
		blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
		ctx.rect(0, 0, this.canvas.width, this.canvas.height);
		ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
		ctx.fill();
		ctx.fillStyle = whiteGradient;
		ctx.fill();
		ctx.fillStyle = blackGradient;
		ctx.fill();
	}
	paintSelection(s, v) {
		this.selection.style.left = `${s * this.width}px`;
		this.selection.style.top = `${this.height - v * this.height}px`;
	}
	onDidChangeColor() {
		if (this.monitor && this.monitor.isMonitoring()) return;
		this.paint();
	}
};
var Strip = class extends Disposable {
	constructor(container, model) {
		super();
		this.model = model;
		this._onDidChange = new Emitter$1();
		this.onDidChange = this._onDidChange.event;
		this._onColorFlushed = new Emitter$1();
		this.onColorFlushed = this._onColorFlushed.event;
		this.domNode = append(container, $$7(".strip"));
		this.overlay = append(this.domNode, $$7(".overlay"));
		this.slider = append(this.domNode, $$7(".slider"));
		this.slider.style.top = `0px`;
		this._register(addDisposableListener(this.domNode, EventType$1.POINTER_DOWN, (e) => this.onPointerDown(e)));
		this.layout();
	}
	layout() {
		this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
		const value = this.getValue(this.model.color);
		this.updateSliderPosition(value);
	}
	onPointerDown(e) {
		if (!e.target || !(e.target instanceof Element)) return;
		const monitor = this._register(new GlobalPointerMoveMonitor());
		const origin = getDomNodePagePosition(this.domNode);
		this.domNode.classList.add("grabbing");
		if (e.target !== this.slider) this.onDidChangeTop(e.offsetY);
		monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangeTop(event.pageY - origin.top), () => null);
		const pointerUpListener = addDisposableListener(document, EventType$1.POINTER_UP, () => {
			this._onColorFlushed.fire();
			pointerUpListener.dispose();
			monitor.stopMonitoring(true);
			this.domNode.classList.remove("grabbing");
		}, true);
	}
	onDidChangeTop(top) {
		const value = Math.max(0, Math.min(1, 1 - top / this.height));
		this.updateSliderPosition(value);
		this._onDidChange.fire(value);
	}
	updateSliderPosition(value) {
		this.slider.style.top = `${(1 - value) * this.height}px`;
	}
};
var OpacityStrip = class extends Strip {
	constructor(container, model) {
		super(container, model);
		this.domNode.classList.add("opacity-strip");
		this._register(model.onDidChangeColor(this.onDidChangeColor, this));
		this.onDidChangeColor(this.model.color);
	}
	onDidChangeColor(color) {
		const { r, g, b } = color.rgba;
		const opaque = new Color(new RGBA(r, g, b, 1));
		const transparent$1 = new Color(new RGBA(r, g, b, 0));
		this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent$1} 100%)`;
	}
	getValue(color) {
		return color.hsva.a;
	}
};
var HueStrip = class extends Strip {
	constructor(container, model) {
		super(container, model);
		this.domNode.classList.add("hue-strip");
	}
	getValue(color) {
		return 1 - color.hsva.h / 360;
	}
};
var ColorPickerWidget = class extends Widget {
	constructor(container, model, pixelRatio, themeService) {
		super();
		this.model = model;
		this.pixelRatio = pixelRatio;
		this._register(PixelRatio.onDidChange(() => this.layout()));
		const element = $$7(".colorpicker-widget");
		container.appendChild(element);
		const header = new ColorPickerHeader(element, this.model, themeService);
		this.body = new ColorPickerBody(element, this.model, this.pixelRatio);
		this._register(header);
		this._register(this.body);
	}
	layout() {
		this.body.layout();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
var __decorate$72 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$72 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$47 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var ColorHover = class {
	constructor(owner, range, model, provider) {
		this.owner = owner;
		this.range = range;
		this.model = model;
		this.provider = provider;
		/**
		* Force the hover to always be rendered at this specific range,
		* even in the case of multiple hover parts.
		*/
		this.forceShowAtRange = true;
	}
	isValidForHoverAnchor(anchor) {
		return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
	}
};
var ColorHoverParticipant = class ColorHoverParticipant$1 {
	constructor(_editor, _themeService) {
		this._editor = _editor;
		this._themeService = _themeService;
		this.hoverOrdinal = 1;
	}
	computeSync(anchor, lineDecorations) {
		return [];
	}
	computeAsync(anchor, lineDecorations, token) {
		return AsyncIterableObject.fromPromise(this._computeAsync(anchor, lineDecorations, token));
	}
	_computeAsync(anchor, lineDecorations, token) {
		return __awaiter$47(this, void 0, void 0, function* () {
			if (!this._editor.hasModel()) return [];
			const colorDetector = ColorDetector.get(this._editor);
			if (!colorDetector) return [];
			for (const d of lineDecorations) {
				if (!colorDetector.isColorDecoration(d)) continue;
				const colorData = colorDetector.getColorData(d.range.getStartPosition());
				if (colorData) return [yield this._createColorHover(this._editor.getModel(), colorData.colorInfo, colorData.provider)];
			}
			return [];
		});
	}
	_createColorHover(editorModel, colorInfo, provider) {
		return __awaiter$47(this, void 0, void 0, function* () {
			const originalText = editorModel.getValueInRange(colorInfo.range);
			const { red, green, blue, alpha } = colorInfo.color;
			const color = new Color(new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha));
			const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
			const model = new ColorPickerModel(color, [], 0);
			model.colorPresentations = colorPresentations || [];
			model.guessColorPresentation(color, originalText);
			return new ColorHover(this, Range$1.lift(colorInfo.range), model, provider);
		});
	}
	renderHoverParts(context, hoverParts) {
		if (hoverParts.length === 0 || !this._editor.hasModel()) return Disposable.None;
		const disposables = new DisposableStore();
		const colorHover = hoverParts[0];
		const editorModel = this._editor.getModel();
		const model = colorHover.model;
		const widget = disposables.add(new ColorPickerWidget(context.fragment, model, this._editor.getOption(131), this._themeService));
		context.setColorPicker(widget);
		let range = new Range$1(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
		const updateEditorModel = () => {
			let textEdits;
			let newRange;
			if (model.presentation.textEdit) {
				textEdits = [model.presentation.textEdit];
				newRange = new Range$1(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
				const trackedRange = this._editor.getModel()._setTrackedRange(null, newRange, 3);
				this._editor.pushUndoStop();
				this._editor.executeEdits("colorpicker", textEdits);
				newRange = this._editor.getModel()._getTrackedRange(trackedRange) || newRange;
			} else {
				textEdits = [{
					range,
					text: model.presentation.label,
					forceMoveMarkers: false
				}];
				newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);
				this._editor.pushUndoStop();
				this._editor.executeEdits("colorpicker", textEdits);
			}
			if (model.presentation.additionalTextEdits) {
				textEdits = [...model.presentation.additionalTextEdits];
				this._editor.executeEdits("colorpicker", textEdits);
				context.hide();
			}
			this._editor.pushUndoStop();
			range = newRange;
		};
		const updateColorPresentations = (color) => {
			return getColorPresentations(editorModel, {
				range,
				color: {
					red: color.rgba.r / 255,
					green: color.rgba.g / 255,
					blue: color.rgba.b / 255,
					alpha: color.rgba.a
				}
			}, colorHover.provider, CancellationToken.None).then((colorPresentations) => {
				model.colorPresentations = colorPresentations || [];
			});
		};
		disposables.add(model.onColorFlushed((color) => {
			updateColorPresentations(color).then(updateEditorModel);
		}));
		disposables.add(model.onDidChangeColor(updateColorPresentations));
		return disposables;
	}
};
ColorHoverParticipant = __decorate$72([__param$72(1, IThemeService)], ColorHoverParticipant);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js
function hasModifier(e, modifier) {
	return !!e[modifier];
}
/**
* An event that encapsulates the various trigger modifiers logic needed for go to definition.
*/
var ClickLinkMouseEvent = class {
	constructor(source, opts) {
		this.target = source.target;
		this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
		this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
		this.isNoneOrSingleMouseDown = source.event.detail <= 1;
	}
};
/**
* An event that encapsulates the various trigger modifiers logic needed for go to definition.
*/
var ClickLinkKeyboardEvent = class {
	constructor(source, opts) {
		this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
		this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
		this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
	}
};
var ClickLinkOptions = class {
	constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
		this.triggerKey = triggerKey;
		this.triggerModifier = triggerModifier;
		this.triggerSideBySideKey = triggerSideBySideKey;
		this.triggerSideBySideModifier = triggerSideBySideModifier;
	}
	equals(other) {
		return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier;
	}
};
function createOptions(multiCursorModifier) {
	if (multiCursorModifier === "altKey") {
		if (isMacintosh) return new ClickLinkOptions(57, "metaKey", 6, "altKey");
		return new ClickLinkOptions(5, "ctrlKey", 6, "altKey");
	}
	if (isMacintosh) return new ClickLinkOptions(6, "altKey", 57, "metaKey");
	return new ClickLinkOptions(6, "altKey", 5, "ctrlKey");
}
var ClickLinkGesture = class extends Disposable {
	constructor(editor$1) {
		super();
		this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter$1());
		this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
		this._onExecute = this._register(new Emitter$1());
		this.onExecute = this._onExecute.event;
		this._onCancel = this._register(new Emitter$1());
		this.onCancel = this._onCancel.event;
		this._editor = editor$1;
		this._opts = createOptions(this._editor.getOption(72));
		this._lastMouseMoveEvent = null;
		this._hasTriggerKeyOnMouseDown = false;
		this._lineNumberOnMouseDown = 0;
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(72)) {
				const newOpts = createOptions(this._editor.getOption(72));
				if (this._opts.equals(newOpts)) return;
				this._opts = newOpts;
				this._lastMouseMoveEvent = null;
				this._hasTriggerKeyOnMouseDown = false;
				this._lineNumberOnMouseDown = 0;
				this._onCancel.fire();
			}
		}));
		this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
		this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
		this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
		this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
		this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
		this._register(this._editor.onMouseDrag(() => this._resetHandler()));
		this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
		this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
		this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
		this._register(this._editor.onDidScrollChange((e) => {
			if (e.scrollTopChanged || e.scrollLeftChanged) this._resetHandler();
		}));
	}
	_onDidChangeCursorSelection(e) {
		if (e.selection && e.selection.startColumn !== e.selection.endColumn) this._resetHandler();
	}
	_onEditorMouseMove(mouseEvent) {
		this._lastMouseMoveEvent = mouseEvent;
		this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
	}
	_onEditorMouseDown(mouseEvent) {
		this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
		this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
	}
	_onEditorMouseUp(mouseEvent) {
		const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
		if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber) this._onExecute.fire(mouseEvent);
	}
	_onEditorKeyDown(e) {
		if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
		else if (e.hasTriggerModifier) this._onCancel.fire();
	}
	_onEditorKeyUp(e) {
		if (e.keyCodeIsTriggerKey) this._onCancel.fire();
	}
	_resetHandler() {
		this._lastMouseMoveEvent = null;
		this._hasTriggerKeyOnMouseDown = false;
		this._onCancel.fire();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js
var __decorate$71 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$71 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget$1 extends CodeEditorWidget {
	constructor(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
		super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
		this._parentEditor = parentEditor;
		this._overwriteOptions = options;
		super.updateOptions(this._overwriteOptions);
		this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));
	}
	getParentEditor() {
		return this._parentEditor;
	}
	_onParentConfigurationChanged(e) {
		super.updateOptions(this._parentEditor.getRawOptions());
		super.updateOptions(this._overwriteOptions);
	}
	updateOptions(newOptions) {
		mixin(this._overwriteOptions, newOptions, true);
		super.updateOptions(this._overwriteOptions);
	}
};
EmbeddedCodeEditorWidget = __decorate$71([
	__param$71(3, IInstantiationService),
	__param$71(4, ICodeEditorService),
	__param$71(5, ICommandService),
	__param$71(6, IContextKeyService),
	__param$71(7, IThemeService),
	__param$71(8, INotificationService),
	__param$71(9, IAccessibilityService),
	__param$71(10, ILanguageConfigurationService),
	__param$71(11, ILanguageFeaturesService)
], EmbeddedCodeEditorWidget);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/browser/zoneWidget.js
var defaultColor = new Color(new RGBA(0, 122, 204));
var defaultOptions$1 = {
	showArrow: true,
	showFrame: true,
	className: "",
	frameColor: defaultColor,
	arrowColor: defaultColor,
	keepEditorSelection: false
};
var WIDGET_ID = "vs.editor.contrib.zoneWidget";
var ViewZoneDelegate = class {
	constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
		this.id = "";
		this.domNode = domNode;
		this.afterLineNumber = afterLineNumber;
		this.afterColumn = afterColumn;
		this.heightInLines = heightInLines;
		this._onDomNodeTop = onDomNodeTop;
		this._onComputedHeight = onComputedHeight;
	}
	onDomNodeTop(top) {
		this._onDomNodeTop(top);
	}
	onComputedHeight(height) {
		this._onComputedHeight(height);
	}
};
var OverlayWidgetDelegate = class {
	constructor(id, domNode) {
		this._id = id;
		this._domNode = domNode;
	}
	getId() {
		return this._id;
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		return null;
	}
};
var Arrow = class Arrow {
	constructor(_editor) {
		this._editor = _editor;
		this._ruleName = Arrow._IdGenerator.nextId();
		this._decorations = this._editor.createDecorationsCollection();
		this._color = null;
		this._height = -1;
	}
	dispose() {
		this.hide();
		removeCSSRulesContainingSelector(this._ruleName);
	}
	set color(value) {
		if (this._color !== value) {
			this._color = value;
			this._updateStyle();
		}
	}
	set height(value) {
		if (this._height !== value) {
			this._height = value;
			this._updateStyle();
		}
	}
	_updateStyle() {
		removeCSSRulesContainingSelector(this._ruleName);
		createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
	}
	show(where) {
		if (where.column === 1) where = {
			lineNumber: where.lineNumber,
			column: 2
		};
		this._decorations.set([{
			range: Range$1.fromPositions(where),
			options: {
				description: "zone-widget-arrow",
				className: this._ruleName,
				stickiness: 1
			}
		}]);
	}
	hide() {
		this._decorations.clear();
	}
};
Arrow._IdGenerator = new IdGenerator(".arrow-decoration-");
var ZoneWidget = class {
	constructor(editor$1, options = {}) {
		this._arrow = null;
		this._overlayWidget = null;
		this._resizeSash = null;
		this._viewZone = null;
		this._disposables = new DisposableStore();
		this.container = null;
		this._isShowing = false;
		this.editor = editor$1;
		this._positionMarkerId = this.editor.createDecorationsCollection();
		this.options = deepClone(options);
		mixin(this.options, defaultOptions$1, false);
		this.domNode = document.createElement("div");
		if (!this.options.isAccessible) {
			this.domNode.setAttribute("aria-hidden", "true");
			this.domNode.setAttribute("role", "presentation");
		}
		this._disposables.add(this.editor.onDidLayoutChange((info) => {
			const width = this._getWidth(info);
			this.domNode.style.width = width + "px";
			this.domNode.style.left = this._getLeft(info) + "px";
			this._onWidth(width);
		}));
	}
	dispose() {
		if (this._overlayWidget) {
			this.editor.removeOverlayWidget(this._overlayWidget);
			this._overlayWidget = null;
		}
		if (this._viewZone) this.editor.changeViewZones((accessor) => {
			if (this._viewZone) accessor.removeZone(this._viewZone.id);
			this._viewZone = null;
		});
		this._positionMarkerId.clear();
		this._disposables.dispose();
	}
	create() {
		this.domNode.classList.add("zone-widget");
		if (this.options.className) this.domNode.classList.add(this.options.className);
		this.container = document.createElement("div");
		this.container.classList.add("zone-widget-container");
		this.domNode.appendChild(this.container);
		if (this.options.showArrow) {
			this._arrow = new Arrow(this.editor);
			this._disposables.add(this._arrow);
		}
		this._fillContainer(this.container);
		this._initSash();
		this._applyStyles();
	}
	style(styles) {
		if (styles.frameColor) this.options.frameColor = styles.frameColor;
		if (styles.arrowColor) this.options.arrowColor = styles.arrowColor;
		this._applyStyles();
	}
	_applyStyles() {
		if (this.container && this.options.frameColor) {
			const frameColor = this.options.frameColor.toString();
			this.container.style.borderTopColor = frameColor;
			this.container.style.borderBottomColor = frameColor;
		}
		if (this._arrow && this.options.arrowColor) {
			const arrowColor = this.options.arrowColor.toString();
			this._arrow.color = arrowColor;
		}
	}
	_getWidth(info) {
		return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
	}
	_getLeft(info) {
		if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) return info.minimap.minimapWidth;
		return 0;
	}
	_onViewZoneTop(top) {
		this.domNode.style.top = top + "px";
	}
	_onViewZoneHeight(height) {
		this.domNode.style.height = `${height}px`;
		if (this.container) {
			const containerHeight = height - this._decoratingElementsHeight();
			this.container.style.height = `${containerHeight}px`;
			const layoutInfo = this.editor.getLayoutInfo();
			this._doLayout(containerHeight, this._getWidth(layoutInfo));
		}
		if (this._resizeSash) this._resizeSash.layout();
	}
	get position() {
		const range = this._positionMarkerId.getRange(0);
		if (!range) return;
		return range.getStartPosition();
	}
	show(rangeOrPos, heightInLines) {
		const range = Range$1.isIRange(rangeOrPos) ? Range$1.lift(rangeOrPos) : Range$1.fromPositions(rangeOrPos);
		this._isShowing = true;
		this._showImpl(range, heightInLines);
		this._isShowing = false;
		this._positionMarkerId.set([{
			range,
			options: ModelDecorationOptions.EMPTY
		}]);
	}
	hide() {
		if (this._viewZone) {
			this.editor.changeViewZones((accessor) => {
				if (this._viewZone) accessor.removeZone(this._viewZone.id);
			});
			this._viewZone = null;
		}
		if (this._overlayWidget) {
			this.editor.removeOverlayWidget(this._overlayWidget);
			this._overlayWidget = null;
		}
		if (this._arrow) this._arrow.hide();
	}
	_decoratingElementsHeight() {
		const lineHeight = this.editor.getOption(61);
		let result = 0;
		if (this.options.showArrow) {
			const arrowHeight = Math.round(lineHeight / 3);
			result += 2 * arrowHeight;
		}
		if (this.options.showFrame) {
			const frameThickness = Math.round(lineHeight / 9);
			result += 2 * frameThickness;
		}
		return result;
	}
	_showImpl(where, heightInLines) {
		const position = where.getStartPosition();
		const layoutInfo = this.editor.getLayoutInfo();
		const width = this._getWidth(layoutInfo);
		this.domNode.style.width = `${width}px`;
		this.domNode.style.left = this._getLeft(layoutInfo) + "px";
		const viewZoneDomNode = document.createElement("div");
		viewZoneDomNode.style.overflow = "hidden";
		const lineHeight = this.editor.getOption(61);
		const maxHeightInLines = Math.max(12, this.editor.getLayoutInfo().height / lineHeight * .8);
		heightInLines = Math.min(heightInLines, maxHeightInLines);
		let arrowHeight = 0;
		let frameThickness = 0;
		if (this._arrow && this.options.showArrow) {
			arrowHeight = Math.round(lineHeight / 3);
			this._arrow.height = arrowHeight;
			this._arrow.show(position);
		}
		if (this.options.showFrame) frameThickness = Math.round(lineHeight / 9);
		this.editor.changeViewZones((accessor) => {
			if (this._viewZone) accessor.removeZone(this._viewZone.id);
			if (this._overlayWidget) {
				this.editor.removeOverlayWidget(this._overlayWidget);
				this._overlayWidget = null;
			}
			this.domNode.style.top = "-1000px";
			this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));
			this._viewZone.id = accessor.addZone(this._viewZone);
			this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);
			this.editor.addOverlayWidget(this._overlayWidget);
		});
		if (this.container && this.options.showFrame) {
			const width$1 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
			this.container.style.borderTopWidth = width$1 + "px";
			this.container.style.borderBottomWidth = width$1 + "px";
		}
		const containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
		if (this.container) {
			this.container.style.top = arrowHeight + "px";
			this.container.style.height = containerHeight + "px";
			this.container.style.overflow = "hidden";
		}
		this._doLayout(containerHeight, width);
		if (!this.options.keepEditorSelection) this.editor.setSelection(where);
		const model = this.editor.getModel();
		if (model) {
			const revealLine = where.endLineNumber + 1;
			if (revealLine <= model.getLineCount()) this.revealLine(revealLine, false);
			else this.revealLine(model.getLineCount(), true);
		}
	}
	revealLine(lineNumber, isLastLine) {
		if (isLastLine) this.editor.revealLineInCenter(lineNumber, 0);
		else this.editor.revealLine(lineNumber, 0);
	}
	setCssClass(className, classToReplace) {
		if (!this.container) return;
		if (classToReplace) this.container.classList.remove(classToReplace);
		this.container.classList.add(className);
	}
	_onWidth(widthInPixel) {}
	_doLayout(heightInPixel, widthInPixel) {}
	_relayout(newHeightInLines) {
		if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) this.editor.changeViewZones((accessor) => {
			if (this._viewZone) {
				this._viewZone.heightInLines = newHeightInLines;
				accessor.layoutZone(this._viewZone.id);
			}
		});
	}
	_initSash() {
		if (this._resizeSash) return;
		this._resizeSash = this._disposables.add(new Sash(this.domNode, this, { orientation: 1 }));
		if (!this.options.isResizeable) this._resizeSash.state = 0;
		let data;
		this._disposables.add(this._resizeSash.onDidStart((e) => {
			if (this._viewZone) data = {
				startY: e.startY,
				heightInLines: this._viewZone.heightInLines
			};
		}));
		this._disposables.add(this._resizeSash.onDidEnd(() => {
			data = void 0;
		}));
		this._disposables.add(this._resizeSash.onDidChange((evt) => {
			if (data) {
				const lineDelta = (evt.currentY - data.startY) / this.editor.getOption(61);
				const roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
				const newHeightInLines = data.heightInLines + roundedLineDelta;
				if (newHeightInLines > 5 && newHeightInLines < 35) this._relayout(newHeightInLines);
			}
		}));
	}
	getHorizontalSashLeft() {
		return 0;
	}
	getHorizontalSashTop() {
		return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
	}
	getHorizontalSashWidth() {
		const layoutInfo = this.editor.getLayoutInfo();
		return layoutInfo.width - layoutInfo.minimap.minimapWidth;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js
var BaseDropdown = class extends ActionRunner {
	constructor(container, options) {
		super();
		this._onDidChangeVisibility = this._register(new Emitter$1());
		this.onDidChangeVisibility = this._onDidChangeVisibility.event;
		this._element = append(container, $(".monaco-dropdown"));
		this._label = append(this._element, $(".dropdown-label"));
		let labelRenderer = options.labelRenderer;
		if (!labelRenderer) labelRenderer = (container$1) => {
			container$1.textContent = options.label || "";
			return null;
		};
		for (const event of [
			EventType$1.CLICK,
			EventType$1.MOUSE_DOWN,
			EventType.Tap
		]) this._register(addDisposableListener(this.element, event, (e) => EventHelper.stop(e, true)));
		for (const event of [EventType$1.MOUSE_DOWN, EventType.Tap]) this._register(addDisposableListener(this._label, event, (e) => {
			if (e instanceof MouseEvent && (e.detail > 1 || e.button !== 0)) return;
			if (this.visible) this.hide();
			else this.show();
		}));
		this._register(addDisposableListener(this._label, EventType$1.KEY_UP, (e) => {
			const event = new StandardKeyboardEvent(e);
			if (event.equals(3) || event.equals(10)) {
				EventHelper.stop(e, true);
				if (this.visible) this.hide();
				else this.show();
			}
		}));
		const cleanupFn = labelRenderer(this._label);
		if (cleanupFn) this._register(cleanupFn);
		this._register(Gesture.addTarget(this._label));
	}
	get element() {
		return this._element;
	}
	show() {
		if (!this.visible) {
			this.visible = true;
			this._onDidChangeVisibility.fire(true);
		}
	}
	hide() {
		if (this.visible) {
			this.visible = false;
			this._onDidChangeVisibility.fire(false);
		}
	}
	dispose() {
		super.dispose();
		this.hide();
		if (this.boxContainer) {
			this.boxContainer.remove();
			this.boxContainer = void 0;
		}
		if (this.contents) {
			this.contents.remove();
			this.contents = void 0;
		}
		if (this._label) {
			this._label.remove();
			this._label = void 0;
		}
	}
};
var DropdownMenu = class extends BaseDropdown {
	constructor(container, options) {
		super(container, options);
		this._actions = [];
		this._contextMenuProvider = options.contextMenuProvider;
		this.actions = options.actions || [];
		this.actionProvider = options.actionProvider;
		this.menuClassName = options.menuClassName || "";
		this.menuAsChild = !!options.menuAsChild;
	}
	set menuOptions(options) {
		this._menuOptions = options;
	}
	get menuOptions() {
		return this._menuOptions;
	}
	get actions() {
		if (this.actionProvider) return this.actionProvider.getActions();
		return this._actions;
	}
	set actions(actions) {
		this._actions = actions;
	}
	show() {
		super.show();
		this.element.classList.add("active");
		this._contextMenuProvider.showContextMenu({
			getAnchor: () => this.element,
			getActions: () => this.actions,
			getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
			getActionViewItem: (action) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action) : void 0,
			getKeyBinding: (action) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : void 0,
			getMenuClassName: () => this.menuClassName,
			onHide: () => this.onHide(),
			actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
			anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
			domForShadowRoot: this.menuAsChild ? this.element : void 0
		});
	}
	hide() {
		super.hide();
	}
	onHide() {
		this.hide();
		this.element.classList.remove("active");
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
var DropdownMenuActionViewItem = class extends BaseActionViewItem {
	constructor(action, menuActionsOrProvider, contextMenuProvider, options = Object.create(null)) {
		super(null, action, options);
		this.actionItem = null;
		this._onDidChangeVisibility = this._register(new Emitter$1());
		this.menuActionsOrProvider = menuActionsOrProvider;
		this.contextMenuProvider = contextMenuProvider;
		this.options = options;
		if (this.options.actionRunner) this.actionRunner = this.options.actionRunner;
	}
	render(container) {
		this.actionItem = container;
		const labelRenderer = (el) => {
			this.element = append(el, $("a.action-label"));
			let classNames = [];
			if (typeof this.options.classNames === "string") classNames = this.options.classNames.split(/\s+/g).filter((s) => !!s);
			else if (this.options.classNames) classNames = this.options.classNames;
			if (!classNames.find((c) => c === "icon")) classNames.push("codicon");
			this.element.classList.add(...classNames);
			this.element.setAttribute("role", "button");
			this.element.setAttribute("aria-haspopup", "true");
			this.element.setAttribute("aria-expanded", "false");
			this.element.title = this._action.label || "";
			this.element.ariaLabel = this._action.label || "";
			return null;
		};
		const isActionsArray = Array.isArray(this.menuActionsOrProvider);
		const options = {
			contextMenuProvider: this.contextMenuProvider,
			labelRenderer,
			menuAsChild: this.options.menuAsChild,
			actions: isActionsArray ? this.menuActionsOrProvider : void 0,
			actionProvider: isActionsArray ? void 0 : this.menuActionsOrProvider
		};
		this.dropdownMenu = this._register(new DropdownMenu(container, options));
		this._register(this.dropdownMenu.onDidChangeVisibility((visible) => {
			var _a$5;
			(_a$5 = this.element) === null || _a$5 === void 0 || _a$5.setAttribute("aria-expanded", `${visible}`);
			this._onDidChangeVisibility.fire(visible);
		}));
		this.dropdownMenu.menuOptions = {
			actionViewItemProvider: this.options.actionViewItemProvider,
			actionRunner: this.actionRunner,
			getKeyBinding: this.options.keybindingProvider,
			context: this._context
		};
		if (this.options.anchorAlignmentProvider) {
			const that = this;
			this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {
				return that.options.anchorAlignmentProvider();
			} });
		}
		this.updateTooltip();
		this.updateEnabled();
	}
	getTooltip() {
		let title = null;
		if (this.getAction().tooltip) title = this.getAction().tooltip;
		else if (this.getAction().label) title = this.getAction().label;
		return title !== null && title !== void 0 ? title : void 0;
	}
	setActionContext(newContext) {
		super.setActionContext(newContext);
		if (this.dropdownMenu) if (this.dropdownMenu.menuOptions) this.dropdownMenu.menuOptions.context = newContext;
		else this.dropdownMenu.menuOptions = { context: newContext };
	}
	updateEnabled() {
		var _a$5, _b$1;
		const disabled = !this.getAction().enabled;
		(_a$5 = this.actionItem) === null || _a$5 === void 0 || _a$5.classList.toggle("disabled", disabled);
		(_b$1 = this.element) === null || _b$1 === void 0 || _b$1.classList.toggle("disabled", disabled);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
var __decorate$70 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$70 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$46 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
function createAndFillInActionBarActions(menu, options, target, primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {
	const groups = menu.getActions(options);
	fillInActions(groups, target, false, typeof primaryGroup === "string" ? (actionGroup) => actionGroup === primaryGroup : primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions);
	return asDisposable(groups);
}
function asDisposable(groups) {
	const disposables = new DisposableStore();
	for (const [, actions] of groups) for (const action of actions) disposables.add(action);
	return disposables;
}
function fillInActions(groups, target, useAlternativeActions, isPrimaryAction = (actionGroup) => actionGroup === "navigation", primaryMaxCount = Number.MAX_SAFE_INTEGER, shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {
	let primaryBucket;
	let secondaryBucket;
	if (Array.isArray(target)) {
		primaryBucket = target;
		secondaryBucket = target;
	} else {
		primaryBucket = target.primary;
		secondaryBucket = target.secondary;
	}
	const submenuInfo = /* @__PURE__ */ new Set();
	for (const [group, actions] of groups) {
		let target$1;
		if (isPrimaryAction(group)) {
			target$1 = primaryBucket;
			if (target$1.length > 0 && useSeparatorsInPrimaryActions) target$1.push(new Separator());
		} else {
			target$1 = secondaryBucket;
			if (target$1.length > 0) target$1.push(new Separator());
		}
		for (let action of actions) {
			if (useAlternativeActions) action = action instanceof MenuItemAction && action.alt ? action.alt : action;
			const newLen = target$1.push(action);
			if (action instanceof SubmenuAction) submenuInfo.add({
				group,
				action,
				index: newLen - 1
			});
		}
	}
	for (const { group, action, index } of submenuInfo) {
		const target$1 = isPrimaryAction(group) ? primaryBucket : secondaryBucket;
		const submenuActions = action.actions;
		if ((submenuActions.length <= 1 || target$1.length + submenuActions.length - 2 <= primaryMaxCount) && shouldInlineSubmenu(action, group, target$1.length)) target$1.splice(index, 1, ...submenuActions);
	}
	if (primaryBucket !== secondaryBucket && primaryBucket.length > primaryMaxCount) {
		const overflow = primaryBucket.splice(primaryMaxCount, primaryBucket.length - primaryMaxCount);
		secondaryBucket.unshift(...overflow, new Separator());
	}
}
var MenuEntryActionViewItem = class MenuEntryActionViewItem$1 extends ActionViewItem {
	constructor(action, options, _keybindingService, _notificationService, _contextKeyService, _themeService, _contextMenuService) {
		super(void 0, action, {
			icon: !!(action.class || action.item.icon),
			label: !action.class && !action.item.icon,
			draggable: options === null || options === void 0 ? void 0 : options.draggable,
			keybinding: options === null || options === void 0 ? void 0 : options.keybinding,
			hoverDelegate: options === null || options === void 0 ? void 0 : options.hoverDelegate
		});
		this._keybindingService = _keybindingService;
		this._notificationService = _notificationService;
		this._contextKeyService = _contextKeyService;
		this._themeService = _themeService;
		this._contextMenuService = _contextMenuService;
		this._wantsAltCommand = false;
		this._itemClassDispose = this._register(new MutableDisposable());
		this._altKey = ModifierKeyEmitter.getInstance();
	}
	get _menuItemAction() {
		return this._action;
	}
	get _commandAction() {
		return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
	}
	onClick(event) {
		return __awaiter$46(this, void 0, void 0, function* () {
			event.preventDefault();
			event.stopPropagation();
			try {
				yield this.actionRunner.run(this._commandAction, this._context);
			} catch (err) {
				this._notificationService.error(err);
			}
		});
	}
	render(container) {
		super.render(container);
		container.classList.add("menu-entry");
		this._updateItemClass(this._menuItemAction.item);
		let mouseOver = false;
		let alternativeKeyDown = this._altKey.keyStatus.altKey || (isWindows || isLinux) && this._altKey.keyStatus.shiftKey;
		const updateAltState = () => {
			var _a$5;
			const wantsAltCommand = mouseOver && alternativeKeyDown && !!((_a$5 = this._commandAction.alt) === null || _a$5 === void 0 ? void 0 : _a$5.enabled);
			if (wantsAltCommand !== this._wantsAltCommand) {
				this._wantsAltCommand = wantsAltCommand;
				this.updateLabel();
				this.updateTooltip();
				this.updateClass();
			}
		};
		if (this._menuItemAction.alt) this._register(this._altKey.event((value) => {
			alternativeKeyDown = value.altKey || (isWindows || isLinux) && value.shiftKey;
			updateAltState();
		}));
		this._register(addDisposableListener(container, "mouseleave", (_) => {
			mouseOver = false;
			updateAltState();
		}));
		this._register(addDisposableListener(container, "mouseenter", (_) => {
			mouseOver = true;
			updateAltState();
		}));
	}
	updateLabel() {
		if (this.options.label && this.label) this.label.textContent = this._commandAction.label;
	}
	getTooltip() {
		var _a$5;
		const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);
		const keybindingLabel = keybinding && keybinding.getLabel();
		const tooltip = this._commandAction.tooltip || this._commandAction.label;
		let title = keybindingLabel ? localize("titleAndKb", "{0} ({1})", tooltip, keybindingLabel) : tooltip;
		if (!this._wantsAltCommand && ((_a$5 = this._menuItemAction.alt) === null || _a$5 === void 0 ? void 0 : _a$5.enabled)) {
			const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;
			const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);
			const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();
			const altTitleSection = altKeybindingLabel ? localize("titleAndKb", "{0} ({1})", altTooltip, altKeybindingLabel) : altTooltip;
			title = localize("titleAndKbAndAlt", "{0}\n[{1}] {2}", title, UILabelProvider.modifierLabels[OS].altKey, altTitleSection);
		}
		return title;
	}
	updateClass() {
		if (this.options.icon) if (this._commandAction !== this._menuItemAction) {
			if (this._menuItemAction.alt) this._updateItemClass(this._menuItemAction.alt.item);
		} else this._updateItemClass(this._menuItemAction.item);
	}
	_updateItemClass(item) {
		var _a$5;
		this._itemClassDispose.value = void 0;
		const { element, label } = this;
		if (!element || !label) return;
		const icon = this._commandAction.checked && ((_a$5 = item.toggled) === null || _a$5 === void 0 ? void 0 : _a$5.icon) ? item.toggled.icon : item.icon;
		if (!icon) return;
		if (ThemeIcon.isThemeIcon(icon)) {
			const iconClasses = ThemeIcon.asClassNameArray(icon);
			label.classList.add(...iconClasses);
			this._itemClassDispose.value = toDisposable(() => {
				label.classList.remove(...iconClasses);
			});
		} else {
			label.style.backgroundImage = isDark(this._themeService.getColorTheme().type) ? asCSSUrl(icon.dark) : asCSSUrl(icon.light);
			label.classList.add("icon");
			this._itemClassDispose.value = combinedDisposable(toDisposable(() => {
				label.style.backgroundImage = "";
				label.classList.remove("icon");
			}), this._themeService.onDidColorThemeChange(() => {
				this.updateClass();
			}));
		}
	}
};
MenuEntryActionViewItem = __decorate$70([
	__param$70(2, IKeybindingService),
	__param$70(3, INotificationService),
	__param$70(4, IContextKeyService),
	__param$70(5, IThemeService),
	__param$70(6, IContextMenuService)
], MenuEntryActionViewItem);
var SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem$1 extends DropdownMenuActionViewItem {
	constructor(action, options, _contextMenuService, _themeService) {
		var _a$5, _b$1;
		const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {
			menuAsChild: (_a$5 = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a$5 !== void 0 ? _a$5 : false,
			classNames: (_b$1 = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b$1 !== void 0 ? _b$1 : ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : void 0
		});
		super(action, { getActions: () => action.actions }, _contextMenuService, dropdownOptions);
		this._contextMenuService = _contextMenuService;
		this._themeService = _themeService;
	}
	render(container) {
		super.render(container);
		assertType(this.element);
		container.classList.add("menu-entry");
		const { icon } = this._action.item;
		if (icon && !ThemeIcon.isThemeIcon(icon)) {
			this.element.classList.add("icon");
			const setBackgroundImage = () => {
				if (this.element) this.element.style.backgroundImage = isDark(this._themeService.getColorTheme().type) ? asCSSUrl(icon.dark) : asCSSUrl(icon.light);
			};
			setBackgroundImage();
			this._register(this._themeService.onDidColorThemeChange(() => {
				setBackgroundImage();
			}));
		}
	}
};
SubmenuEntryActionViewItem = __decorate$70([__param$70(2, IContextMenuService), __param$70(3, IThemeService)], SubmenuEntryActionViewItem);
var DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem$1 extends BaseActionViewItem {
	constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {
		var _a$5, _b$1, _c$1;
		super(null, submenuAction);
		this._keybindingService = _keybindingService;
		this._notificationService = _notificationService;
		this._contextMenuService = _contextMenuService;
		this._menuService = _menuService;
		this._instaService = _instaService;
		this._storageService = _storageService;
		this._container = null;
		this._options = options;
		this._storageKey = `${submenuAction.item.submenu.id}_lastActionId`;
		let defaultAction;
		const defaultActionId = _storageService.get(this._storageKey, 1);
		if (defaultActionId) defaultAction = submenuAction.actions.find((a) => defaultActionId === a.id);
		if (!defaultAction) defaultAction = submenuAction.actions[0];
		this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, { keybinding: this._getDefaultActionKeybindingLabel(defaultAction) });
		const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {
			menuAsChild: (_a$5 = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a$5 !== void 0 ? _a$5 : true,
			classNames: (_b$1 = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b$1 !== void 0 ? _b$1 : ["codicon", "codicon-chevron-down"],
			actionRunner: (_c$1 = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c$1 !== void 0 ? _c$1 : new ActionRunner()
		});
		this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);
		this._dropdown.actionRunner.onDidRun((e) => {
			if (e.action instanceof MenuItemAction) this.update(e.action);
		});
	}
	update(lastAction) {
		this._storageService.store(this._storageKey, lastAction.id, 1, 0);
		this._defaultAction.dispose();
		this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, { keybinding: this._getDefaultActionKeybindingLabel(lastAction) });
		this._defaultAction.actionRunner = new class extends ActionRunner {
			runAction(action, context) {
				return __awaiter$46(this, void 0, void 0, function* () {
					yield action.run(void 0);
				});
			}
		}();
		if (this._container) this._defaultAction.render(prepend(this._container, $(".action-container")));
	}
	_getDefaultActionKeybindingLabel(defaultAction) {
		var _a$5;
		let defaultActionKeybinding;
		if ((_a$5 = this._options) === null || _a$5 === void 0 ? void 0 : _a$5.renderKeybindingWithDefaultActionLabel) {
			const kb = this._keybindingService.lookupKeybinding(defaultAction.id);
			if (kb) defaultActionKeybinding = `(${kb.getLabel()})`;
		}
		return defaultActionKeybinding;
	}
	setActionContext(newContext) {
		super.setActionContext(newContext);
		this._defaultAction.setActionContext(newContext);
		this._dropdown.setActionContext(newContext);
	}
	render(container) {
		this._container = container;
		super.render(this._container);
		this._container.classList.add("monaco-dropdown-with-default");
		const primaryContainer = $(".action-container");
		this._defaultAction.render(append(this._container, primaryContainer));
		this._register(addDisposableListener(primaryContainer, EventType$1.KEY_DOWN, (e) => {
			const event = new StandardKeyboardEvent(e);
			if (event.equals(17)) {
				this._defaultAction.element.tabIndex = -1;
				this._dropdown.focus();
				event.stopPropagation();
			}
		}));
		const dropdownContainer = $(".dropdown-action-container");
		this._dropdown.render(append(this._container, dropdownContainer));
		this._register(addDisposableListener(dropdownContainer, EventType$1.KEY_DOWN, (e) => {
			var _a$5;
			const event = new StandardKeyboardEvent(e);
			if (event.equals(15)) {
				this._defaultAction.element.tabIndex = 0;
				this._dropdown.setFocusable(false);
				(_a$5 = this._defaultAction.element) === null || _a$5 === void 0 || _a$5.focus();
				event.stopPropagation();
			}
		}));
	}
	focus(fromRight) {
		if (fromRight) this._dropdown.focus();
		else {
			this._defaultAction.element.tabIndex = 0;
			this._defaultAction.element.focus();
		}
	}
	blur() {
		this._defaultAction.element.tabIndex = -1;
		this._dropdown.blur();
		this._container.blur();
	}
	setFocusable(focusable) {
		if (focusable) this._defaultAction.element.tabIndex = 0;
		else {
			this._defaultAction.element.tabIndex = -1;
			this._dropdown.setFocusable(false);
		}
	}
	dispose() {
		this._defaultAction.dispose();
		this._dropdown.dispose();
		super.dispose();
	}
};
DropdownWithDefaultActionViewItem = __decorate$70([
	__param$70(2, IKeybindingService),
	__param$70(3, INotificationService),
	__param$70(4, IContextMenuService),
	__param$70(5, IMenuService),
	__param$70(6, IInstantiationService),
	__param$70(7, IStorageService)
], DropdownWithDefaultActionViewItem);
/**
* Creates action view items for menu actions or submenu actions.
*/
function createActionViewItem(instaService, action, options) {
	if (action instanceof MenuItemAction) return instaService.createInstance(MenuEntryActionViewItem, action, options);
	else if (action instanceof SubmenuItemAction) if (action.item.rememberDefaultAction) return instaService.createInstance(DropdownWithDefaultActionViewItem, action, options);
	else return instaService.createInstance(SubmenuEntryActionViewItem, action, options);
	else return;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/peekView.js
var __decorate$69 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$69 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
const IPeekViewService = createDecorator("IPeekViewService");
registerSingleton(IPeekViewService, class {
	constructor() {
		this._widgets = /* @__PURE__ */ new Map();
	}
	addExclusiveWidget(editor$1, widget) {
		const existing = this._widgets.get(editor$1);
		if (existing) {
			existing.listener.dispose();
			existing.widget.dispose();
		}
		const remove = () => {
			const data = this._widgets.get(editor$1);
			if (data && data.widget === widget) {
				data.listener.dispose();
				this._widgets.delete(editor$1);
			}
		};
		this._widgets.set(editor$1, {
			widget,
			listener: widget.onDidClose(remove)
		});
	}
});
var PeekContext;
(function(PeekContext$1) {
	PeekContext$1.inPeekEditor = new RawContextKey("inReferenceSearchEditor", true, localize("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek"));
	PeekContext$1.notInPeekEditor = PeekContext$1.inPeekEditor.toNegated();
})(PeekContext || (PeekContext = {}));
var PeekContextController = class PeekContextController$1 {
	constructor(editor$1, contextKeyService) {
		if (editor$1 instanceof EmbeddedCodeEditorWidget) PeekContext.inPeekEditor.bindTo(contextKeyService);
	}
	dispose() {}
};
PeekContextController.ID = "editor.contrib.referenceController";
PeekContextController = __decorate$69([__param$69(1, IContextKeyService)], PeekContextController);
registerEditorContribution(PeekContextController.ID, PeekContextController);
function getOuterEditor(accessor) {
	const editor$1 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
	if (editor$1 instanceof EmbeddedCodeEditorWidget) return editor$1.getParentEditor();
	return editor$1;
}
var defaultOptions = {
	headerBackgroundColor: Color.white,
	primaryHeadingColor: Color.fromHex("#333333"),
	secondaryHeadingColor: Color.fromHex("#6c6c6cb3")
};
var PeekViewWidget = class PeekViewWidget$1 extends ZoneWidget {
	constructor(editor$1, options, instantiationService) {
		super(editor$1, options);
		this.instantiationService = instantiationService;
		this._onDidClose = new Emitter$1();
		this.onDidClose = this._onDidClose.event;
		mixin(this.options, defaultOptions, false);
	}
	dispose() {
		if (!this.disposed) {
			this.disposed = true;
			super.dispose();
			this._onDidClose.fire(this);
		}
	}
	style(styles) {
		const options = this.options;
		if (styles.headerBackgroundColor) options.headerBackgroundColor = styles.headerBackgroundColor;
		if (styles.primaryHeadingColor) options.primaryHeadingColor = styles.primaryHeadingColor;
		if (styles.secondaryHeadingColor) options.secondaryHeadingColor = styles.secondaryHeadingColor;
		super.style(styles);
	}
	_applyStyles() {
		super._applyStyles();
		const options = this.options;
		if (this._headElement && options.headerBackgroundColor) this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
		if (this._primaryHeading && options.primaryHeadingColor) this._primaryHeading.style.color = options.primaryHeadingColor.toString();
		if (this._secondaryHeading && options.secondaryHeadingColor) this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
		if (this._bodyElement && options.frameColor) this._bodyElement.style.borderColor = options.frameColor.toString();
	}
	_fillContainer(container) {
		this.setCssClass("peekview-widget");
		this._headElement = $(".head");
		this._bodyElement = $(".body");
		this._fillHead(this._headElement);
		this._fillBody(this._bodyElement);
		container.appendChild(this._headElement);
		container.appendChild(this._bodyElement);
	}
	_fillHead(container, noCloseAction) {
		const titleElement = $(".peekview-title");
		if (this.options.supportOnTitleClick) {
			titleElement.classList.add("clickable");
			addStandardDisposableListener(titleElement, "click", (event) => this._onTitleClick(event));
		}
		append(this._headElement, titleElement);
		this._fillTitleIcon(titleElement);
		this._primaryHeading = $("span.filename");
		this._secondaryHeading = $("span.dirname");
		this._metaHeading = $("span.meta");
		append(titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
		const actionsContainer = $(".peekview-actions");
		append(this._headElement, actionsContainer);
		this._actionbarWidget = new ActionBar(actionsContainer, this._getActionBarOptions());
		this._disposables.add(this._actionbarWidget);
		if (!noCloseAction) this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), Codicon.close.classNames, true, () => {
			this.dispose();
			return Promise.resolve();
		}), {
			label: false,
			icon: true
		});
	}
	_fillTitleIcon(container) {}
	_getActionBarOptions() {
		return {
			actionViewItemProvider: createActionViewItem.bind(void 0, this.instantiationService),
			orientation: 0
		};
	}
	_onTitleClick(event) {}
	setTitle(primaryHeading, secondaryHeading) {
		if (this._primaryHeading && this._secondaryHeading) {
			this._primaryHeading.innerText = primaryHeading;
			this._primaryHeading.setAttribute("title", primaryHeading);
			if (secondaryHeading) this._secondaryHeading.innerText = secondaryHeading;
			else clearNode(this._secondaryHeading);
		}
	}
	setMetaTitle(value) {
		if (this._metaHeading) if (value) {
			this._metaHeading.innerText = value;
			show(this._metaHeading);
		} else hide(this._metaHeading);
	}
	_doLayout(heightInPixel, widthInPixel) {
		if (!this._isShowing && heightInPixel < 0) {
			this.dispose();
			return;
		}
		const headHeight = Math.ceil(this.editor.getOption(61) * 1.2);
		const bodyHeight = Math.round(heightInPixel - (headHeight + 2));
		this._doLayoutHead(headHeight, widthInPixel);
		this._doLayoutBody(bodyHeight, widthInPixel);
	}
	_doLayoutHead(heightInPixel, widthInPixel) {
		if (this._headElement) {
			this._headElement.style.height = `${heightInPixel}px`;
			this._headElement.style.lineHeight = this._headElement.style.height;
		}
	}
	_doLayoutBody(heightInPixel, widthInPixel) {
		if (this._bodyElement) this._bodyElement.style.height = `${heightInPixel}px`;
	}
};
PeekViewWidget = __decorate$69([__param$69(2, IInstantiationService)], PeekViewWidget);
const peekViewTitleBackground = registerColor("peekViewTitle.background", {
	dark: transparent(editorInfoForeground, .1),
	light: transparent(editorInfoForeground, .1),
	hcDark: null,
	hcLight: null
}, localize("peekViewTitleBackground", "Background color of the peek view title area."));
const peekViewTitleForeground = registerColor("peekViewTitleLabel.foreground", {
	dark: Color.white,
	light: Color.black,
	hcDark: Color.white,
	hcLight: editorForeground
}, localize("peekViewTitleForeground", "Color of the peek view title."));
const peekViewTitleInfoForeground = registerColor("peekViewTitleDescription.foreground", {
	dark: "#ccccccb3",
	light: "#616161",
	hcDark: "#FFFFFF99",
	hcLight: "#292929"
}, localize("peekViewTitleInfoForeground", "Color of the peek view title info."));
const peekViewBorder = registerColor("peekView.border", {
	dark: editorInfoForeground,
	light: editorInfoForeground,
	hcDark: contrastBorder,
	hcLight: contrastBorder
}, localize("peekViewBorder", "Color of the peek view borders and arrow."));
const peekViewResultsBackground = registerColor("peekViewResult.background", {
	dark: "#252526",
	light: "#F3F3F3",
	hcDark: Color.black,
	hcLight: Color.white
}, localize("peekViewResultsBackground", "Background color of the peek view result list."));
const peekViewResultsMatchForeground = registerColor("peekViewResult.lineForeground", {
	dark: "#bbbbbb",
	light: "#646465",
	hcDark: Color.white,
	hcLight: editorForeground
}, localize("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
const peekViewResultsFileForeground = registerColor("peekViewResult.fileForeground", {
	dark: Color.white,
	light: "#1E1E1E",
	hcDark: Color.white,
	hcLight: editorForeground
}, localize("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
const peekViewResultsSelectionBackground = registerColor("peekViewResult.selectionBackground", {
	dark: "#3399ff33",
	light: "#3399ff33",
	hcDark: null,
	hcLight: null
}, localize("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
const peekViewResultsSelectionForeground = registerColor("peekViewResult.selectionForeground", {
	dark: Color.white,
	light: "#6C6C6C",
	hcDark: Color.white,
	hcLight: editorForeground
}, localize("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
const peekViewEditorBackground = registerColor("peekViewEditor.background", {
	dark: "#001F33",
	light: "#F2F8FC",
	hcDark: Color.black,
	hcLight: Color.white
}, localize("peekViewEditorBackground", "Background color of the peek view editor."));
const peekViewEditorGutterBackground = registerColor("peekViewEditorGutter.background", {
	dark: peekViewEditorBackground,
	light: peekViewEditorBackground,
	hcDark: peekViewEditorBackground,
	hcLight: peekViewEditorBackground
}, localize("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
const peekViewResultsMatchHighlight = registerColor("peekViewResult.matchHighlightBackground", {
	dark: "#ea5c004d",
	light: "#ea5c004d",
	hcDark: null,
	hcLight: null
}, localize("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
const peekViewEditorMatchHighlight = registerColor("peekViewEditor.matchHighlightBackground", {
	dark: "#ff8f0099",
	light: "#f5d802de",
	hcDark: null,
	hcLight: null
}, localize("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
const peekViewEditorMatchHighlightBorder = registerColor("peekViewEditor.matchHighlightBorder", {
	dark: null,
	light: null,
	hcDark: activeContrastBorder,
	hcLight: activeContrastBorder
}, localize("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/referencesModel.js
var __awaiter$45 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var OneReference = class {
	constructor(isProviderFirst, parent, link, _rangeCallback) {
		this.isProviderFirst = isProviderFirst;
		this.parent = parent;
		this.link = link;
		this._rangeCallback = _rangeCallback;
		this.id = defaultGenerator.nextId();
	}
	get uri() {
		return this.link.uri;
	}
	get range() {
		var _a$5, _b$1;
		return (_b$1 = (_a$5 = this._range) !== null && _a$5 !== void 0 ? _a$5 : this.link.targetSelectionRange) !== null && _b$1 !== void 0 ? _b$1 : this.link.range;
	}
	set range(value) {
		this._range = value;
		this._rangeCallback(this);
	}
	get ariaMessage() {
		var _a$5;
		const preview = (_a$5 = this.parent.getPreview(this)) === null || _a$5 === void 0 ? void 0 : _a$5.preview(this.range);
		if (!preview) return localize("aria.oneReference", "symbol in {0} on line {1} at column {2}", basename(this.uri), this.range.startLineNumber, this.range.startColumn);
		else return localize({
			key: "aria.oneReference.preview",
			comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"]
		}, "symbol in {0} on line {1} at column {2}, {3}", basename(this.uri), this.range.startLineNumber, this.range.startColumn, preview.value);
	}
};
var FilePreview = class {
	constructor(_modelReference) {
		this._modelReference = _modelReference;
	}
	dispose() {
		this._modelReference.dispose();
	}
	preview(range, n = 8) {
		const model = this._modelReference.object.textEditorModel;
		if (!model) return;
		const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
		const beforeRange = new Range$1(startLineNumber, model.getWordUntilPosition({
			lineNumber: startLineNumber,
			column: startColumn - n
		}).startColumn, startLineNumber, startColumn);
		const afterRange = new Range$1(endLineNumber, endColumn, endLineNumber, 1073741824);
		const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
		const inside = model.getValueInRange(range);
		const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
		return {
			value: before + inside + after,
			highlight: {
				start: before.length,
				end: before.length + inside.length
			}
		};
	}
};
var FileReferences = class {
	constructor(parent, uri) {
		this.parent = parent;
		this.uri = uri;
		this.children = [];
		this._previews = new ResourceMap();
	}
	dispose() {
		dispose(this._previews.values());
		this._previews.clear();
	}
	getPreview(child) {
		return this._previews.get(child.uri);
	}
	get ariaMessage() {
		const len = this.children.length;
		if (len === 1) return localize("aria.fileReferences.1", "1 symbol in {0}, full path {1}", basename(this.uri), this.uri.fsPath);
		else return localize("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", len, basename(this.uri), this.uri.fsPath);
	}
	resolve(textModelResolverService) {
		return __awaiter$45(this, void 0, void 0, function* () {
			if (this._previews.size !== 0) return this;
			for (const child of this.children) {
				if (this._previews.has(child.uri)) continue;
				try {
					const ref = yield textModelResolverService.createModelReference(child.uri);
					this._previews.set(child.uri, new FilePreview(ref));
				} catch (err) {
					onUnexpectedError(err);
				}
			}
			return this;
		});
	}
};
var ReferencesModel = class ReferencesModel {
	constructor(links, title) {
		this.groups = [];
		this.references = [];
		this._onDidChangeReferenceRange = new Emitter$1();
		this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
		this._links = links;
		this._title = title;
		const [providersFirst] = links;
		links.sort(ReferencesModel._compareReferences);
		let current;
		for (const link of links) {
			if (!current || !extUri.isEqual(current.uri, link.uri, true)) {
				current = new FileReferences(this, link.uri);
				this.groups.push(current);
			}
			if (current.children.length === 0 || ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {
				const oneRef = new OneReference(providersFirst === link, current, link, (ref) => this._onDidChangeReferenceRange.fire(ref));
				this.references.push(oneRef);
				current.children.push(oneRef);
			}
		}
	}
	dispose() {
		dispose(this.groups);
		this._onDidChangeReferenceRange.dispose();
		this.groups.length = 0;
	}
	clone() {
		return new ReferencesModel(this._links, this._title);
	}
	get title() {
		return this._title;
	}
	get isEmpty() {
		return this.groups.length === 0;
	}
	get ariaMessage() {
		if (this.isEmpty) return localize("aria.result.0", "No results found");
		else if (this.references.length === 1) return localize("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath);
		else if (this.groups.length === 1) return localize("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
		else return localize("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
	}
	nextOrPreviousReference(reference, next) {
		const { parent } = reference;
		let idx = parent.children.indexOf(reference);
		const childCount = parent.children.length;
		const groupCount = parent.parent.groups.length;
		if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
			if (next) idx = (idx + 1) % childCount;
			else idx = (idx + childCount - 1) % childCount;
			return parent.children[idx];
		}
		idx = parent.parent.groups.indexOf(parent);
		if (next) {
			idx = (idx + 1) % groupCount;
			return parent.parent.groups[idx].children[0];
		} else {
			idx = (idx + groupCount - 1) % groupCount;
			return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
		}
	}
	nearestReference(resource, position) {
		const nearest = this.references.map((ref, idx) => {
			return {
				idx,
				prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
				offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
			};
		}).sort((a, b) => {
			if (a.prefixLen > b.prefixLen) return -1;
			else if (a.prefixLen < b.prefixLen) return 1;
			else if (a.offsetDist < b.offsetDist) return -1;
			else if (a.offsetDist > b.offsetDist) return 1;
			else return 0;
		})[0];
		if (nearest) return this.references[nearest.idx];
	}
	referenceAt(resource, position) {
		for (const ref of this.references) if (ref.uri.toString() === resource.toString()) {
			if (Range$1.containsPosition(ref.range, position)) return ref;
		}
	}
	firstReference() {
		for (const ref of this.references) if (ref.isProviderFirst) return ref;
		return this.references[0];
	}
	static _compareReferences(a, b) {
		return extUri.compare(a.uri, b.uri) || Range$1.compareRangesUsingStarts(a.range, b.range);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js
var __decorate$68 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$68 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var DataSource = class DataSource$1 {
	constructor(_resolverService) {
		this._resolverService = _resolverService;
	}
	hasChildren(element) {
		if (element instanceof ReferencesModel) return true;
		if (element instanceof FileReferences) return true;
		return false;
	}
	getChildren(element) {
		if (element instanceof ReferencesModel) return element.groups;
		if (element instanceof FileReferences) return element.resolve(this._resolverService).then((val) => {
			return val.children;
		});
		throw new Error("bad tree");
	}
};
DataSource = __decorate$68([__param$68(0, ITextModelService)], DataSource);
var Delegate = class {
	getHeight() {
		return 23;
	}
	getTemplateId(element) {
		if (element instanceof FileReferences) return FileReferencesRenderer.id;
		else return OneReferenceRenderer.id;
	}
};
var StringRepresentationProvider = class StringRepresentationProvider$1 {
	constructor(_keybindingService) {
		this._keybindingService = _keybindingService;
	}
	getKeyboardNavigationLabel(element) {
		var _a$5;
		if (element instanceof OneReference) {
			const parts = (_a$5 = element.parent.getPreview(element)) === null || _a$5 === void 0 ? void 0 : _a$5.preview(element.range);
			if (parts) return parts.value;
		}
		return basename(element.uri);
	}
};
StringRepresentationProvider = __decorate$68([__param$68(0, IKeybindingService)], StringRepresentationProvider);
var IdentityProvider = class {
	getId(element) {
		return element instanceof OneReference ? element.id : element.uri;
	}
};
var FileReferencesTemplate = class FileReferencesTemplate$1 extends Disposable {
	constructor(container, _labelService, themeService) {
		super();
		this._labelService = _labelService;
		const parent = document.createElement("div");
		parent.classList.add("reference-file");
		this.file = this._register(new IconLabel(parent, { supportHighlights: true }));
		this.badge = new CountBadge(append(parent, $(".count")));
		this._register(attachBadgeStyler(this.badge, themeService));
		container.appendChild(parent);
	}
	set(element, matches) {
		const parent = dirname(element.uri);
		this.file.setLabel(this._labelService.getUriBasenameLabel(element.uri), this._labelService.getUriLabel(parent, { relative: true }), {
			title: this._labelService.getUriLabel(element.uri),
			matches
		});
		const len = element.children.length;
		this.badge.setCount(len);
		if (len > 1) this.badge.setTitleFormat(localize("referencesCount", "{0} references", len));
		else this.badge.setTitleFormat(localize("referenceCount", "{0} reference", len));
	}
};
FileReferencesTemplate = __decorate$68([__param$68(1, ILabelService), __param$68(2, IThemeService)], FileReferencesTemplate);
var FileReferencesRenderer = class FileReferencesRenderer$1 {
	constructor(_instantiationService) {
		this._instantiationService = _instantiationService;
		this.templateId = FileReferencesRenderer$1.id;
	}
	renderTemplate(container) {
		return this._instantiationService.createInstance(FileReferencesTemplate, container);
	}
	renderElement(node, index, template) {
		template.set(node.element, createMatches(node.filterData));
	}
	disposeTemplate(templateData) {
		templateData.dispose();
	}
};
FileReferencesRenderer.id = "FileReferencesRenderer";
FileReferencesRenderer = __decorate$68([__param$68(0, IInstantiationService)], FileReferencesRenderer);
var OneReferenceTemplate = class {
	constructor(container) {
		this.label = new HighlightedLabel(container);
	}
	set(element, score) {
		var _a$5;
		const preview = (_a$5 = element.parent.getPreview(element)) === null || _a$5 === void 0 ? void 0 : _a$5.preview(element.range);
		if (!preview || !preview.value) this.label.set(`${basename(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
		else {
			const { value, highlight } = preview;
			if (score && !FuzzyScore.isDefault(score)) {
				this.label.element.classList.toggle("referenceMatch", false);
				this.label.set(value, createMatches(score));
			} else {
				this.label.element.classList.toggle("referenceMatch", true);
				this.label.set(value, [highlight]);
			}
		}
	}
};
var OneReferenceRenderer = class OneReferenceRenderer {
	constructor() {
		this.templateId = OneReferenceRenderer.id;
	}
	renderTemplate(container) {
		return new OneReferenceTemplate(container);
	}
	renderElement(node, index, templateData) {
		templateData.set(node.element, node.filterData);
	}
	disposeTemplate() {}
};
OneReferenceRenderer.id = "OneReferenceRenderer";
var AccessibilityProvider = class {
	getWidgetAriaLabel() {
		return localize("treeAriaLabel", "References");
	}
	getAriaLabel(element) {
		return element.ariaMessage;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js
var __decorate$67 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$67 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$44 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var DecorationsManager = class DecorationsManager {
	constructor(_editor, _model) {
		this._editor = _editor;
		this._model = _model;
		this._decorations = /* @__PURE__ */ new Map();
		this._decorationIgnoreSet = /* @__PURE__ */ new Set();
		this._callOnDispose = new DisposableStore();
		this._callOnModelChange = new DisposableStore();
		this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
		this._onModelChanged();
	}
	dispose() {
		this._callOnModelChange.dispose();
		this._callOnDispose.dispose();
		this.removeDecorations();
	}
	_onModelChanged() {
		this._callOnModelChange.clear();
		const model = this._editor.getModel();
		if (!model) return;
		for (const ref of this._model.references) if (ref.uri.toString() === model.uri.toString()) {
			this._addDecorations(ref.parent);
			return;
		}
	}
	_addDecorations(reference) {
		if (!this._editor.hasModel()) return;
		this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
		const newDecorations = [];
		const newDecorationsActualIndex = [];
		for (let i = 0, len = reference.children.length; i < len; i++) {
			const oneReference = reference.children[i];
			if (this._decorationIgnoreSet.has(oneReference.id)) continue;
			if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) continue;
			newDecorations.push({
				range: oneReference.range,
				options: DecorationsManager.DecorationOptions
			});
			newDecorationsActualIndex.push(i);
		}
		this._editor.changeDecorations((changeAccessor) => {
			const decorations = changeAccessor.deltaDecorations([], newDecorations);
			for (let i = 0; i < decorations.length; i++) this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
		});
	}
	_onDecorationChanged() {
		const toRemove = [];
		const model = this._editor.getModel();
		if (!model) return;
		for (const [decorationId, reference] of this._decorations) {
			const newRange = model.getDecorationRange(decorationId);
			if (!newRange) continue;
			let ignore = false;
			if (Range$1.equalsRange(newRange, reference.range)) continue;
			if (Range$1.spansMultipleLines(newRange)) ignore = true;
			else if (reference.range.endColumn - reference.range.startColumn !== newRange.endColumn - newRange.startColumn) ignore = true;
			if (ignore) {
				this._decorationIgnoreSet.add(reference.id);
				toRemove.push(decorationId);
			} else reference.range = newRange;
		}
		for (let i = 0, len = toRemove.length; i < len; i++) this._decorations.delete(toRemove[i]);
		this._editor.removeDecorations(toRemove);
	}
	removeDecorations() {
		this._editor.removeDecorations([...this._decorations.keys()]);
		this._decorations.clear();
	}
};
DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
	description: "reference-decoration",
	stickiness: 1,
	className: "reference-decoration"
});
var LayoutData = class {
	constructor() {
		this.ratio = .7;
		this.heightInLines = 18;
	}
	static fromJSON(raw) {
		let ratio;
		let heightInLines;
		try {
			const data = JSON.parse(raw);
			ratio = data.ratio;
			heightInLines = data.heightInLines;
		} catch (_a$5) {}
		return {
			ratio: ratio || .7,
			heightInLines: heightInLines || 18
		};
	}
};
var ReferencesTree = class extends WorkbenchAsyncDataTree {};
/**
* ZoneWidget that is shown inside the editor
*/
var ReferenceWidget = class ReferenceWidget$1 extends PeekViewWidget {
	constructor(editor$1, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService, _languageService, _languageConfigurationService) {
		super(editor$1, {
			showFrame: false,
			showArrow: true,
			isResizeable: true,
			isAccessible: true,
			supportOnTitleClick: true
		}, _instantiationService);
		this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
		this.layoutData = layoutData;
		this._textModelResolverService = _textModelResolverService;
		this._instantiationService = _instantiationService;
		this._peekViewService = _peekViewService;
		this._uriLabel = _uriLabel;
		this._undoRedoService = _undoRedoService;
		this._keybindingService = _keybindingService;
		this._languageService = _languageService;
		this._languageConfigurationService = _languageConfigurationService;
		this._disposeOnNewModel = new DisposableStore();
		this._callOnDispose = new DisposableStore();
		this._onDidSelectReference = new Emitter$1();
		this.onDidSelectReference = this._onDidSelectReference.event;
		this._dim = new Dimension(0, 0);
		this._applyTheme(themeService.getColorTheme());
		this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
		this._peekViewService.addExclusiveWidget(editor$1, this);
		this.create();
	}
	dispose() {
		this.setModel(void 0);
		this._callOnDispose.dispose();
		this._disposeOnNewModel.dispose();
		dispose(this._preview);
		dispose(this._previewNotAvailableMessage);
		dispose(this._tree);
		dispose(this._previewModelReference);
		this._splitView.dispose();
		super.dispose();
	}
	_applyTheme(theme) {
		const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
		this.style({
			arrowColor: borderColor,
			frameColor: borderColor,
			headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
			primaryHeadingColor: theme.getColor(peekViewTitleForeground),
			secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
		});
	}
	show(where) {
		super.show(where, this.layoutData.heightInLines || 18);
	}
	focusOnReferenceTree() {
		this._tree.domFocus();
	}
	focusOnPreviewEditor() {
		this._preview.focus();
	}
	isPreviewEditorFocused() {
		return this._preview.hasTextFocus();
	}
	_onTitleClick(e) {
		if (this._preview && this._preview.getModel()) this._onDidSelectReference.fire({
			element: this._getFocusedReference(),
			kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
			source: "title"
		});
	}
	_fillBody(containerElement) {
		this.setCssClass("reference-zone-widget");
		this._messageContainer = append(containerElement, $("div.messages"));
		hide(this._messageContainer);
		this._splitView = new SplitView(containerElement, { orientation: 1 });
		this._previewContainer = append(containerElement, $("div.preview.inline"));
		this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, {
			scrollBeyondLastLine: false,
			scrollbar: {
				verticalScrollbarSize: 14,
				horizontal: "auto",
				useShadows: true,
				verticalHasArrows: false,
				horizontalHasArrows: false,
				alwaysConsumeMouseWheel: false
			},
			overviewRulerLanes: 2,
			fixedOverflowWidgets: true,
			minimap: { enabled: false }
		}, this.editor);
		hide(this._previewContainer);
		this._previewNotAvailableMessage = new TextModel(localize("missingPreviewMessage", "no preview available"), PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService);
		this._treeContainer = append(containerElement, $("div.ref-tree.inline"));
		const treeOptions = {
			keyboardSupport: this._defaultTreeKeyboardSupport,
			accessibilityProvider: new AccessibilityProvider(),
			keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
			identityProvider: new IdentityProvider(),
			openOnSingleClick: true,
			selectionNavigation: true,
			overrideStyles: { listBackground: peekViewResultsBackground }
		};
		if (this._defaultTreeKeyboardSupport) this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
			if (e.equals(9)) {
				this._keybindingService.dispatchEvent(e, e.target);
				e.stopPropagation();
			}
		}, true));
		this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [this._instantiationService.createInstance(FileReferencesRenderer), this._instantiationService.createInstance(OneReferenceRenderer)], this._instantiationService.createInstance(DataSource), treeOptions);
		this._splitView.addView({
			onDidChange: Event.None,
			element: this._previewContainer,
			minimumSize: 200,
			maximumSize: Number.MAX_VALUE,
			layout: (width) => {
				this._preview.layout({
					height: this._dim.height,
					width
				});
			}
		}, Sizing.Distribute);
		this._splitView.addView({
			onDidChange: Event.None,
			element: this._treeContainer,
			minimumSize: 100,
			maximumSize: Number.MAX_VALUE,
			layout: (width) => {
				this._treeContainer.style.height = `${this._dim.height}px`;
				this._treeContainer.style.width = `${width}px`;
				this._tree.layout(this._dim.height, width);
			}
		}, Sizing.Distribute);
		this._disposables.add(this._splitView.onDidSashChange(() => {
			if (this._dim.width) this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
		}, void 0));
		const onEvent = (element, kind) => {
			if (element instanceof OneReference) {
				if (kind === "show") this._revealReference(element, false);
				this._onDidSelectReference.fire({
					element,
					kind,
					source: "tree"
				});
			}
		};
		this._tree.onDidOpen((e) => {
			if (e.sideBySide) onEvent(e.element, "side");
			else if (e.editorOptions.pinned) onEvent(e.element, "goto");
			else onEvent(e.element, "show");
		});
		hide(this._treeContainer);
	}
	_onWidth(width) {
		if (this._dim) this._doLayoutBody(this._dim.height, width);
	}
	_doLayoutBody(heightInPixel, widthInPixel) {
		super._doLayoutBody(heightInPixel, widthInPixel);
		this._dim = new Dimension(widthInPixel, heightInPixel);
		this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
		this._splitView.layout(widthInPixel);
		this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
	}
	setSelection(selection) {
		return this._revealReference(selection, true).then(() => {
			if (!this._model) return;
			this._tree.setSelection([selection]);
			this._tree.setFocus([selection]);
		});
	}
	setModel(newModel) {
		this._disposeOnNewModel.clear();
		this._model = newModel;
		if (this._model) return this._onNewModel();
		return Promise.resolve();
	}
	_onNewModel() {
		if (!this._model) return Promise.resolve(void 0);
		if (this._model.isEmpty) {
			this.setTitle("");
			this._messageContainer.innerText = localize("noResults", "No results");
			show(this._messageContainer);
			return Promise.resolve(void 0);
		}
		hide(this._messageContainer);
		this._decorationsManager = new DecorationsManager(this._preview, this._model);
		this._disposeOnNewModel.add(this._decorationsManager);
		this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference) => this._tree.rerender(reference)));
		this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
			const { event, target } = e;
			if (event.detail !== 2) return;
			const element = this._getFocusedReference();
			if (!element) return;
			this._onDidSelectReference.fire({
				element: {
					uri: element.uri,
					range: target.range
				},
				kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
				source: "editor"
			});
		}));
		this.container.classList.add("results-loaded");
		show(this._treeContainer);
		show(this._previewContainer);
		this._splitView.layout(this._dim.width);
		this.focusOnReferenceTree();
		return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
	}
	_getFocusedReference() {
		const [element] = this._tree.getFocus();
		if (element instanceof OneReference) return element;
		else if (element instanceof FileReferences) {
			if (element.children.length > 0) return element.children[0];
		}
	}
	revealReference(reference) {
		return __awaiter$44(this, void 0, void 0, function* () {
			yield this._revealReference(reference, false);
			this._onDidSelectReference.fire({
				element: reference,
				kind: "goto",
				source: "tree"
			});
		});
	}
	_revealReference(reference, revealParent) {
		return __awaiter$44(this, void 0, void 0, function* () {
			if (this._revealedReference === reference) return;
			this._revealedReference = reference;
			if (reference.uri.scheme !== Schemas.inMemory) this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname(reference.uri)));
			else this.setTitle(localize("peekView.alternateTitle", "References"));
			const promise = this._textModelResolverService.createModelReference(reference.uri);
			if (this._tree.getInput() === reference.parent) this._tree.reveal(reference);
			else {
				if (revealParent) this._tree.reveal(reference.parent);
				yield this._tree.expand(reference.parent);
				this._tree.reveal(reference);
			}
			const ref = yield promise;
			if (!this._model) {
				ref.dispose();
				return;
			}
			dispose(this._previewModelReference);
			const model = ref.object;
			if (model) {
				const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
				const sel = Range$1.lift(reference.range).collapseToStart();
				this._previewModelReference = ref;
				this._preview.setModel(model.textEditorModel);
				this._preview.setSelection(sel);
				this._preview.revealRangeInCenter(sel, scrollType);
			} else {
				this._preview.setModel(this._previewNotAvailableMessage);
				ref.dispose();
			}
		});
	}
};
ReferenceWidget = __decorate$67([
	__param$67(3, IThemeService),
	__param$67(4, ITextModelService),
	__param$67(5, IInstantiationService),
	__param$67(6, IPeekViewService),
	__param$67(7, ILabelService),
	__param$67(8, IUndoRedoService),
	__param$67(9, IKeybindingService),
	__param$67(10, ILanguageService),
	__param$67(11, ILanguageConfigurationService)
], ReferenceWidget);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
var __decorate$66 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$66 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$43 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false, localize("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
var ReferencesController = class ReferencesController$1 {
	constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
		this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
		this._editor = _editor;
		this._editorService = _editorService;
		this._notificationService = _notificationService;
		this._instantiationService = _instantiationService;
		this._storageService = _storageService;
		this._configurationService = _configurationService;
		this._disposables = new DisposableStore();
		this._requestIdPool = 0;
		this._ignoreModelChangeEvent = false;
		this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
	}
	static get(editor$1) {
		return editor$1.getContribution(ReferencesController$1.ID);
	}
	dispose() {
		var _a$5, _b$1;
		this._referenceSearchVisible.reset();
		this._disposables.dispose();
		(_a$5 = this._widget) === null || _a$5 === void 0 || _a$5.dispose();
		(_b$1 = this._model) === null || _b$1 === void 0 || _b$1.dispose();
		this._widget = void 0;
		this._model = void 0;
	}
	toggleWidget(range, modelPromise, peekMode) {
		let widgetPosition;
		if (this._widget) widgetPosition = this._widget.position;
		this.closeWidget();
		if (!!widgetPosition && range.containsPosition(widgetPosition)) return;
		this._peekMode = peekMode;
		this._referenceSearchVisible.set(true);
		this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
			this.closeWidget();
		}));
		this._disposables.add(this._editor.onDidChangeModel(() => {
			if (!this._ignoreModelChangeEvent) this.closeWidget();
		}));
		const storageKey = "peekViewLayout";
		const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
		this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
		this._widget.setTitle(localize("labelLoading", "Loading..."));
		this._widget.show(range);
		this._disposables.add(this._widget.onDidClose(() => {
			modelPromise.cancel();
			if (this._widget) {
				this._storageService.store(storageKey, JSON.stringify(this._widget.layoutData), 0, 1);
				this._widget = void 0;
			}
			this.closeWidget();
		}));
		this._disposables.add(this._widget.onDidSelectReference((event) => {
			const { element, kind } = event;
			if (!element) return;
			switch (kind) {
				case "open":
					if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) this.openReference(element, false, false);
					break;
				case "side":
					this.openReference(element, true, false);
					break;
				case "goto":
					if (peekMode) this._gotoReference(element);
					else this.openReference(element, false, true);
					break;
			}
		}));
		const requestId = ++this._requestIdPool;
		modelPromise.then((model) => {
			var _a$5;
			if (requestId !== this._requestIdPool || !this._widget) {
				model.dispose();
				return;
			}
			(_a$5 = this._model) === null || _a$5 === void 0 || _a$5.dispose();
			this._model = model;
			return this._widget.setModel(this._model).then(() => {
				if (this._widget && this._model && this._editor.hasModel()) {
					if (!this._model.isEmpty) this._widget.setMetaTitle(localize("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
					else this._widget.setMetaTitle("");
					const uri = this._editor.getModel().uri;
					const pos = new Position$1(range.startLineNumber, range.startColumn);
					const selection = this._model.nearestReference(uri, pos);
					if (selection) return this._widget.setSelection(selection).then(() => {
						if (this._widget && this._editor.getOption(79) === "editor") this._widget.focusOnPreviewEditor();
					});
				}
			});
		}, (error) => {
			this._notificationService.error(error);
		});
	}
	changeFocusBetweenPreviewAndReferences() {
		if (!this._widget) return;
		if (this._widget.isPreviewEditorFocused()) this._widget.focusOnReferenceTree();
		else this._widget.focusOnPreviewEditor();
	}
	goToNextOrPreviousReference(fwd) {
		return __awaiter$43(this, void 0, void 0, function* () {
			if (!this._editor.hasModel() || !this._model || !this._widget) return;
			const currentPosition = this._widget.position;
			if (!currentPosition) return;
			const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
			if (!source) return;
			const target = this._model.nextOrPreviousReference(source, fwd);
			const editorFocus = this._editor.hasTextFocus();
			const previewEditorFocus = this._widget.isPreviewEditorFocused();
			yield this._widget.setSelection(target);
			yield this._gotoReference(target);
			if (editorFocus) this._editor.focus();
			else if (this._widget && previewEditorFocus) this._widget.focusOnPreviewEditor();
		});
	}
	revealReference(reference) {
		return __awaiter$43(this, void 0, void 0, function* () {
			if (!this._editor.hasModel() || !this._model || !this._widget) return;
			yield this._widget.revealReference(reference);
		});
	}
	closeWidget(focusEditor = true) {
		var _a$5, _b$1;
		(_a$5 = this._widget) === null || _a$5 === void 0 || _a$5.dispose();
		(_b$1 = this._model) === null || _b$1 === void 0 || _b$1.dispose();
		this._referenceSearchVisible.reset();
		this._disposables.clear();
		this._widget = void 0;
		this._model = void 0;
		if (focusEditor) this._editor.focus();
		this._requestIdPool += 1;
	}
	_gotoReference(ref) {
		if (this._widget) this._widget.hide();
		this._ignoreModelChangeEvent = true;
		const range = Range$1.lift(ref.range).collapseToStart();
		return this._editorService.openCodeEditor({
			resource: ref.uri,
			options: {
				selection: range,
				selectionSource: "code.jump"
			}
		}, this._editor).then((openedEditor) => {
			var _a$5;
			this._ignoreModelChangeEvent = false;
			if (!openedEditor || !this._widget) {
				this.closeWidget();
				return;
			}
			if (this._editor === openedEditor) {
				this._widget.show(range);
				this._widget.focusOnReferenceTree();
			} else {
				const other = ReferencesController$1.get(openedEditor);
				const model = this._model.clone();
				this.closeWidget();
				openedEditor.focus();
				other === null || other === void 0 || other.toggleWidget(range, createCancelablePromise((_) => Promise.resolve(model)), (_a$5 = this._peekMode) !== null && _a$5 !== void 0 ? _a$5 : false);
			}
		}, (err) => {
			this._ignoreModelChangeEvent = false;
			onUnexpectedError(err);
		});
	}
	openReference(ref, sideBySide, pinned) {
		if (!sideBySide) this.closeWidget();
		const { uri, range } = ref;
		this._editorService.openCodeEditor({
			resource: uri,
			options: {
				selection: range,
				selectionSource: "code.jump",
				pinned
			}
		}, this._editor, sideBySide);
	}
};
ReferencesController.ID = "editor.contrib.referencesController";
ReferencesController = __decorate$66([
	__param$66(2, IContextKeyService),
	__param$66(3, ICodeEditorService),
	__param$66(4, INotificationService),
	__param$66(5, IInstantiationService),
	__param$66(6, IStorageService),
	__param$66(7, IConfigurationService)
], ReferencesController);
function withController(accessor, fn) {
	const outerEditor = getOuterEditor(accessor);
	if (!outerEditor) return;
	const controller = ReferencesController.get(outerEditor);
	if (controller) fn(controller);
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "togglePeekWidgetFocus",
	weight: 100,
	primary: KeyChord(2089, 60),
	when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
	handler(accessor) {
		withController(accessor, (controller) => {
			controller.changeFocusBetweenPreviewAndReferences();
		});
	}
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "goToNextReference",
	weight: 90,
	primary: 62,
	secondary: [70],
	when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
	handler(accessor) {
		withController(accessor, (controller) => {
			controller.goToNextOrPreviousReference(true);
		});
	}
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "goToPreviousReference",
	weight: 90,
	primary: 1086,
	secondary: [1094],
	when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
	handler(accessor) {
		withController(accessor, (controller) => {
			controller.goToNextOrPreviousReference(false);
		});
	}
});
CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
KeybindingsRegistry.registerKeybindingRule({
	id: "closeReferenceSearch",
	weight: -1,
	primary: 9,
	secondary: [1033],
	when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerKeybindingRule({
	id: "closeReferenceSearch",
	weight: 250,
	primary: 9,
	secondary: [1033],
	when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "revealReference",
	weight: 200,
	primary: 3,
	mac: {
		primary: 3,
		secondary: [2066]
	},
	when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
	handler(accessor) {
		var _a$5;
		const focus = (_a$5 = accessor.get(IListService).lastFocusedList) === null || _a$5 === void 0 ? void 0 : _a$5.getFocus();
		if (Array.isArray(focus) && focus[0] instanceof OneReference) withController(accessor, (controller) => controller.revealReference(focus[0]));
	}
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "openReferenceToSide",
	weight: 100,
	primary: 2051,
	mac: { primary: 259 },
	when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
	handler(accessor) {
		var _a$5;
		const focus = (_a$5 = accessor.get(IListService).lastFocusedList) === null || _a$5 === void 0 ? void 0 : _a$5.getFocus();
		if (Array.isArray(focus) && focus[0] instanceof OneReference) withController(accessor, (controller) => controller.openReference(focus[0], true, true));
	}
});
CommandsRegistry.registerCommand("openReference", (accessor) => {
	var _a$5;
	const focus = (_a$5 = accessor.get(IListService).lastFocusedList) === null || _a$5 === void 0 ? void 0 : _a$5.getFocus();
	if (Array.isArray(focus) && focus[0] instanceof OneReference) withController(accessor, (controller) => controller.openReference(focus[0], false, true));
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js
var __decorate$65 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$65 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
const ctxHasSymbols = new RawContextKey("hasSymbols", false, localize("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only."));
const ISymbolNavigationService = createDecorator("ISymbolNavigationService");
var SymbolNavigationService = class SymbolNavigationService$1 {
	constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
		this._editorService = _editorService;
		this._notificationService = _notificationService;
		this._keybindingService = _keybindingService;
		this._currentModel = void 0;
		this._currentIdx = -1;
		this._ignoreEditorChange = false;
		this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
	}
	reset() {
		var _a$5, _b$1;
		this._ctxHasSymbols.reset();
		(_a$5 = this._currentState) === null || _a$5 === void 0 || _a$5.dispose();
		(_b$1 = this._currentMessage) === null || _b$1 === void 0 || _b$1.dispose();
		this._currentModel = void 0;
		this._currentIdx = -1;
	}
	put(anchor) {
		const refModel = anchor.parent.parent;
		if (refModel.references.length <= 1) {
			this.reset();
			return;
		}
		this._currentModel = refModel;
		this._currentIdx = refModel.references.indexOf(anchor);
		this._ctxHasSymbols.set(true);
		this._showMessage();
		const editorState = new EditorState$1(this._editorService);
		this._currentState = combinedDisposable(editorState, editorState.onDidChange((_) => {
			if (this._ignoreEditorChange) return;
			const editor$1 = this._editorService.getActiveCodeEditor();
			if (!editor$1) return;
			const model = editor$1.getModel();
			const position = editor$1.getPosition();
			if (!model || !position) return;
			let seenUri = false;
			let seenPosition = false;
			for (const reference of refModel.references) if (isEqual(reference.uri, model.uri)) {
				seenUri = true;
				seenPosition = seenPosition || Range$1.containsPosition(reference.range, position);
			} else if (seenUri) break;
			if (!seenUri || !seenPosition) this.reset();
		}));
	}
	revealNext(source) {
		if (!this._currentModel) return Promise.resolve();
		this._currentIdx += 1;
		this._currentIdx %= this._currentModel.references.length;
		const reference = this._currentModel.references[this._currentIdx];
		this._showMessage();
		this._ignoreEditorChange = true;
		return this._editorService.openCodeEditor({
			resource: reference.uri,
			options: {
				selection: Range$1.collapseToStart(reference.range),
				selectionRevealType: 3
			}
		}, source).finally(() => {
			this._ignoreEditorChange = false;
		});
	}
	_showMessage() {
		var _a$5;
		(_a$5 = this._currentMessage) === null || _a$5 === void 0 || _a$5.dispose();
		const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
		const message = kb ? localize("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
		this._currentMessage = this._notificationService.status(message);
	}
};
SymbolNavigationService = __decorate$65([
	__param$65(0, IContextKeyService),
	__param$65(1, ICodeEditorService),
	__param$65(2, INotificationService),
	__param$65(3, IKeybindingService)
], SymbolNavigationService);
registerSingleton(ISymbolNavigationService, SymbolNavigationService, true);
registerEditorCommand(new class extends EditorCommand {
	constructor() {
		super({
			id: "editor.gotoNextSymbolFromResult",
			precondition: ctxHasSymbols,
			kbOpts: {
				weight: 100,
				primary: 70
			}
		});
	}
	runEditorCommand(accessor, editor$1) {
		return accessor.get(ISymbolNavigationService).revealNext(editor$1);
	}
}());
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "editor.gotoNextSymbolFromResult.cancel",
	weight: 100,
	when: ctxHasSymbols,
	primary: 9,
	handler(accessor) {
		accessor.get(ISymbolNavigationService).reset();
	}
});
var EditorState$1 = class EditorState$2 {
	constructor(editorService) {
		this._listener = /* @__PURE__ */ new Map();
		this._disposables = new DisposableStore();
		this._onDidChange = new Emitter$1();
		this.onDidChange = this._onDidChange.event;
		this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
		this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
		editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
	}
	dispose() {
		this._disposables.dispose();
		this._onDidChange.dispose();
		dispose(this._listener.values());
	}
	_onDidAddEditor(editor$1) {
		this._listener.set(editor$1, combinedDisposable(editor$1.onDidChangeCursorPosition((_) => this._onDidChange.fire({ editor: editor$1 })), editor$1.onDidChangeModelContent((_) => this._onDidChange.fire({ editor: editor$1 }))));
	}
	_onDidRemoveEditor(editor$1) {
		var _a$5;
		(_a$5 = this._listener.get(editor$1)) === null || _a$5 === void 0 || _a$5.dispose();
		this._listener.delete(editor$1);
	}
};
EditorState$1 = __decorate$65([__param$65(0, ICodeEditorService)], EditorState$1);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js
var __awaiter$42 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
function getLocationLinks(model, position, registry, provide) {
	const promises = registry.ordered(model).map((provider) => {
		return Promise.resolve(provide(provider, model, position)).then(void 0, (err) => {
			onUnexpectedExternalError(err);
		});
	});
	return Promise.all(promises).then((values) => {
		const result = [];
		for (const value of values) if (Array.isArray(value)) result.push(...value);
		else if (value) result.push(value);
		return result;
	});
}
function getDefinitionsAtPosition(registry, model, position, token) {
	return getLocationLinks(model, position, registry, (provider, model$1, position$1) => {
		return provider.provideDefinition(model$1, position$1, token);
	});
}
function getDeclarationsAtPosition(registry, model, position, token) {
	return getLocationLinks(model, position, registry, (provider, model$1, position$1) => {
		return provider.provideDeclaration(model$1, position$1, token);
	});
}
function getImplementationsAtPosition(registry, model, position, token) {
	return getLocationLinks(model, position, registry, (provider, model$1, position$1) => {
		return provider.provideImplementation(model$1, position$1, token);
	});
}
function getTypeDefinitionsAtPosition(registry, model, position, token) {
	return getLocationLinks(model, position, registry, (provider, model$1, position$1) => {
		return provider.provideTypeDefinition(model$1, position$1, token);
	});
}
function getReferencesAtPosition(registry, model, position, compact, token) {
	return getLocationLinks(model, position, registry, (provider, model$1, position$1) => __awaiter$42(this, void 0, void 0, function* () {
		const result = yield provider.provideReferences(model$1, position$1, { includeDeclaration: true }, token);
		if (!compact || !result || result.length !== 2) return result;
		const resultWithoutDeclaration = yield provider.provideReferences(model$1, position$1, { includeDeclaration: false }, token);
		if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) return resultWithoutDeclaration;
		return result;
	}));
}
function _sortedAndDeduped(callback) {
	return __awaiter$42(this, void 0, void 0, function* () {
		const model = new ReferencesModel(yield callback(), "");
		const modelLinks = model.references.map((ref) => ref.link);
		model.dispose();
		return modelLinks;
	});
}
registerModelAndPositionCommand("_executeDefinitionProvider", (accessor, model, position) => {
	const promise = getDefinitionsAtPosition(accessor.get(ILanguageFeaturesService).definitionProvider, model, position, CancellationToken.None);
	return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeTypeDefinitionProvider", (accessor, model, position) => {
	const promise = getTypeDefinitionsAtPosition(accessor.get(ILanguageFeaturesService).typeDefinitionProvider, model, position, CancellationToken.None);
	return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeDeclarationProvider", (accessor, model, position) => {
	const promise = getDeclarationsAtPosition(accessor.get(ILanguageFeaturesService).declarationProvider, model, position, CancellationToken.None);
	return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeReferenceProvider", (accessor, model, position) => {
	const promise = getReferencesAtPosition(accessor.get(ILanguageFeaturesService).referenceProvider, model, position, false, CancellationToken.None);
	return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeImplementationProvider", (accessor, model, position) => {
	const promise = getImplementationsAtPosition(accessor.get(ILanguageFeaturesService).implementationProvider, model, position, CancellationToken.None);
	return _sortedAndDeduped(() => promise);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
var __awaiter$41 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var _a$4, _b, _c, _d, _e, _f, _g, _h;
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
	submenu: MenuId.EditorContextPeek,
	title: localize("peek.submenu", "Peek"),
	group: "navigation",
	order: 100
});
var _goToActionIds = /* @__PURE__ */ new Set();
function registerGoToAction(ctor) {
	const result = new ctor();
	registerInstantiatedEditorAction(result);
	_goToActionIds.add(result.id);
	return result;
}
var SymbolNavigationAnchor = class SymbolNavigationAnchor {
	constructor(model, position) {
		this.model = model;
		this.position = position;
	}
	static is(thing) {
		if (!thing || typeof thing !== "object") return false;
		if (thing instanceof SymbolNavigationAnchor) return true;
		if (Position$1.isIPosition(thing.position) && thing.model) return true;
		return false;
	}
};
var SymbolNavigationAction = class SymbolNavigationAction extends EditorAction {
	constructor(configuration, opts) {
		super(opts);
		this.configuration = configuration;
	}
	run(accessor, editor$1, arg) {
		if (!editor$1.hasModel()) return Promise.resolve(void 0);
		const notificationService = accessor.get(INotificationService);
		const editorService = accessor.get(ICodeEditorService);
		const progressService = accessor.get(IEditorProgressService);
		const symbolNavService = accessor.get(ISymbolNavigationService);
		const languageFeaturesService = accessor.get(ILanguageFeaturesService);
		const model = editor$1.getModel();
		const position = editor$1.getPosition();
		const anchor = SymbolNavigationAnchor.is(arg) ? arg : new SymbolNavigationAnchor(model, position);
		const cts = new EditorStateCancellationTokenSource(editor$1, 5);
		const promise = raceCancellation(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then((references) => __awaiter$41(this, void 0, void 0, function* () {
			var _a$5;
			if (!references || cts.token.isCancellationRequested) return;
			alert(references.ariaMessage);
			let altAction;
			if (references.referenceAt(model.uri, position)) {
				const altActionId = this._getAlternativeCommand(editor$1);
				if (!SymbolNavigationAction._activeAlternativeCommands.has(altActionId) && _goToActionIds.has(altActionId)) altAction = editor$1.getAction(altActionId);
			}
			const referenceCount = references.references.length;
			if (referenceCount === 0) {
				if (!this.configuration.muteMessage) {
					const info = model.getWordAtPosition(position);
					(_a$5 = MessageController.get(editor$1)) === null || _a$5 === void 0 || _a$5.showMessage(this._getNoResultFoundMessage(info), position);
				}
			} else if (referenceCount === 1 && altAction) {
				SymbolNavigationAction._activeAlternativeCommands.add(this.id);
				altAction.run().finally(() => {
					SymbolNavigationAction._activeAlternativeCommands.delete(this.id);
				});
			} else return this._onResult(editorService, symbolNavService, editor$1, references);
		}), (err) => {
			notificationService.error(err);
		}).finally(() => {
			cts.dispose();
		});
		progressService.showWhile(promise, 250);
		return promise;
	}
	_onResult(editorService, symbolNavService, editor$1, model) {
		return __awaiter$41(this, void 0, void 0, function* () {
			const gotoLocation = this._getGoToPreference(editor$1);
			if (!(editor$1 instanceof EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) this._openInPeek(editor$1, model);
			else {
				const next = model.firstReference();
				const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
				const targetEditor = yield this._openReference(editor$1, editorService, next, this.configuration.openToSide, !peek);
				if (peek && targetEditor) this._openInPeek(targetEditor, model);
				else model.dispose();
				if (gotoLocation === "goto") symbolNavService.put(next);
			}
		});
	}
	_openReference(editor$1, editorService, reference, sideBySide, highlight) {
		return __awaiter$41(this, void 0, void 0, function* () {
			let range = void 0;
			if (isLocationLink(reference)) range = reference.targetSelectionRange;
			if (!range) range = reference.range;
			if (!range) return;
			const targetEditor = yield editorService.openCodeEditor({
				resource: reference.uri,
				options: {
					selection: Range$1.collapseToStart(range),
					selectionRevealType: 3,
					selectionSource: "code.jump"
				}
			}, editor$1, sideBySide);
			if (!targetEditor) return;
			if (highlight) {
				const modelNow = targetEditor.getModel();
				const decorations = targetEditor.createDecorationsCollection([{
					range,
					options: {
						description: "symbol-navigate-action-highlight",
						className: "symbolHighlight"
					}
				}]);
				setTimeout(() => {
					if (targetEditor.getModel() === modelNow) decorations.clear();
				}, 350);
			}
			return targetEditor;
		});
	}
	_openInPeek(target, model) {
		const controller = ReferencesController.get(target);
		if (controller && target.hasModel()) controller.toggleWidget(target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this.configuration.openInPeek);
		else model.dispose();
	}
};
SymbolNavigationAction._activeAlternativeCommands = /* @__PURE__ */ new Set();
var DefinitionAction = class extends SymbolNavigationAction {
	_getLocationModel(languageFeaturesService, model, position, token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(yield getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, token), localize("def.title", "Definitions"));
		});
	}
	_getNoResultFoundMessage(info) {
		return info && info.word ? localize("noResultWord", "No definition found for '{0}'", info.word) : localize("generic.noResults", "No definition found");
	}
	_getAlternativeCommand(editor$1) {
		return editor$1.getOption(53).alternativeDefinitionCommand;
	}
	_getGoToPreference(editor$1) {
		return editor$1.getOption(53).multipleDefinitions;
	}
};
var goToDefinitionKb = isWeb && !isStandalone() ? 2118 : 70;
registerGoToAction((_a$4 = class GoToDefinitionAction extends DefinitionAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: false,
			muteMessage: false
		}, {
			id: GoToDefinitionAction.id,
			label: localize("actions.goToDecl.label", "Go to Definition"),
			alias: "Go to Definition",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: goToDefinitionKb,
				weight: 100
			},
			contextMenuOpts: {
				group: "navigation",
				order: 1.1
			}
		});
		CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", GoToDefinitionAction.id);
	}
}, _a$4.id = "editor.action.revealDefinition", _a$4));
registerGoToAction((_b = class OpenDefinitionToSideAction extends DefinitionAction {
	constructor() {
		super({
			openToSide: true,
			openInPeek: false,
			muteMessage: false
		}, {
			id: OpenDefinitionToSideAction.id,
			label: localize("actions.goToDeclToSide.label", "Open Definition to the Side"),
			alias: "Open Definition to the Side",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, goToDefinitionKb),
				weight: 100
			}
		});
		CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", OpenDefinitionToSideAction.id);
	}
}, _b.id = "editor.action.revealDefinitionAside", _b));
registerGoToAction((_c = class PeekDefinitionAction extends DefinitionAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: true,
			muteMessage: false
		}, {
			id: PeekDefinitionAction.id,
			label: localize("actions.previewDecl.label", "Peek Definition"),
			alias: "Peek Definition",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 582,
				linux: { primary: 3140 },
				weight: 100
			},
			contextMenuOpts: {
				menuId: MenuId.EditorContextPeek,
				group: "peek",
				order: 2
			}
		});
		CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", PeekDefinitionAction.id);
	}
}, _c.id = "editor.action.peekDefinition", _c));
var DeclarationAction = class extends SymbolNavigationAction {
	_getLocationModel(languageFeaturesService, model, position, token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(yield getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, token), localize("decl.title", "Declarations"));
		});
	}
	_getNoResultFoundMessage(info) {
		return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
	}
	_getAlternativeCommand(editor$1) {
		return editor$1.getOption(53).alternativeDeclarationCommand;
	}
	_getGoToPreference(editor$1) {
		return editor$1.getOption(53).multipleDeclarations;
	}
};
registerGoToAction((_d = class GoToDeclarationAction extends DeclarationAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: false,
			muteMessage: false
		}, {
			id: GoToDeclarationAction.id,
			label: localize("actions.goToDeclaration.label", "Go to Declaration"),
			alias: "Go to Declaration",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			contextMenuOpts: {
				group: "navigation",
				order: 1.3
			}
		});
	}
	_getNoResultFoundMessage(info) {
		return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
	}
}, _d.id = "editor.action.revealDeclaration", _d));
registerGoToAction(class PeekDeclarationAction extends DeclarationAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: true,
			muteMessage: false
		}, {
			id: "editor.action.peekDeclaration",
			label: localize("actions.peekDecl.label", "Peek Declaration"),
			alias: "Peek Declaration",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			contextMenuOpts: {
				menuId: MenuId.EditorContextPeek,
				group: "peek",
				order: 3
			}
		});
	}
});
var TypeDefinitionAction = class extends SymbolNavigationAction {
	_getLocationModel(languageFeaturesService, model, position, token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(yield getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, token), localize("typedef.title", "Type Definitions"));
		});
	}
	_getNoResultFoundMessage(info) {
		return info && info.word ? localize("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", info.word) : localize("goToTypeDefinition.generic.noResults", "No type definition found");
	}
	_getAlternativeCommand(editor$1) {
		return editor$1.getOption(53).alternativeTypeDefinitionCommand;
	}
	_getGoToPreference(editor$1) {
		return editor$1.getOption(53).multipleTypeDefinitions;
	}
};
registerGoToAction((_e = class GoToTypeDefinitionAction extends TypeDefinitionAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: false,
			muteMessage: false
		}, {
			id: GoToTypeDefinitionAction.ID,
			label: localize("actions.goToTypeDefinition.label", "Go to Type Definition"),
			alias: "Go to Type Definition",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 0,
				weight: 100
			},
			contextMenuOpts: {
				group: "navigation",
				order: 1.4
			}
		});
	}
}, _e.ID = "editor.action.goToTypeDefinition", _e));
registerGoToAction((_f = class PeekTypeDefinitionAction extends TypeDefinitionAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: true,
			muteMessage: false
		}, {
			id: PeekTypeDefinitionAction.ID,
			label: localize("actions.peekTypeDefinition.label", "Peek Type Definition"),
			alias: "Peek Type Definition",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			contextMenuOpts: {
				menuId: MenuId.EditorContextPeek,
				group: "peek",
				order: 4
			}
		});
	}
}, _f.ID = "editor.action.peekTypeDefinition", _f));
var ImplementationAction = class extends SymbolNavigationAction {
	_getLocationModel(languageFeaturesService, model, position, token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(yield getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, token), localize("impl.title", "Implementations"));
		});
	}
	_getNoResultFoundMessage(info) {
		return info && info.word ? localize("goToImplementation.noResultWord", "No implementation found for '{0}'", info.word) : localize("goToImplementation.generic.noResults", "No implementation found");
	}
	_getAlternativeCommand(editor$1) {
		return editor$1.getOption(53).alternativeImplementationCommand;
	}
	_getGoToPreference(editor$1) {
		return editor$1.getOption(53).multipleImplementations;
	}
};
registerGoToAction((_g = class GoToImplementationAction extends ImplementationAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: false,
			muteMessage: false
		}, {
			id: GoToImplementationAction.ID,
			label: localize("actions.goToImplementation.label", "Go to Implementations"),
			alias: "Go to Implementations",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2118,
				weight: 100
			},
			contextMenuOpts: {
				group: "navigation",
				order: 1.45
			}
		});
	}
}, _g.ID = "editor.action.goToImplementation", _g));
registerGoToAction((_h = class PeekImplementationAction extends ImplementationAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: true,
			muteMessage: false
		}, {
			id: PeekImplementationAction.ID,
			label: localize("actions.peekImplementation.label", "Peek Implementations"),
			alias: "Peek Implementations",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3142,
				weight: 100
			},
			contextMenuOpts: {
				menuId: MenuId.EditorContextPeek,
				group: "peek",
				order: 5
			}
		});
	}
}, _h.ID = "editor.action.peekImplementation", _h));
var ReferencesAction = class extends SymbolNavigationAction {
	_getNoResultFoundMessage(info) {
		return info ? localize("references.no", "No references found for '{0}'", info.word) : localize("references.noGeneric", "No references found");
	}
	_getAlternativeCommand(editor$1) {
		return editor$1.getOption(53).alternativeReferenceCommand;
	}
	_getGoToPreference(editor$1) {
		return editor$1.getOption(53).multipleReferences;
	}
};
registerGoToAction(class GoToReferencesAction extends ReferencesAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: false,
			muteMessage: false
		}, {
			id: "editor.action.goToReferences",
			label: localize("goToReferences.label", "Go to References"),
			alias: "Go to References",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1094,
				weight: 100
			},
			contextMenuOpts: {
				group: "navigation",
				order: 1.45
			}
		});
	}
	_getLocationModel(languageFeaturesService, model, position, token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, true, token), localize("ref.title", "References"));
		});
	}
});
registerGoToAction(class PeekReferencesAction extends ReferencesAction {
	constructor() {
		super({
			openToSide: false,
			openInPeek: true,
			muteMessage: false
		}, {
			id: "editor.action.referenceSearch.trigger",
			label: localize("references.action.label", "Peek References"),
			alias: "Peek References",
			precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
			contextMenuOpts: {
				menuId: MenuId.EditorContextPeek,
				group: "peek",
				order: 6
			}
		});
	}
	_getLocationModel(languageFeaturesService, model, position, token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, token), localize("ref.title", "References"));
		});
	}
});
var GenericGoToLocationAction = class extends SymbolNavigationAction {
	constructor(config, _references, _gotoMultipleBehaviour) {
		super(config, {
			id: "editor.action.goToLocation",
			label: localize("label.generic", "Go to Any Symbol"),
			alias: "Go to Any Symbol",
			precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated())
		});
		this._references = _references;
		this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
	}
	_getLocationModel(languageFeaturesService, _model, _position, _token) {
		return __awaiter$41(this, void 0, void 0, function* () {
			return new ReferencesModel(this._references, localize("generic.title", "Locations"));
		});
	}
	_getNoResultFoundMessage(info) {
		return info && localize("generic.noResult", "No results for '{0}'", info.word) || "";
	}
	_getGoToPreference(editor$1) {
		var _a$5;
		return (_a$5 = this._gotoMultipleBehaviour) !== null && _a$5 !== void 0 ? _a$5 : editor$1.getOption(53).multipleReferences;
	}
	_getAlternativeCommand() {
		return "";
	}
};
CommandsRegistry.registerCommand({
	id: "editor.action.goToLocations",
	description: {
		description: "Go to locations from a position in a file",
		args: [
			{
				name: "uri",
				description: "The text document in which to start",
				constraint: URI
			},
			{
				name: "position",
				description: "The position at which to start",
				constraint: Position$1.isIPosition
			},
			{
				name: "locations",
				description: "An array of locations.",
				constraint: Array
			},
			{
				name: "multiple",
				description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto"
			},
			{
				name: "noResultsMessage",
				description: "Human readable message that shows when locations is empty."
			}
		]
	},
	handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter$41(void 0, void 0, void 0, function* () {
		assertType(URI.isUri(resource));
		assertType(Position$1.isIPosition(position));
		assertType(Array.isArray(references));
		assertType(typeof multiple === "undefined" || typeof multiple === "string");
		assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
		const editorService = accessor.get(ICodeEditorService);
		const editor$1 = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
		if (isCodeEditor(editor$1)) {
			editor$1.setPosition(position);
			editor$1.revealPositionInCenterIfOutsideViewport(position, 0);
			return editor$1.invokeWithinContext((accessor$1) => {
				const command = new class extends GenericGoToLocationAction {
					_getNoResultFoundMessage(info) {
						return noResultsMessage || super._getNoResultFoundMessage(info);
					}
				}({
					muteMessage: !Boolean(noResultsMessage),
					openInPeek: Boolean(openInPeek),
					openToSide: false
				}, references, multiple);
				accessor$1.get(IInstantiationService).invokeFunction(command.run.bind(command), editor$1);
			});
		}
	})
});
CommandsRegistry.registerCommand({
	id: "editor.action.peekLocations",
	description: {
		description: "Peek locations from a position in a file",
		args: [
			{
				name: "uri",
				description: "The text document in which to start",
				constraint: URI
			},
			{
				name: "position",
				description: "The position at which to start",
				constraint: Position$1.isIPosition
			},
			{
				name: "locations",
				description: "An array of locations.",
				constraint: Array
			},
			{
				name: "multiple",
				description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto"
			}
		]
	},
	handler: (accessor, resource, position, references, multiple) => __awaiter$41(void 0, void 0, void 0, function* () {
		accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
	})
});
CommandsRegistry.registerCommand({
	id: "editor.action.findReferences",
	handler: (accessor, resource, position) => {
		assertType(URI.isUri(resource));
		assertType(Position$1.isIPosition(position));
		const languageFeaturesService = accessor.get(ILanguageFeaturesService);
		const codeEditorService = accessor.get(ICodeEditorService);
		return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then((control) => {
			if (!isCodeEditor(control) || !control.hasModel()) return;
			const controller = ReferencesController.get(control);
			if (!controller) return;
			const references = createCancelablePromise((token) => getReferencesAtPosition(languageFeaturesService.referenceProvider, control.getModel(), Position$1.lift(position), false, token).then((references$1) => new ReferencesModel(references$1, localize("ref.title", "References"))));
			const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
			return Promise.resolve(controller.toggleWidget(range, references, false));
		});
	}
});
CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
MenuRegistry.appendMenuItems([
	{
		id: MenuId.MenubarGoMenu,
		item: {
			command: {
				id: "editor.action.revealDefinition",
				title: localize({
					key: "miGotoDefinition",
					comment: ["&& denotes a mnemonic"]
				}, "Go to &&Definition")
			},
			group: "4_symbol_nav",
			order: 2
		}
	},
	{
		id: MenuId.MenubarGoMenu,
		item: {
			command: {
				id: "editor.action.revealDeclaration",
				title: localize({
					key: "miGotoDeclaration",
					comment: ["&& denotes a mnemonic"]
				}, "Go to &&Declaration")
			},
			group: "4_symbol_nav",
			order: 3
		}
	},
	{
		id: MenuId.MenubarGoMenu,
		item: {
			command: {
				id: "editor.action.goToTypeDefinition",
				title: localize({
					key: "miGotoTypeDefinition",
					comment: ["&& denotes a mnemonic"]
				}, "Go to &&Type Definition")
			},
			group: "4_symbol_nav",
			order: 3
		}
	},
	{
		id: MenuId.MenubarGoMenu,
		item: {
			command: {
				id: "editor.action.goToImplementation",
				title: localize({
					key: "miGotoImplementation",
					comment: ["&& denotes a mnemonic"]
				}, "Go to &&Implementations")
			},
			group: "4_symbol_nav",
			order: 4
		}
	},
	{
		id: MenuId.MenubarGoMenu,
		item: {
			command: {
				id: "editor.action.goToReferences",
				title: localize({
					key: "miGotoReference",
					comment: ["&& denotes a mnemonic"]
				}, "Go to &&References")
			},
			group: "4_symbol_nav",
			order: 5
		}
	}
]);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
var __decorate$64 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$64 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var GotoDefinitionAtPositionEditorContribution = class GotoDefinitionAtPositionEditorContribution$1 {
	constructor(editor$1, textModelResolverService, languageService, languageFeaturesService) {
		this.textModelResolverService = textModelResolverService;
		this.languageService = languageService;
		this.languageFeaturesService = languageFeaturesService;
		this.toUnhook = new DisposableStore();
		this.toUnhookForKeyboard = new DisposableStore();
		this.currentWordAtPosition = null;
		this.previousPromise = null;
		this.editor = editor$1;
		this.linkDecorations = this.editor.createDecorationsCollection();
		const linkGesture = new ClickLinkGesture(editor$1);
		this.toUnhook.add(linkGesture);
		this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
			this.startFindDefinitionFromMouse(mouseEvent, withNullAsUndefined(keyboardEvent));
		}));
		this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
			if (this.isEnabled(mouseEvent)) this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).then(() => {
				this.removeLinkDecorations();
			}, (error) => {
				this.removeLinkDecorations();
				onUnexpectedError(error);
			});
		}));
		this.toUnhook.add(linkGesture.onCancel(() => {
			this.removeLinkDecorations();
			this.currentWordAtPosition = null;
		}));
	}
	static get(editor$1) {
		return editor$1.getContribution(GotoDefinitionAtPositionEditorContribution$1.ID);
	}
	startFindDefinitionFromCursor(position) {
		return this.startFindDefinition(position).then(() => {
			this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
				this.currentWordAtPosition = null;
				this.removeLinkDecorations();
				this.toUnhookForKeyboard.clear();
			}));
			this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
				if (e) {
					this.currentWordAtPosition = null;
					this.removeLinkDecorations();
					this.toUnhookForKeyboard.clear();
				}
			}));
		});
	}
	startFindDefinitionFromMouse(mouseEvent, withKey) {
		if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) return;
		if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
			this.currentWordAtPosition = null;
			this.removeLinkDecorations();
			return;
		}
		const position = mouseEvent.target.position;
		this.startFindDefinition(position);
	}
	startFindDefinition(position) {
		var _a$5;
		this.toUnhookForKeyboard.clear();
		const word = position ? (_a$5 = this.editor.getModel()) === null || _a$5 === void 0 ? void 0 : _a$5.getWordAtPosition(position) : null;
		if (!word) {
			this.currentWordAtPosition = null;
			this.removeLinkDecorations();
			return Promise.resolve(0);
		}
		if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) return Promise.resolve(0);
		this.currentWordAtPosition = word;
		const state = new EditorState(this.editor, 15);
		if (this.previousPromise) {
			this.previousPromise.cancel();
			this.previousPromise = null;
		}
		this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
		return this.previousPromise.then((results) => {
			if (!results || !results.length || !state.validate(this.editor)) {
				this.removeLinkDecorations();
				return;
			}
			if (results.length > 1) this.addDecoration(new Range$1(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
			else {
				const result = results[0];
				if (!result.uri) return;
				this.textModelResolverService.createModelReference(result.uri).then((ref) => {
					if (!ref.object || !ref.object.textEditorModel) {
						ref.dispose();
						return;
					}
					const { object: { textEditorModel } } = ref;
					const { startLineNumber } = result.range;
					if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
						ref.dispose();
						return;
					}
					const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
					let wordRange;
					if (result.originSelectionRange) wordRange = Range$1.lift(result.originSelectionRange);
					else wordRange = new Range$1(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
					const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
					this.addDecoration(wordRange, new MarkdownString().appendCodeblock(languageId ? languageId : "", previewValue));
					ref.dispose();
				});
			}
		}).then(void 0, onUnexpectedError);
	}
	getPreviewValue(textEditorModel, startLineNumber, result) {
		let rangeToUse = result.range;
		if (rangeToUse.endLineNumber - rangeToUse.startLineNumber >= GotoDefinitionAtPositionEditorContribution$1.MAX_SOURCE_PREVIEW_LINES) rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
		return this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
	}
	stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
		let minIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
		for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
			const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
			minIndent = Math.min(minIndent, endIndent);
		}
		return textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
	}
	getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
		const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
		const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution$1.MAX_SOURCE_PREVIEW_LINES);
		let endLineNumber = startLineNumber + 1;
		for (; endLineNumber < maxLineNumber; endLineNumber++) if (startIndent === textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber)) break;
		return new Range$1(startLineNumber, 1, endLineNumber + 1, 1);
	}
	addDecoration(range, hoverMessage) {
		const newDecorations = {
			range,
			options: {
				description: "goto-definition-link",
				inlineClassName: "goto-definition-link",
				hoverMessage
			}
		};
		this.linkDecorations.set([newDecorations]);
	}
	removeLinkDecorations() {
		this.linkDecorations.clear();
	}
	isEnabled(mouseEvent, withKey) {
		return this.editor.hasModel() && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
	}
	findDefinition(position, token) {
		const model = this.editor.getModel();
		if (!model) return Promise.resolve(null);
		return getDefinitionsAtPosition(this.languageFeaturesService.definitionProvider, model, position, token);
	}
	gotoDefinition(position, openToSide) {
		this.editor.setPosition(position);
		return this.editor.invokeWithinContext((accessor) => {
			return new DefinitionAction({
				openToSide,
				openInPeek: !openToSide && this.editor.getOption(80) && !this.isInPeekEditor(accessor),
				muteMessage: true
			}, {
				alias: "",
				label: "",
				id: "",
				precondition: void 0
			}).run(accessor, this.editor);
		});
	}
	isInPeekEditor(accessor) {
		const contextKeyService = accessor.get(IContextKeyService);
		return PeekContext.inPeekEditor.getValue(contextKeyService);
	}
	dispose() {
		this.toUnhook.dispose();
	}
};
GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
GotoDefinitionAtPositionEditorContribution = __decorate$64([
	__param$64(1, ITextModelService),
	__param$64(2, ILanguageService),
	__param$64(3, ILanguageFeaturesService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(GotoDefinitionAtPositionEditorContribution.ID, GotoDefinitionAtPositionEditorContribution);
registerThemingParticipant((theme, collector) => {
	const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
	if (activeLinkForeground) collector.addRule(`.monaco-editor .goto-definition-link { color: ${activeLinkForeground} !important; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
var $$6 = $;
var HoverWidget = class extends Disposable {
	constructor() {
		super();
		this.containerDomNode = document.createElement("div");
		this.containerDomNode.className = "monaco-hover";
		this.containerDomNode.tabIndex = 0;
		this.containerDomNode.setAttribute("role", "tooltip");
		this.contentsDomNode = document.createElement("div");
		this.contentsDomNode.className = "monaco-hover-content";
		this.scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, { consumeMouseWheelIfScrollbarIsNeeded: true }));
		this.containerDomNode.appendChild(this.scrollbar.getDomNode());
	}
	onContentsChanged() {
		this.scrollbar.scanDomNode();
	}
};
var HoverAction = class HoverAction extends Disposable {
	constructor(parent, actionOptions, keybindingLabel) {
		super();
		this.actionContainer = append(parent, $$6("div.action-container"));
		this.actionContainer.setAttribute("tabindex", "0");
		this.action = append(this.actionContainer, $$6("a.action"));
		this.action.setAttribute("role", "button");
		if (actionOptions.iconClass) append(this.action, $$6(`span.icon.${actionOptions.iconClass}`));
		const label = append(this.action, $$6("span"));
		label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
		this._register(addDisposableListener(this.actionContainer, EventType$1.CLICK, (e) => {
			e.stopPropagation();
			e.preventDefault();
			actionOptions.run(this.actionContainer);
		}));
		this._register(addDisposableListener(this.actionContainer, EventType$1.KEY_UP, (e) => {
			if (new StandardKeyboardEvent(e).equals(3)) {
				e.stopPropagation();
				e.preventDefault();
				actionOptions.run(this.actionContainer);
			}
		}));
		this.setEnabled(true);
	}
	static render(parent, actionOptions, keybindingLabel) {
		return new HoverAction(parent, actionOptions, keybindingLabel);
	}
	setEnabled(enabled) {
		if (enabled) {
			this.actionContainer.classList.remove("disabled");
			this.actionContainer.removeAttribute("aria-disabled");
		} else {
			this.actionContainer.classList.add("disabled");
			this.actionContainer.setAttribute("aria-disabled", "true");
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverOperation.js
var __awaiter$40 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var __asyncValues$1 = void 0 && (void 0).__asyncValues || function(o) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m = o[Symbol.asyncIterator], i;
	return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
		return this;
	}, i);
	function verb(n) {
		i[n] = o[n] && function(v) {
			return new Promise(function(resolve, reject) {
				v = o[n](v), settle(resolve, reject, v.done, v.value);
			});
		};
	}
	function settle(resolve, reject, d, v) {
		Promise.resolve(v).then(function(v$1) {
			resolve({
				value: v$1,
				done: d
			});
		}, reject);
	}
};
var HoverResult = class {
	constructor(value, isComplete, hasLoadingMessage) {
		this.value = value;
		this.isComplete = isComplete;
		this.hasLoadingMessage = hasLoadingMessage;
	}
};
/**
* Computing the hover is very fine tuned.
*
* Suppose the hover delay is 300ms (the default). Then, when resting the mouse at an anchor:
* - at 150ms, the async computation is triggered (i.e. semantic hover)
*   - if async results already come in, they are not rendered yet.
* - at 300ms, the sync computation is triggered (i.e. decorations, markers)
*   - if there are sync or async results, they are rendered.
* - at 900ms, if the async computation hasn't finished, a "Loading..." result is added.
*/
var HoverOperation = class extends Disposable {
	constructor(_editor, _computer) {
		super();
		this._editor = _editor;
		this._computer = _computer;
		this._onResult = this._register(new Emitter$1());
		this.onResult = this._onResult.event;
		this._firstWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerAsyncComputation(), 0));
		this._secondWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerSyncComputation(), 0));
		this._loadingMessageScheduler = this._register(new RunOnceScheduler(() => this._triggerLoadingMessage(), 0));
		this._state = 0;
		this._asyncIterable = null;
		this._asyncIterableDone = false;
		this._result = [];
	}
	dispose() {
		if (this._asyncIterable) {
			this._asyncIterable.cancel();
			this._asyncIterable = null;
		}
		super.dispose();
	}
	get _hoverTime() {
		return this._editor.getOption(55).delay;
	}
	get _firstWaitTime() {
		return this._hoverTime / 2;
	}
	get _secondWaitTime() {
		return this._hoverTime - this._firstWaitTime;
	}
	get _loadingMessageTime() {
		return 3 * this._hoverTime;
	}
	_setState(state, fireResult = true) {
		this._state = state;
		if (fireResult) this._fireResult();
	}
	_triggerAsyncComputation() {
		this._setState(2);
		this._secondWaitScheduler.schedule(this._secondWaitTime);
		if (this._computer.computeAsync) {
			this._asyncIterableDone = false;
			this._asyncIterable = createCancelableAsyncIterable((token) => this._computer.computeAsync(token));
			__awaiter$40(this, void 0, void 0, function* () {
				var e_1, _a$5;
				try {
					try {
						for (var _b$1 = __asyncValues$1(this._asyncIterable), _c$1; _c$1 = yield _b$1.next(), !_c$1.done;) {
							const item = _c$1.value;
							if (item) {
								this._result.push(item);
								this._fireResult();
							}
						}
					} catch (e_1_1) {
						e_1 = { error: e_1_1 };
					} finally {
						try {
							if (_c$1 && !_c$1.done && (_a$5 = _b$1.return)) yield _a$5.call(_b$1);
						} finally {
							if (e_1) throw e_1.error;
						}
					}
					this._asyncIterableDone = true;
					if (this._state === 3 || this._state === 4) this._setState(0);
				} catch (e) {
					onUnexpectedError(e);
				}
			});
		} else this._asyncIterableDone = true;
	}
	_triggerSyncComputation() {
		if (this._computer.computeSync) this._result = this._result.concat(this._computer.computeSync());
		this._setState(this._asyncIterableDone ? 0 : 3);
	}
	_triggerLoadingMessage() {
		if (this._state === 3) this._setState(4);
	}
	_fireResult() {
		if (this._state === 1 || this._state === 2) return;
		const isComplete = this._state === 0;
		const hasLoadingMessage = this._state === 4;
		this._onResult.fire(new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage));
	}
	start(mode) {
		if (mode === 0) {
			if (this._state === 0) {
				this._setState(1);
				this._firstWaitScheduler.schedule(this._firstWaitTime);
				this._loadingMessageScheduler.schedule(this._loadingMessageTime);
			}
		} else switch (this._state) {
			case 0:
				this._triggerAsyncComputation();
				this._secondWaitScheduler.cancel();
				this._triggerSyncComputation();
				break;
			case 2:
				this._secondWaitScheduler.cancel();
				this._triggerSyncComputation();
				break;
		}
	}
	cancel() {
		this._firstWaitScheduler.cancel();
		this._secondWaitScheduler.cancel();
		this._loadingMessageScheduler.cancel();
		if (this._asyncIterable) {
			this._asyncIterable.cancel();
			this._asyncIterable = null;
		}
		this._result = [];
		this._setState(0, false);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverTypes.js
var HoverRangeAnchor = class {
	constructor(priority, range) {
		this.priority = priority;
		this.range = range;
		this.type = 1;
	}
	equals(other) {
		return other.type === 1 && this.range.equalsRange(other.range);
	}
	canAdoptVisibleHover(lastAnchor, showAtPosition) {
		return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
	}
};
var HoverForeignElementAnchor = class {
	constructor(priority, owner, range) {
		this.priority = priority;
		this.owner = owner;
		this.range = range;
		this.type = 2;
	}
	equals(other) {
		return other.type === 2 && this.owner === other.owner;
	}
	canAdoptVisibleHover(lastAnchor, showAtPosition) {
		return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
	}
};
const HoverParticipantRegistry = new class HoverParticipantRegistry$1 {
	constructor() {
		this._participants = [];
	}
	register(ctor) {
		this._participants.push(ctor);
	}
	getAll() {
		return this._participants;
	}
}();

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js
var Scanner = class Scanner {
	constructor() {
		this.value = "";
		this.pos = 0;
	}
	static isDigitCharacter(ch) {
		return ch >= 48 && ch <= 57;
	}
	static isVariableCharacter(ch) {
		return ch === 95 || ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
	}
	text(value) {
		this.value = value;
		this.pos = 0;
	}
	tokenText(token) {
		return this.value.substr(token.pos, token.len);
	}
	next() {
		if (this.pos >= this.value.length) return {
			type: 14,
			pos: this.pos,
			len: 0
		};
		const pos = this.pos;
		let len = 0;
		let ch = this.value.charCodeAt(pos);
		let type;
		type = Scanner._table[ch];
		if (typeof type === "number") {
			this.pos += 1;
			return {
				type,
				pos,
				len: 1
			};
		}
		if (Scanner.isDigitCharacter(ch)) {
			type = 8;
			do {
				len += 1;
				ch = this.value.charCodeAt(pos + len);
			} while (Scanner.isDigitCharacter(ch));
			this.pos += len;
			return {
				type,
				pos,
				len
			};
		}
		if (Scanner.isVariableCharacter(ch)) {
			type = 9;
			do
				ch = this.value.charCodeAt(pos + ++len);
			while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
			this.pos += len;
			return {
				type,
				pos,
				len
			};
		}
		type = 10;
		do {
			len += 1;
			ch = this.value.charCodeAt(pos + len);
		} while (!isNaN(ch) && typeof Scanner._table[ch] === "undefined" && !Scanner.isDigitCharacter(ch) && !Scanner.isVariableCharacter(ch));
		this.pos += len;
		return {
			type,
			pos,
			len
		};
	}
};
Scanner._table = {
	[36]: 0,
	[58]: 1,
	[44]: 2,
	[123]: 3,
	[125]: 4,
	[92]: 5,
	[47]: 6,
	[124]: 7,
	[43]: 11,
	[45]: 12,
	[63]: 13
};
var Marker = class {
	constructor() {
		this._children = [];
	}
	appendChild(child) {
		if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) this._children[this._children.length - 1].value += child.value;
		else {
			child.parent = this;
			this._children.push(child);
		}
		return this;
	}
	replace(child, others) {
		const { parent } = child;
		const idx = parent.children.indexOf(child);
		const newChildren = parent.children.slice(0);
		newChildren.splice(idx, 1, ...others);
		parent._children = newChildren;
		(function _fixParent(children, parent$1) {
			for (const child$1 of children) {
				child$1.parent = parent$1;
				_fixParent(child$1.children, child$1);
			}
		})(others, parent);
	}
	get children() {
		return this._children;
	}
	get snippet() {
		let candidate = this;
		while (true) {
			if (!candidate) return;
			if (candidate instanceof TextmateSnippet) return candidate;
			candidate = candidate.parent;
		}
	}
	toString() {
		return this.children.reduce((prev, cur) => prev + cur.toString(), "");
	}
	len() {
		return 0;
	}
};
var Text = class Text extends Marker {
	constructor(value) {
		super();
		this.value = value;
	}
	toString() {
		return this.value;
	}
	len() {
		return this.value.length;
	}
	clone() {
		return new Text(this.value);
	}
};
var TransformableMarker = class extends Marker {};
var Placeholder = class Placeholder extends TransformableMarker {
	constructor(index) {
		super();
		this.index = index;
	}
	static compareByIndex(a, b) {
		if (a.index === b.index) return 0;
		else if (a.isFinalTabstop) return 1;
		else if (b.isFinalTabstop) return -1;
		else if (a.index < b.index) return -1;
		else if (a.index > b.index) return 1;
		else return 0;
	}
	get isFinalTabstop() {
		return this.index === 0;
	}
	get choice() {
		return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
	}
	clone() {
		const ret = new Placeholder(this.index);
		if (this.transform) ret.transform = this.transform.clone();
		ret._children = this.children.map((child) => child.clone());
		return ret;
	}
};
var Choice = class Choice extends Marker {
	constructor() {
		super(...arguments);
		this.options = [];
	}
	appendChild(marker) {
		if (marker instanceof Text) {
			marker.parent = this;
			this.options.push(marker);
		}
		return this;
	}
	toString() {
		return this.options[0].value;
	}
	len() {
		return this.options[0].len();
	}
	clone() {
		const ret = new Choice();
		this.options.forEach(ret.appendChild, ret);
		return ret;
	}
};
var Transform = class Transform extends Marker {
	constructor() {
		super(...arguments);
		this.regexp = /* @__PURE__ */ new RegExp("");
	}
	resolve(value) {
		const _this = this;
		let didMatch = false;
		let ret = value.replace(this.regexp, function() {
			didMatch = true;
			return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
		});
		if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) ret = this._replace([]);
		return ret;
	}
	_replace(groups) {
		let ret = "";
		for (const marker of this._children) if (marker instanceof FormatString) {
			let value = groups[marker.index] || "";
			value = marker.resolve(value);
			ret += value;
		} else ret += marker.toString();
		return ret;
	}
	toString() {
		return "";
	}
	clone() {
		const ret = new Transform();
		ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
		ret._children = this.children.map((child) => child.clone());
		return ret;
	}
};
var FormatString = class FormatString extends Marker {
	constructor(index, shorthandName, ifValue, elseValue) {
		super();
		this.index = index;
		this.shorthandName = shorthandName;
		this.ifValue = ifValue;
		this.elseValue = elseValue;
	}
	resolve(value) {
		if (this.shorthandName === "upcase") return !value ? "" : value.toLocaleUpperCase();
		else if (this.shorthandName === "downcase") return !value ? "" : value.toLocaleLowerCase();
		else if (this.shorthandName === "capitalize") return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
		else if (this.shorthandName === "pascalcase") return !value ? "" : this._toPascalCase(value);
		else if (this.shorthandName === "camelcase") return !value ? "" : this._toCamelCase(value);
		else if (Boolean(value) && typeof this.ifValue === "string") return this.ifValue;
		else if (!Boolean(value) && typeof this.elseValue === "string") return this.elseValue;
		else return value || "";
	}
	_toPascalCase(value) {
		const match = value.match(/[a-z0-9]+/gi);
		if (!match) return value;
		return match.map((word) => {
			return word.charAt(0).toUpperCase() + word.substr(1);
		}).join("");
	}
	_toCamelCase(value) {
		const match = value.match(/[a-z0-9]+/gi);
		if (!match) return value;
		return match.map((word, index) => {
			if (index === 0) return word.charAt(0).toLowerCase() + word.substr(1);
			return word.charAt(0).toUpperCase() + word.substr(1);
		}).join("");
	}
	clone() {
		return new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
	}
};
var Variable = class Variable extends TransformableMarker {
	constructor(name) {
		super();
		this.name = name;
	}
	resolve(resolver) {
		let value = resolver.resolve(this);
		if (this.transform) value = this.transform.resolve(value || "");
		if (value !== void 0) {
			this._children = [new Text(value)];
			return true;
		}
		return false;
	}
	clone() {
		const ret = new Variable(this.name);
		if (this.transform) ret.transform = this.transform.clone();
		ret._children = this.children.map((child) => child.clone());
		return ret;
	}
};
function walk(marker, visitor) {
	const stack = [...marker];
	while (stack.length > 0) {
		const marker$1 = stack.shift();
		if (!visitor(marker$1)) break;
		stack.unshift(...marker$1.children);
	}
}
var TextmateSnippet = class TextmateSnippet extends Marker {
	get placeholderInfo() {
		if (!this._placeholders) {
			const all = [];
			let last;
			this.walk(function(candidate) {
				if (candidate instanceof Placeholder) {
					all.push(candidate);
					last = !last || last.index < candidate.index ? candidate : last;
				}
				return true;
			});
			this._placeholders = {
				all,
				last
			};
		}
		return this._placeholders;
	}
	get placeholders() {
		const { all } = this.placeholderInfo;
		return all;
	}
	offset(marker) {
		let pos = 0;
		let found = false;
		this.walk((candidate) => {
			if (candidate === marker) {
				found = true;
				return false;
			}
			pos += candidate.len();
			return true;
		});
		if (!found) return -1;
		return pos;
	}
	fullLen(marker) {
		let ret = 0;
		walk([marker], (marker$1) => {
			ret += marker$1.len();
			return true;
		});
		return ret;
	}
	enclosingPlaceholders(placeholder) {
		const ret = [];
		let { parent } = placeholder;
		while (parent) {
			if (parent instanceof Placeholder) ret.push(parent);
			parent = parent.parent;
		}
		return ret;
	}
	resolveVariables(resolver) {
		this.walk((candidate) => {
			if (candidate instanceof Variable) {
				if (candidate.resolve(resolver)) this._placeholders = void 0;
			}
			return true;
		});
		return this;
	}
	appendChild(child) {
		this._placeholders = void 0;
		return super.appendChild(child);
	}
	replace(child, others) {
		this._placeholders = void 0;
		return super.replace(child, others);
	}
	clone() {
		const ret = new TextmateSnippet();
		this._children = this.children.map((child) => child.clone());
		return ret;
	}
	walk(visitor) {
		walk(this.children, visitor);
	}
};
var SnippetParser = class {
	constructor() {
		this._scanner = new Scanner();
		this._token = {
			type: 14,
			pos: 0,
			len: 0
		};
	}
	static escape(value) {
		return value.replace(/\$|}|\\/g, "\\$&");
	}
	static guessNeedsClipboard(template) {
		return /\${?CLIPBOARD/.test(template);
	}
	parse(value, insertFinalTabstop, enforceFinalTabstop) {
		const snippet = new TextmateSnippet();
		this.parseFragment(value, snippet);
		this.ensureFinalTabstop(snippet, enforceFinalTabstop !== null && enforceFinalTabstop !== void 0 ? enforceFinalTabstop : false, insertFinalTabstop !== null && insertFinalTabstop !== void 0 ? insertFinalTabstop : false);
		return snippet;
	}
	parseFragment(value, snippet) {
		const offset = snippet.children.length;
		this._scanner.text(value);
		this._token = this._scanner.next();
		while (this._parse(snippet));
		const placeholderDefaultValues = /* @__PURE__ */ new Map();
		const incompletePlaceholders = [];
		snippet.walk((marker) => {
			if (marker instanceof Placeholder) if (marker.isFinalTabstop) placeholderDefaultValues.set(0, void 0);
			else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) placeholderDefaultValues.set(marker.index, marker.children);
			else incompletePlaceholders.push(marker);
			return true;
		});
		for (const placeholder of incompletePlaceholders) {
			const defaultValues = placeholderDefaultValues.get(placeholder.index);
			if (defaultValues) {
				const clone = new Placeholder(placeholder.index);
				clone.transform = placeholder.transform;
				for (const child of defaultValues) clone.appendChild(child.clone());
				snippet.replace(placeholder, [clone]);
			}
		}
		return snippet.children.slice(offset);
	}
	ensureFinalTabstop(snippet, enforceFinalTabstop, insertFinalTabstop) {
		if (enforceFinalTabstop || insertFinalTabstop && snippet.placeholders.length > 0) {
			if (!snippet.placeholders.find((p) => p.index === 0)) snippet.appendChild(new Placeholder(0));
		}
	}
	_accept(type, value) {
		if (type === void 0 || this._token.type === type) {
			const ret = !value ? true : this._scanner.tokenText(this._token);
			this._token = this._scanner.next();
			return ret;
		}
		return false;
	}
	_backTo(token) {
		this._scanner.pos = token.pos + token.len;
		this._token = token;
		return false;
	}
	_until(type) {
		const start = this._token;
		while (this._token.type !== type) {
			if (this._token.type === 14) return false;
			else if (this._token.type === 5) {
				const nextToken = this._scanner.next();
				if (nextToken.type !== 0 && nextToken.type !== 4 && nextToken.type !== 5) return false;
			}
			this._token = this._scanner.next();
		}
		const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
		this._token = this._scanner.next();
		return value;
	}
	_parse(marker) {
		return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
	}
	_parseEscaped(marker) {
		let value;
		if (value = this._accept(5, true)) {
			value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
			marker.appendChild(new Text(value));
			return true;
		}
		return false;
	}
	_parseTabstopOrVariableName(parent) {
		let value;
		const token = this._token;
		if (!(this._accept(0) && (value = this._accept(9, true) || this._accept(8, true)))) return this._backTo(token);
		parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
		return true;
	}
	_parseComplexPlaceholder(parent) {
		let index;
		const token = this._token;
		if (!(this._accept(0) && this._accept(3) && (index = this._accept(8, true)))) return this._backTo(token);
		const placeholder = new Placeholder(Number(index));
		if (this._accept(1)) while (true) {
			if (this._accept(4)) {
				parent.appendChild(placeholder);
				return true;
			}
			if (this._parse(placeholder)) continue;
			parent.appendChild(new Text("${" + index + ":"));
			placeholder.children.forEach(parent.appendChild, parent);
			return true;
		}
		else if (placeholder.index > 0 && this._accept(7)) {
			const choice = new Choice();
			while (true) {
				if (this._parseChoiceElement(choice)) {
					if (this._accept(2)) continue;
					if (this._accept(7)) {
						placeholder.appendChild(choice);
						if (this._accept(4)) {
							parent.appendChild(placeholder);
							return true;
						}
					}
				}
				this._backTo(token);
				return false;
			}
		} else if (this._accept(6)) {
			if (this._parseTransform(placeholder)) {
				parent.appendChild(placeholder);
				return true;
			}
			this._backTo(token);
			return false;
		} else if (this._accept(4)) {
			parent.appendChild(placeholder);
			return true;
		} else return this._backTo(token);
	}
	_parseChoiceElement(parent) {
		const token = this._token;
		const values = [];
		while (true) {
			if (this._token.type === 2 || this._token.type === 7) break;
			let value;
			if (value = this._accept(5, true)) value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
			else value = this._accept(void 0, true);
			if (!value) {
				this._backTo(token);
				return false;
			}
			values.push(value);
		}
		if (values.length === 0) {
			this._backTo(token);
			return false;
		}
		parent.appendChild(new Text(values.join("")));
		return true;
	}
	_parseComplexVariable(parent) {
		let name;
		const token = this._token;
		if (!(this._accept(0) && this._accept(3) && (name = this._accept(9, true)))) return this._backTo(token);
		const variable = new Variable(name);
		if (this._accept(1)) while (true) {
			if (this._accept(4)) {
				parent.appendChild(variable);
				return true;
			}
			if (this._parse(variable)) continue;
			parent.appendChild(new Text("${" + name + ":"));
			variable.children.forEach(parent.appendChild, parent);
			return true;
		}
		else if (this._accept(6)) {
			if (this._parseTransform(variable)) {
				parent.appendChild(variable);
				return true;
			}
			this._backTo(token);
			return false;
		} else if (this._accept(4)) {
			parent.appendChild(variable);
			return true;
		} else return this._backTo(token);
	}
	_parseTransform(parent) {
		const transform = new Transform();
		let regexValue = "";
		let regexOptions = "";
		while (true) {
			if (this._accept(6)) break;
			let escaped;
			if (escaped = this._accept(5, true)) {
				escaped = this._accept(6, true) || escaped;
				regexValue += escaped;
				continue;
			}
			if (this._token.type !== 14) {
				regexValue += this._accept(void 0, true);
				continue;
			}
			return false;
		}
		while (true) {
			if (this._accept(6)) break;
			let escaped;
			if (escaped = this._accept(5, true)) {
				escaped = this._accept(5, true) || this._accept(6, true) || escaped;
				transform.appendChild(new Text(escaped));
				continue;
			}
			if (this._parseFormatString(transform) || this._parseAnything(transform)) continue;
			return false;
		}
		while (true) {
			if (this._accept(4)) break;
			if (this._token.type !== 14) {
				regexOptions += this._accept(void 0, true);
				continue;
			}
			return false;
		}
		try {
			transform.regexp = new RegExp(regexValue, regexOptions);
		} catch (e) {
			return false;
		}
		parent.transform = transform;
		return true;
	}
	_parseFormatString(parent) {
		const token = this._token;
		if (!this._accept(0)) return false;
		let complex = false;
		if (this._accept(3)) complex = true;
		const index = this._accept(8, true);
		if (!index) {
			this._backTo(token);
			return false;
		} else if (!complex) {
			parent.appendChild(new FormatString(Number(index)));
			return true;
		} else if (this._accept(4)) {
			parent.appendChild(new FormatString(Number(index)));
			return true;
		} else if (!this._accept(1)) {
			this._backTo(token);
			return false;
		}
		if (this._accept(6)) {
			const shorthand = this._accept(9, true);
			if (!shorthand || !this._accept(4)) {
				this._backTo(token);
				return false;
			} else {
				parent.appendChild(new FormatString(Number(index), shorthand));
				return true;
			}
		} else if (this._accept(11)) {
			const ifValue = this._until(4);
			if (ifValue) {
				parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
				return true;
			}
		} else if (this._accept(12)) {
			const elseValue = this._until(4);
			if (elseValue) {
				parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
				return true;
			}
		} else if (this._accept(13)) {
			const ifValue = this._until(1);
			if (ifValue) {
				const elseValue = this._until(4);
				if (elseValue) {
					parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
					return true;
				}
			}
		} else {
			const elseValue = this._until(4);
			if (elseValue) {
				parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
				return true;
			}
		}
		this._backTo(token);
		return false;
	}
	_parseAnything(marker) {
		if (this._token.type !== 14) {
			marker.appendChild(new Text(this._scanner.tokenText(this._token)));
			this._accept(void 0);
			return true;
		}
		return false;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js
var NLS_DEFAULT_LABEL = localize("defaultLabel", "input");
var NLS_PRESERVE_CASE_LABEL = localize("label.preserveCaseToggle", "Preserve Case");
var PreserveCaseToggle = class extends Toggle {
	constructor(opts) {
		super({
			icon: Codicon.preserveCase,
			title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,
			isChecked: opts.isChecked,
			inputActiveOptionBorder: opts.inputActiveOptionBorder,
			inputActiveOptionForeground: opts.inputActiveOptionForeground,
			inputActiveOptionBackground: opts.inputActiveOptionBackground
		});
	}
};
var ReplaceInput = class extends Widget {
	constructor(parent, contextViewProvider, _showOptionButtons, options) {
		super();
		this._showOptionButtons = _showOptionButtons;
		this.fixFocusOnOptionClickEnabled = true;
		this.cachedOptionsWidth = 0;
		this._onDidOptionChange = this._register(new Emitter$1());
		this.onDidOptionChange = this._onDidOptionChange.event;
		this._onKeyDown = this._register(new Emitter$1());
		this.onKeyDown = this._onKeyDown.event;
		this._onMouseDown = this._register(new Emitter$1());
		this._onInput = this._register(new Emitter$1());
		this._onKeyUp = this._register(new Emitter$1());
		this._onPreserveCaseKeyDown = this._register(new Emitter$1());
		this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
		this.contextViewProvider = contextViewProvider;
		this.placeholder = options.placeholder || "";
		this.validation = options.validation;
		this.label = options.label || NLS_DEFAULT_LABEL;
		this.inputActiveOptionBorder = options.inputActiveOptionBorder;
		this.inputActiveOptionForeground = options.inputActiveOptionForeground;
		this.inputActiveOptionBackground = options.inputActiveOptionBackground;
		this.inputBackground = options.inputBackground;
		this.inputForeground = options.inputForeground;
		this.inputBorder = options.inputBorder;
		this.inputValidationInfoBorder = options.inputValidationInfoBorder;
		this.inputValidationInfoBackground = options.inputValidationInfoBackground;
		this.inputValidationInfoForeground = options.inputValidationInfoForeground;
		this.inputValidationWarningBorder = options.inputValidationWarningBorder;
		this.inputValidationWarningBackground = options.inputValidationWarningBackground;
		this.inputValidationWarningForeground = options.inputValidationWarningForeground;
		this.inputValidationErrorBorder = options.inputValidationErrorBorder;
		this.inputValidationErrorBackground = options.inputValidationErrorBackground;
		this.inputValidationErrorForeground = options.inputValidationErrorForeground;
		const appendPreserveCaseLabel = options.appendPreserveCaseLabel || "";
		const history = options.history || [];
		const flexibleHeight = !!options.flexibleHeight;
		const flexibleWidth = !!options.flexibleWidth;
		const flexibleMaxHeight = options.flexibleMaxHeight;
		this.domNode = document.createElement("div");
		this.domNode.classList.add("monaco-findInput");
		this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
			ariaLabel: this.label || "",
			placeholder: this.placeholder || "",
			validationOptions: { validation: this.validation },
			inputBackground: this.inputBackground,
			inputForeground: this.inputForeground,
			inputBorder: this.inputBorder,
			inputValidationInfoBackground: this.inputValidationInfoBackground,
			inputValidationInfoForeground: this.inputValidationInfoForeground,
			inputValidationInfoBorder: this.inputValidationInfoBorder,
			inputValidationWarningBackground: this.inputValidationWarningBackground,
			inputValidationWarningForeground: this.inputValidationWarningForeground,
			inputValidationWarningBorder: this.inputValidationWarningBorder,
			inputValidationErrorBackground: this.inputValidationErrorBackground,
			inputValidationErrorForeground: this.inputValidationErrorForeground,
			inputValidationErrorBorder: this.inputValidationErrorBorder,
			history,
			showHistoryHint: options.showHistoryHint,
			flexibleHeight,
			flexibleWidth,
			flexibleMaxHeight
		}));
		this.preserveCase = this._register(new PreserveCaseToggle({
			appendTitle: appendPreserveCaseLabel,
			isChecked: false,
			inputActiveOptionBorder: this.inputActiveOptionBorder,
			inputActiveOptionForeground: this.inputActiveOptionForeground,
			inputActiveOptionBackground: this.inputActiveOptionBackground
		}));
		this._register(this.preserveCase.onChange((viaKeyboard) => {
			this._onDidOptionChange.fire(viaKeyboard);
			if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) this.inputBox.focus();
			this.validate();
		}));
		this._register(this.preserveCase.onKeyDown((e) => {
			this._onPreserveCaseKeyDown.fire(e);
		}));
		if (this._showOptionButtons) this.cachedOptionsWidth = this.preserveCase.width();
		else this.cachedOptionsWidth = 0;
		const indexes = [this.preserveCase.domNode];
		this.onkeydown(this.domNode, (event) => {
			if (event.equals(15) || event.equals(17) || event.equals(9)) {
				const index = indexes.indexOf(document.activeElement);
				if (index >= 0) {
					let newIndex = -1;
					if (event.equals(17)) newIndex = (index + 1) % indexes.length;
					else if (event.equals(15)) if (index === 0) newIndex = indexes.length - 1;
					else newIndex = index - 1;
					if (event.equals(9)) {
						indexes[index].blur();
						this.inputBox.focus();
					} else if (newIndex >= 0) indexes[newIndex].focus();
					EventHelper.stop(event, true);
				}
			}
		});
		const controls = document.createElement("div");
		controls.className = "controls";
		controls.style.display = this._showOptionButtons ? "block" : "none";
		controls.appendChild(this.preserveCase.domNode);
		this.domNode.appendChild(controls);
		parent === null || parent === void 0 || parent.appendChild(this.domNode);
		this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
		this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
		this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
		this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
	}
	enable() {
		this.domNode.classList.remove("disabled");
		this.inputBox.enable();
		this.preserveCase.enable();
	}
	disable() {
		this.domNode.classList.add("disabled");
		this.inputBox.disable();
		this.preserveCase.disable();
	}
	setEnabled(enabled) {
		if (enabled) this.enable();
		else this.disable();
	}
	style(styles) {
		this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
		this.inputActiveOptionForeground = styles.inputActiveOptionForeground;
		this.inputActiveOptionBackground = styles.inputActiveOptionBackground;
		this.inputBackground = styles.inputBackground;
		this.inputForeground = styles.inputForeground;
		this.inputBorder = styles.inputBorder;
		this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
		this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
		this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
		this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
		this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
		this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
		this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
		this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
		this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
		this.applyStyles();
	}
	applyStyles() {
		if (this.domNode) {
			const toggleStyles = {
				inputActiveOptionBorder: this.inputActiveOptionBorder,
				inputActiveOptionForeground: this.inputActiveOptionForeground,
				inputActiveOptionBackground: this.inputActiveOptionBackground
			};
			this.preserveCase.style(toggleStyles);
			const inputBoxStyles = {
				inputBackground: this.inputBackground,
				inputForeground: this.inputForeground,
				inputBorder: this.inputBorder,
				inputValidationInfoBackground: this.inputValidationInfoBackground,
				inputValidationInfoForeground: this.inputValidationInfoForeground,
				inputValidationInfoBorder: this.inputValidationInfoBorder,
				inputValidationWarningBackground: this.inputValidationWarningBackground,
				inputValidationWarningForeground: this.inputValidationWarningForeground,
				inputValidationWarningBorder: this.inputValidationWarningBorder,
				inputValidationErrorBackground: this.inputValidationErrorBackground,
				inputValidationErrorForeground: this.inputValidationErrorForeground,
				inputValidationErrorBorder: this.inputValidationErrorBorder
			};
			this.inputBox.style(inputBoxStyles);
		}
	}
	select() {
		this.inputBox.select();
	}
	focus() {
		this.inputBox.focus();
	}
	getPreserveCase() {
		return this.preserveCase.checked;
	}
	setPreserveCase(value) {
		this.preserveCase.checked = value;
	}
	focusOnPreserve() {
		this.preserveCase.focus();
	}
	validate() {
		if (this.inputBox) this.inputBox.validate();
	}
	set width(newWidth) {
		this.inputBox.paddingRight = this.cachedOptionsWidth;
		this.inputBox.width = newWidth;
		this.domNode.style.width = newWidth + "px";
	}
	dispose() {
		super.dispose();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/history/browser/contextScopedHistoryWidget.js
var __decorate$63 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$63 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
const historyNavigationVisible = new RawContextKey("suggestWidgetVisible", false, localize("suggestWidgetVisible", "Whether suggestion are visible"));
var HistoryNavigationWidgetFocusContext = "historyNavigationWidgetFocus";
var HistoryNavigationForwardsEnablementContext = "historyNavigationForwardsEnabled";
var HistoryNavigationBackwardsEnablementContext = "historyNavigationBackwardsEnabled";
var lastFocusedWidget = void 0;
var widgets = [];
function registerAndCreateHistoryNavigationContext(contextKeyService, widget) {
	if (widgets.includes(widget)) throw new Error("Cannot register the same widget multiple times");
	widgets.push(widget);
	const disposableStore = new DisposableStore();
	const scopedContextKeyService = disposableStore.add(contextKeyService.createScoped(widget.element));
	const historyNavigationWidgetFocus = new RawContextKey(HistoryNavigationWidgetFocusContext, false).bindTo(scopedContextKeyService);
	const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);
	const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);
	const onDidFocus = () => {
		historyNavigationWidgetFocus.set(true);
		lastFocusedWidget = widget;
	};
	const onDidBlur = () => {
		historyNavigationWidgetFocus.set(false);
		if (lastFocusedWidget === widget) lastFocusedWidget = void 0;
	};
	if (widget.element === document.activeElement) onDidFocus();
	disposableStore.add(widget.onDidFocus(() => onDidFocus()));
	disposableStore.add(widget.onDidBlur(() => onDidBlur()));
	disposableStore.add(toDisposable(() => {
		widgets.splice(widgets.indexOf(widget), 1);
		onDidBlur();
	}));
	return {
		scopedContextKeyService,
		historyNavigationForwardsEnablement,
		historyNavigationBackwardsEnablement,
		dispose() {
			disposableStore.dispose();
		}
	};
}
var ContextScopedFindInput = class ContextScopedFindInput$1 extends FindInput {
	constructor(container, contextViewProvider, options, contextKeyService, showFindOptions = false) {
		super(container, contextViewProvider, showFindOptions, options);
		this._register(registerAndCreateHistoryNavigationContext(contextKeyService, this.inputBox));
	}
};
ContextScopedFindInput = __decorate$63([__param$63(3, IContextKeyService)], ContextScopedFindInput);
var ContextScopedReplaceInput = class ContextScopedReplaceInput$1 extends ReplaceInput {
	constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
		super(container, contextViewProvider, showReplaceOptions, options);
		this._register(registerAndCreateHistoryNavigationContext(contextKeyService, this.inputBox));
	}
};
ContextScopedReplaceInput = __decorate$63([__param$63(3, IContextKeyService)], ContextScopedReplaceInput);
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "history.showPrevious",
	weight: 200,
	when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), historyNavigationVisible.isEqualTo(false)),
	primary: 16,
	secondary: [528],
	handler: (accessor) => {
		if (lastFocusedWidget) lastFocusedWidget.showPreviousValue();
	}
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
	id: "history.showNext",
	weight: 200,
	when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), historyNavigationVisible.isEqualTo(false)),
	primary: 18,
	secondary: [530],
	handler: (accessor) => {
		if (lastFocusedWidget) lastFocusedWidget.showNextValue();
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js
var __awaiter$39 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const Context$1 = {
	Visible: historyNavigationVisible,
	HasFocusedSuggestion: new RawContextKey("suggestWidgetHasFocusedSuggestion", false, localize("suggestWidgetHasSelection", "Whether any suggestion is focused")),
	DetailsVisible: new RawContextKey("suggestWidgetDetailsVisible", false, localize("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
	MultipleSuggestions: new RawContextKey("suggestWidgetMultipleSuggestions", false, localize("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
	MakesTextEdit: new RawContextKey("suggestionMakesTextEdit", true, localize("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
	AcceptSuggestionsOnEnter: new RawContextKey("acceptSuggestionOnEnter", true, localize("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
	HasInsertAndReplaceRange: new RawContextKey("suggestionHasInsertAndReplaceRange", false, localize("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
	InsertMode: new RawContextKey("suggestionInsertMode", void 0, {
		type: "string",
		description: localize("suggestionInsertMode", "Whether the default behaviour is to insert or replace")
	}),
	CanResolve: new RawContextKey("suggestionCanResolve", false, localize("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
};
const suggestWidgetStatusbarMenu = new MenuId("suggestWidgetStatusBar");
var CompletionItem = class {
	constructor(position, completion, container, provider) {
		this.position = position;
		this.completion = completion;
		this.container = container;
		this.provider = provider;
		this.isInvalid = false;
		this.score = FuzzyScore.Default;
		this.distance = 0;
		this.textLabel = typeof completion.label === "string" ? completion.label : completion.label.label;
		this.labelLow = this.textLabel.toLowerCase();
		this.isInvalid = !this.textLabel;
		this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();
		this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();
		this.extensionId = completion.extensionId;
		if (Range$1.isIRange(completion.range)) {
			this.editStart = new Position$1(completion.range.startLineNumber, completion.range.startColumn);
			this.editInsertEnd = new Position$1(completion.range.endLineNumber, completion.range.endColumn);
			this.editReplaceEnd = new Position$1(completion.range.endLineNumber, completion.range.endColumn);
			this.isInvalid = this.isInvalid || Range$1.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;
		} else {
			this.editStart = new Position$1(completion.range.insert.startLineNumber, completion.range.insert.startColumn);
			this.editInsertEnd = new Position$1(completion.range.insert.endLineNumber, completion.range.insert.endColumn);
			this.editReplaceEnd = new Position$1(completion.range.replace.endLineNumber, completion.range.replace.endColumn);
			this.isInvalid = this.isInvalid || Range$1.spansMultipleLines(completion.range.insert) || Range$1.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;
		}
		if (typeof provider.resolveCompletionItem !== "function") {
			this._resolveCache = Promise.resolve();
			this._isResolved = true;
		}
	}
	get isResolved() {
		return !!this._isResolved;
	}
	resolve(token) {
		return __awaiter$39(this, void 0, void 0, function* () {
			if (!this._resolveCache) {
				const sub = token.onCancellationRequested(() => {
					this._resolveCache = void 0;
					this._isResolved = false;
				});
				this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then((value) => {
					Object.assign(this.completion, value);
					this._isResolved = true;
					sub.dispose();
				}, (err) => {
					if (isCancellationError(err)) {
						this._resolveCache = void 0;
						this._isResolved = false;
					}
				});
			}
			return this._resolveCache;
		});
	}
};
var CompletionOptions = class {
	constructor(snippetSortOrder = 2, kindFilter = /* @__PURE__ */ new Set(), providerFilter = /* @__PURE__ */ new Set(), showDeprecated = true) {
		this.snippetSortOrder = snippetSortOrder;
		this.kindFilter = kindFilter;
		this.providerFilter = providerFilter;
		this.showDeprecated = showDeprecated;
	}
};
CompletionOptions.default = new CompletionOptions();
var _snippetSuggestSupport;
function getSnippetSuggestSupport() {
	return _snippetSuggestSupport;
}
var CompletionItemModel = class {
	constructor(items, needsClipboard, durations, disposable) {
		this.items = items;
		this.needsClipboard = needsClipboard;
		this.durations = durations;
		this.disposable = disposable;
	}
};
function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = { triggerKind: 0 }, token = CancellationToken.None) {
	return __awaiter$39(this, void 0, void 0, function* () {
		const sw = new StopWatch(true);
		position = position.clone();
		const word = model.getWordAtPosition(position);
		const defaultReplaceRange = word ? new Range$1(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range$1.fromPositions(position);
		const defaultRange = {
			replace: defaultReplaceRange,
			insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column)
		};
		const result = [];
		const disposables = new DisposableStore();
		const durations = [];
		let needsClipboard = false;
		const onCompletionList = (provider, container, sw$1) => {
			var _a$5, _b$1, _c$1;
			let didAddResult = false;
			if (!container) return didAddResult;
			for (const suggestion of container.suggestions) if (!options.kindFilter.has(suggestion.kind)) {
				if (!options.showDeprecated && ((_a$5 = suggestion === null || suggestion === void 0 ? void 0 : suggestion.tags) === null || _a$5 === void 0 ? void 0 : _a$5.includes(1))) continue;
				if (!suggestion.range) suggestion.range = defaultRange;
				if (!suggestion.sortText) suggestion.sortText = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.label;
				if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4) needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
				result.push(new CompletionItem(position, suggestion, container, provider));
				didAddResult = true;
			}
			if (isDisposable(container)) disposables.add(container);
			durations.push({
				providerName: (_b$1 = provider._debugDisplayName) !== null && _b$1 !== void 0 ? _b$1 : "unknown_provider",
				elapsedProvider: (_c$1 = container.duration) !== null && _c$1 !== void 0 ? _c$1 : -1,
				elapsedOverall: sw$1.elapsed()
			});
			return didAddResult;
		};
		const snippetCompletions = (() => __awaiter$39(this, void 0, void 0, function* () {}))();
		for (const providerGroup of registry.orderedGroups(model)) {
			let didAddResult = false;
			yield Promise.all(providerGroup.map((provider) => __awaiter$39(this, void 0, void 0, function* () {
				if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) return;
				try {
					const sw$1 = new StopWatch(true);
					didAddResult = onCompletionList(provider, yield provider.provideCompletionItems(model, position, context, token), sw$1) || didAddResult;
				} catch (err) {
					onUnexpectedExternalError(err);
				}
			})));
			if (didAddResult || token.isCancellationRequested) break;
		}
		yield snippetCompletions;
		if (token.isCancellationRequested) {
			disposables.dispose();
			return Promise.reject(new CancellationError());
		}
		return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, {
			entries: durations,
			elapsed: sw.elapsed()
		}, disposables);
	});
}
function defaultComparator(a, b) {
	if (a.sortTextLow && b.sortTextLow) {
		if (a.sortTextLow < b.sortTextLow) return -1;
		else if (a.sortTextLow > b.sortTextLow) return 1;
	}
	if (a.textLabel < b.textLabel) return -1;
	else if (a.textLabel > b.textLabel) return 1;
	return a.completion.kind - b.completion.kind;
}
function snippetUpComparator(a, b) {
	if (a.completion.kind !== b.completion.kind) {
		if (a.completion.kind === 27) return -1;
		else if (b.completion.kind === 27) return 1;
	}
	return defaultComparator(a, b);
}
function snippetDownComparator(a, b) {
	if (a.completion.kind !== b.completion.kind) {
		if (a.completion.kind === 27) return 1;
		else if (b.completion.kind === 27) return -1;
	}
	return defaultComparator(a, b);
}
var _snippetComparators = /* @__PURE__ */ new Map();
_snippetComparators.set(0, snippetUpComparator);
_snippetComparators.set(2, snippetDownComparator);
_snippetComparators.set(1, defaultComparator);
function getSuggestionComparator(snippetConfig) {
	return _snippetComparators.get(snippetConfig);
}
CommandsRegistry.registerCommand("_executeCompletionItemProvider", (accessor, ...args) => __awaiter$39(void 0, void 0, void 0, function* () {
	const [uri, position, triggerCharacter, maxItemsToResolve] = args;
	assertType(URI.isUri(uri));
	assertType(Position$1.isIPosition(position));
	assertType(typeof triggerCharacter === "string" || !triggerCharacter);
	assertType(typeof maxItemsToResolve === "number" || !maxItemsToResolve);
	const { completionProvider } = accessor.get(ILanguageFeaturesService);
	const ref = yield accessor.get(ITextModelService).createModelReference(uri);
	try {
		const result = {
			incomplete: false,
			suggestions: []
		};
		const resolving = [];
		const completions = yield provideSuggestionItems(completionProvider, ref.object.textEditorModel, Position$1.lift(position), void 0, {
			triggerCharacter,
			triggerKind: triggerCharacter ? 1 : 0
		});
		for (const item of completions.items) {
			if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) resolving.push(item.resolve(CancellationToken.None));
			result.incomplete = result.incomplete || item.container.incomplete;
			result.suggestions.push(item.completion);
		}
		try {
			yield Promise.all(resolving);
			return result;
		} finally {
			setTimeout(() => completions.disposable.dispose(), 100);
		}
	} finally {
		ref.dispose();
	}
}));
function showSimpleSuggestions(editor$1, provider) {
	var _a$5;
	(_a$5 = editor$1.getContribution("editor.contrib.suggestController")) === null || _a$5 === void 0 || _a$5.triggerSuggest((/* @__PURE__ */ new Set()).add(provider), void 0, true);
}
var QuickSuggestionsOptions = class {
	static isAllOff(config) {
		return config.other === "off" && config.comments === "off" && config.strings === "off";
	}
	static isAllOn(config) {
		return config.other === "on" && config.comments === "on" && config.strings === "on";
	}
	static valueFor(config, tokenType) {
		switch (tokenType) {
			case 1: return config.comments;
			case 2: return config.strings;
			default: return config.other;
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
var __decorate$62 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$62 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var $$5 = $;
var ContentHoverController = class ContentHoverController$1 extends Disposable {
	constructor(_editor, _instantiationService, _keybindingService) {
		super();
		this._editor = _editor;
		this._instantiationService = _instantiationService;
		this._keybindingService = _keybindingService;
		this._widget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor));
		this._isChangingDecorations = false;
		this._messages = [];
		this._messagesAreComplete = false;
		this._participants = [];
		for (const participant of HoverParticipantRegistry.getAll()) this._participants.push(this._instantiationService.createInstance(participant, this._editor));
		this._participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);
		this._computer = new ContentHoverComputer(this._editor, this._participants);
		this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
		this._register(this._hoverOperation.onResult((result) => {
			this._withResult(result.value, result.isComplete, result.hasLoadingMessage);
		}));
		this._register(this._editor.onDidChangeModelDecorations(() => {
			if (this._isChangingDecorations) return;
			this._onModelDecorationsChanged();
		}));
		this._register(addStandardDisposableListener(this._widget.getDomNode(), "keydown", (e) => {
			if (e.equals(9)) this.hide();
		}));
		this._register(TokenizationRegistry.onDidChange(() => {
			if (this._widget.position && this._computer.anchor && this._messages.length > 0) {
				this._widget.clear();
				this._renderMessages(this._computer.anchor, this._messages);
			}
		}));
	}
	_onModelDecorationsChanged() {
		if (this._widget.position) {
			this._hoverOperation.cancel();
			if (!this._widget.isColorPickerVisible) this._hoverOperation.start(0);
		}
	}
	maybeShowAt(mouseEvent) {
		const anchorCandidates = [];
		for (const participant of this._participants) if (participant.suggestHoverAnchor) {
			const anchor = participant.suggestHoverAnchor(mouseEvent);
			if (anchor) anchorCandidates.push(anchor);
		}
		const target = mouseEvent.target;
		if (target.type === 6) anchorCandidates.push(new HoverRangeAnchor(0, target.range));
		if (target.type === 7) {
			const epsilon = this._editor.getOption(46).typicalHalfwidthCharacterWidth / 2;
			if (!target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === "number" && target.detail.horizontalDistanceToText < epsilon) anchorCandidates.push(new HoverRangeAnchor(0, target.range));
		}
		if (anchorCandidates.length === 0) return false;
		anchorCandidates.sort((a, b) => b.priority - a.priority);
		this._startShowingAt(anchorCandidates[0], 0, false);
		return true;
	}
	startShowingAtRange(range, mode, focus) {
		this._startShowingAt(new HoverRangeAnchor(0, range), mode, focus);
	}
	_startShowingAt(anchor, mode, focus) {
		if (this._computer.anchor && this._computer.anchor.equals(anchor)) return;
		this._hoverOperation.cancel();
		if (this._widget.position) if (!this._computer.anchor || !anchor.canAdoptVisibleHover(this._computer.anchor, this._widget.position)) this.hide();
		else {
			const filteredMessages = this._messages.filter((m) => m.isValidForHoverAnchor(anchor));
			if (filteredMessages.length === 0) this.hide();
			else if (filteredMessages.length === this._messages.length && this._messagesAreComplete) return;
			else this._renderMessages(anchor, filteredMessages);
		}
		this._computer.anchor = anchor;
		this._computer.shouldFocus = focus;
		this._hoverOperation.start(mode);
	}
	hide() {
		this._computer.anchor = null;
		this._hoverOperation.cancel();
		this._widget.hide();
	}
	isColorPickerVisible() {
		return this._widget.isColorPickerVisible;
	}
	containsNode(node) {
		return this._widget.getDomNode().contains(node);
	}
	_addLoadingMessage(result) {
		if (this._computer.anchor) {
			for (const participant of this._participants) if (participant.createLoadingMessage) {
				const loadingMessage = participant.createLoadingMessage(this._computer.anchor);
				if (loadingMessage) return result.slice(0).concat([loadingMessage]);
			}
		}
		return result;
	}
	_withResult(result, isComplete, hasLoadingMessage) {
		this._messages = hasLoadingMessage ? this._addLoadingMessage(result) : result;
		this._messagesAreComplete = isComplete;
		if (this._computer.anchor && this._messages.length > 0) this._renderMessages(this._computer.anchor, this._messages);
		else if (isComplete) this.hide();
	}
	_renderMessages(anchor, messages) {
		const { showAtPosition, showAtRange, highlightRange } = ContentHoverController$1.computeHoverRanges(anchor.range, messages);
		const disposables = new DisposableStore();
		const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));
		const fragment = document.createDocumentFragment();
		let colorPicker = null;
		const context = {
			fragment,
			statusBar,
			setColorPicker: (widget) => colorPicker = widget,
			onContentsChanged: () => this._widget.onContentsChanged(),
			hide: () => this.hide()
		};
		for (const participant of this._participants) {
			const hoverParts = messages.filter((msg) => msg.owner === participant);
			if (hoverParts.length > 0) disposables.add(participant.renderHoverParts(context, hoverParts));
		}
		if (statusBar.hasContent) fragment.appendChild(statusBar.hoverElement);
		if (fragment.hasChildNodes()) {
			if (highlightRange) {
				const highlightDecoration = this._editor.createDecorationsCollection();
				try {
					this._isChangingDecorations = true;
					highlightDecoration.set([{
						range: highlightRange,
						options: ContentHoverController$1._DECORATION_OPTIONS
					}]);
				} finally {
					this._isChangingDecorations = false;
				}
				disposables.add(toDisposable(() => {
					try {
						this._isChangingDecorations = true;
						highlightDecoration.clear();
					} finally {
						this._isChangingDecorations = false;
					}
				}));
			}
			this._widget.showAt(fragment, new ContentHoverVisibleData(colorPicker, showAtPosition, showAtRange, this._editor.getOption(55).above, this._computer.shouldFocus, disposables));
		} else disposables.dispose();
	}
	static computeHoverRanges(anchorRange, messages) {
		const anchorLineNumber = anchorRange.startLineNumber;
		let renderStartColumn = anchorRange.startColumn;
		let renderEndColumn = anchorRange.endColumn;
		let highlightRange = messages[0].range;
		let forceShowAtRange = null;
		for (const msg of messages) {
			highlightRange = Range$1.plusRange(highlightRange, msg.range);
			if (msg.range.startLineNumber === anchorLineNumber && msg.range.endLineNumber === anchorLineNumber) {
				renderStartColumn = Math.min(renderStartColumn, msg.range.startColumn);
				renderEndColumn = Math.max(renderEndColumn, msg.range.endColumn);
			}
			if (msg.forceShowAtRange) forceShowAtRange = msg.range;
		}
		return {
			showAtPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position$1(anchorRange.startLineNumber, renderStartColumn),
			showAtRange: forceShowAtRange ? forceShowAtRange : new Range$1(anchorLineNumber, renderStartColumn, anchorLineNumber, renderEndColumn),
			highlightRange
		};
	}
};
ContentHoverController._DECORATION_OPTIONS = ModelDecorationOptions.register({
	description: "content-hover-highlight",
	className: "hoverHighlight"
});
ContentHoverController = __decorate$62([__param$62(1, IInstantiationService), __param$62(2, IKeybindingService)], ContentHoverController);
var ContentHoverVisibleData = class {
	constructor(colorPicker, showAtPosition, showAtRange, preferAbove, stoleFocus, disposables) {
		this.colorPicker = colorPicker;
		this.showAtPosition = showAtPosition;
		this.showAtRange = showAtRange;
		this.preferAbove = preferAbove;
		this.stoleFocus = stoleFocus;
		this.disposables = disposables;
	}
};
var ContentHoverWidget = class ContentHoverWidget$1 extends Disposable {
	constructor(_editor, _contextKeyService) {
		super();
		this._editor = _editor;
		this._contextKeyService = _contextKeyService;
		this.allowEditorOverflow = true;
		this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(this._contextKeyService);
		this._hover = this._register(new HoverWidget());
		this._visibleData = null;
		this._register(this._editor.onDidLayoutChange(() => this._layout()));
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(46)) this._updateFont();
		}));
		this._setVisibleData(null);
		this._layout();
		this._editor.addContentWidget(this);
	}
	/**
	* Returns `null` if the hover is not visible.
	*/
	get position() {
		var _a$5, _b$1;
		return (_b$1 = (_a$5 = this._visibleData) === null || _a$5 === void 0 ? void 0 : _a$5.showAtPosition) !== null && _b$1 !== void 0 ? _b$1 : null;
	}
	get isColorPickerVisible() {
		var _a$5;
		return Boolean((_a$5 = this._visibleData) === null || _a$5 === void 0 ? void 0 : _a$5.colorPicker);
	}
	dispose() {
		this._editor.removeContentWidget(this);
		if (this._visibleData) this._visibleData.disposables.dispose();
		super.dispose();
	}
	getId() {
		return ContentHoverWidget$1.ID;
	}
	getDomNode() {
		return this._hover.containerDomNode;
	}
	getPosition() {
		if (!this._visibleData) return null;
		let preferAbove = this._visibleData.preferAbove;
		if (!preferAbove && this._contextKeyService.getContextKeyValue(Context$1.Visible.key)) preferAbove = true;
		return {
			position: this._visibleData.showAtPosition,
			range: this._visibleData.showAtRange,
			preference: preferAbove ? [1, 2] : [2, 1]
		};
	}
	_setVisibleData(visibleData) {
		if (this._visibleData) this._visibleData.disposables.dispose();
		this._visibleData = visibleData;
		this._hoverVisibleKey.set(!!this._visibleData);
		this._hover.containerDomNode.classList.toggle("hidden", !this._visibleData);
	}
	_layout() {
		const height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
		const { fontSize, lineHeight } = this._editor.getOption(46);
		this._hover.contentsDomNode.style.fontSize = `${fontSize}px`;
		this._hover.contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;
		this._hover.contentsDomNode.style.maxHeight = `${height}px`;
		this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * .66, 500)}px`;
	}
	_updateFont() {
		Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((node) => this._editor.applyFontInfo(node));
	}
	showAt(node, visibleData) {
		this._setVisibleData(visibleData);
		this._hover.contentsDomNode.textContent = "";
		this._hover.contentsDomNode.appendChild(node);
		this._hover.contentsDomNode.style.paddingBottom = "";
		this._updateFont();
		this.onContentsChanged();
		this._editor.render();
		this.onContentsChanged();
		if (visibleData.stoleFocus) this._hover.containerDomNode.focus();
		if (visibleData.colorPicker) visibleData.colorPicker.layout();
	}
	hide() {
		if (this._visibleData) {
			const stoleFocus = this._visibleData.stoleFocus;
			this._setVisibleData(null);
			this._editor.layoutContentWidget(this);
			if (stoleFocus) this._editor.focus();
		}
	}
	onContentsChanged() {
		this._editor.layoutContentWidget(this);
		this._hover.onContentsChanged();
		const scrollDimensions = this._hover.scrollbar.getScrollDimensions();
		if (scrollDimensions.scrollWidth > scrollDimensions.width) {
			const extraBottomPadding = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;
			if (this._hover.contentsDomNode.style.paddingBottom !== extraBottomPadding) {
				this._hover.contentsDomNode.style.paddingBottom = extraBottomPadding;
				this._editor.layoutContentWidget(this);
				this._hover.onContentsChanged();
			}
		}
	}
	clear() {
		this._hover.contentsDomNode.textContent = "";
	}
};
ContentHoverWidget.ID = "editor.contrib.contentHoverWidget";
ContentHoverWidget = __decorate$62([__param$62(1, IContextKeyService)], ContentHoverWidget);
var EditorHoverStatusBar = class EditorHoverStatusBar$1 extends Disposable {
	constructor(_keybindingService) {
		super();
		this._keybindingService = _keybindingService;
		this._hasContent = false;
		this.hoverElement = $$5("div.hover-row.status-bar");
		this.actionsElement = append(this.hoverElement, $$5("div.actions"));
	}
	get hasContent() {
		return this._hasContent;
	}
	addAction(actionOptions) {
		const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
		const keybindingLabel = keybinding ? keybinding.getLabel() : null;
		this._hasContent = true;
		return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
	}
	append(element) {
		const result = append(this.actionsElement, element);
		this._hasContent = true;
		return result;
	}
};
EditorHoverStatusBar = __decorate$62([__param$62(0, IKeybindingService)], EditorHoverStatusBar);
var ContentHoverComputer = class ContentHoverComputer {
	constructor(_editor, _participants) {
		this._editor = _editor;
		this._participants = _participants;
		this._anchor = null;
		this._shouldFocus = false;
	}
	get anchor() {
		return this._anchor;
	}
	set anchor(value) {
		this._anchor = value;
	}
	get shouldFocus() {
		return this._shouldFocus;
	}
	set shouldFocus(value) {
		this._shouldFocus = value;
	}
	static _getLineDecorations(editor$1, anchor) {
		if (anchor.type !== 1) return [];
		const model = editor$1.getModel();
		const lineNumber = anchor.range.startLineNumber;
		if (lineNumber > model.getLineCount()) return [];
		const maxColumn = model.getLineMaxColumn(lineNumber);
		return editor$1.getLineDecorations(lineNumber).filter((d) => {
			if (d.options.isWholeLine) return true;
			const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
			const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
			if (d.options.showIfCollapsed) {
				if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) return false;
			} else if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) return false;
			return true;
		});
	}
	computeAsync(token) {
		const anchor = this._anchor;
		if (!this._editor.hasModel() || !anchor) return AsyncIterableObject.EMPTY;
		const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, anchor);
		return AsyncIterableObject.merge(this._participants.map((participant) => {
			if (!participant.computeAsync) return AsyncIterableObject.EMPTY;
			return participant.computeAsync(anchor, lineDecorations, token);
		}));
	}
	computeSync() {
		if (!this._editor.hasModel() || !this._anchor) return [];
		const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, this._anchor);
		let result = [];
		for (const participant of this._participants) result = result.concat(participant.computeSync(this._anchor, lineDecorations));
		return coalesce(result);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/marked/marked.js
/**
* marked - a markdown parser
* Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)
* https://github.com/markedjs/marked
*/
/**
* DO NOT EDIT THIS FILE
* The code in this file is generated from files in ./src/
*/
var __marked_exports = {};
(function() {
	function define(deps, factory) {
		factory(__marked_exports);
	}
	define.amd = true;
	(function(global, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.marked = {}));
	})(this, (function(exports$1) {
		"use strict";
		function _defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];
				descriptor.enumerable = descriptor.enumerable || false;
				descriptor.configurable = true;
				if ("value" in descriptor) descriptor.writable = true;
				Object.defineProperty(target, descriptor.key, descriptor);
			}
		}
		function _createClass(Constructor, protoProps, staticProps) {
			if (protoProps) _defineProperties(Constructor.prototype, protoProps);
			if (staticProps) _defineProperties(Constructor, staticProps);
			Object.defineProperty(Constructor, "prototype", { writable: false });
			return Constructor;
		}
		function _unsupportedIterableToArray(o, minLen) {
			if (!o) return;
			if (typeof o === "string") return _arrayLikeToArray(o, minLen);
			var n = Object.prototype.toString.call(o).slice(8, -1);
			if (n === "Object" && o.constructor) n = o.constructor.name;
			if (n === "Map" || n === "Set") return Array.from(o);
			if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
		}
		function _arrayLikeToArray(arr, len) {
			if (len == null || len > arr.length) len = arr.length;
			for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
			return arr2;
		}
		function _createForOfIteratorHelperLoose(o, allowArrayLike) {
			var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
			if (it) return (it = it.call(o)).next.bind(it);
			if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
				if (it) o = it;
				var i = 0;
				return function() {
					if (i >= o.length) return { done: true };
					return {
						done: false,
						value: o[i++]
					};
				};
			}
			throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		function getDefaults() {
			return {
				baseUrl: null,
				breaks: false,
				extensions: null,
				gfm: true,
				headerIds: true,
				headerPrefix: "",
				highlight: null,
				langPrefix: "language-",
				mangle: true,
				pedantic: false,
				renderer: null,
				sanitize: false,
				sanitizer: null,
				silent: false,
				smartLists: false,
				smartypants: false,
				tokenizer: null,
				walkTokens: null,
				xhtml: false
			};
		}
		exports$1.defaults = getDefaults();
		function changeDefaults(newDefaults) {
			exports$1.defaults = newDefaults;
		}
		/**
		* Helpers
		*/
		var escapeTest = /[&<>"']/;
		var escapeReplace = /[&<>"']/g;
		var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
		var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
		var escapeReplacements = {
			"&": "&amp;",
			"<": "&lt;",
			">": "&gt;",
			"\"": "&quot;",
			"'": "&#39;"
		};
		var getEscapeReplacement = function getEscapeReplacement$1(ch) {
			return escapeReplacements[ch];
		};
		function escape$1(html, encode) {
			if (encode) {
				if (escapeTest.test(html)) return html.replace(escapeReplace, getEscapeReplacement);
			} else if (escapeTestNoEncode.test(html)) return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
			return html;
		}
		var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
		/**
		* @param {string} html
		*/
		function unescape(html) {
			return html.replace(unescapeTest, function(_, n) {
				n = n.toLowerCase();
				if (n === "colon") return ":";
				if (n.charAt(0) === "#") return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
				return "";
			});
		}
		var caret = /(^|[^\[])\^/g;
		/**
		* @param {string | RegExp} regex
		* @param {string} opt
		*/
		function edit(regex, opt) {
			regex = typeof regex === "string" ? regex : regex.source;
			opt = opt || "";
			var obj = {
				replace: function replace(name, val) {
					val = val.source || val;
					val = val.replace(caret, "$1");
					regex = regex.replace(name, val);
					return obj;
				},
				getRegex: function getRegex() {
					return new RegExp(regex, opt);
				}
			};
			return obj;
		}
		var nonWordAndColonTest = /[^\w:]/g;
		var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
		/**
		* @param {boolean} sanitize
		* @param {string} base
		* @param {string} href
		*/
		function cleanUrl(sanitize$1, base, href) {
			if (sanitize$1) {
				var prot;
				try {
					prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
				} catch (e) {
					return null;
				}
				if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) return null;
			}
			if (base && !originIndependentUrl.test(href)) href = resolveUrl(base, href);
			try {
				href = encodeURI(href).replace(/%25/g, "%");
			} catch (e) {
				return null;
			}
			return href;
		}
		var baseUrls = {};
		var justDomain = /^[^:]+:\/*[^/]*$/;
		var protocol = /^([^:]+:)[\s\S]*$/;
		var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
		/**
		* @param {string} base
		* @param {string} href
		*/
		function resolveUrl(base, href) {
			if (!baseUrls[" " + base]) if (justDomain.test(base)) baseUrls[" " + base] = base + "/";
			else baseUrls[" " + base] = rtrim(base, "/", true);
			base = baseUrls[" " + base];
			var relativeBase = base.indexOf(":") === -1;
			if (href.substring(0, 2) === "//") {
				if (relativeBase) return href;
				return base.replace(protocol, "$1") + href;
			} else if (href.charAt(0) === "/") {
				if (relativeBase) return href;
				return base.replace(domain, "$1") + href;
			} else return base + href;
		}
		var noopTest = { exec: function noopTest$1() {} };
		function merge(obj) {
			var i = 1, target, key;
			for (; i < arguments.length; i++) {
				target = arguments[i];
				for (key in target) if (Object.prototype.hasOwnProperty.call(target, key)) obj[key] = target[key];
			}
			return obj;
		}
		function splitCells(tableRow, count) {
			var cells = tableRow.replace(/\|/g, function(match, offset, str) {
				var escaped = false, curr = offset;
				while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
				if (escaped) return "|";
				else return " |";
			}).split(/ \|/);
			var i = 0;
			if (!cells[0].trim()) cells.shift();
			if (cells.length > 0 && !cells[cells.length - 1].trim()) cells.pop();
			if (cells.length > count) cells.splice(count);
			else while (cells.length < count) cells.push("");
			for (; i < cells.length; i++) cells[i] = cells[i].trim().replace(/\\\|/g, "|");
			return cells;
		}
		/**
		* Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
		* /c*$/ is vulnerable to REDOS.
		*
		* @param {string} str
		* @param {string} c
		* @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
		*/
		function rtrim(str, c, invert) {
			var l = str.length;
			if (l === 0) return "";
			var suffLen = 0;
			while (suffLen < l) {
				var currChar = str.charAt(l - suffLen - 1);
				if (currChar === c && !invert) suffLen++;
				else if (currChar !== c && invert) suffLen++;
				else break;
			}
			return str.slice(0, l - suffLen);
		}
		function findClosingBracket(str, b) {
			if (str.indexOf(b[1]) === -1) return -1;
			var l = str.length;
			var level = 0, i = 0;
			for (; i < l; i++) if (str[i] === "\\") i++;
			else if (str[i] === b[0]) level++;
			else if (str[i] === b[1]) {
				level--;
				if (level < 0) return i;
			}
			return -1;
		}
		function checkSanitizeDeprecation(opt) {
			if (opt && opt.sanitize && !opt.silent) console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
		}
		/**
		* @param {string} pattern
		* @param {number} count
		*/
		function repeatString(pattern, count) {
			if (count < 1) return "";
			var result = "";
			while (count > 1) {
				if (count & 1) result += pattern;
				count >>= 1;
				pattern += pattern;
			}
			return result + pattern;
		}
		function outputLink(cap, link, raw, lexer$1) {
			var href = link.href;
			var title = link.title ? escape$1(link.title) : null;
			var text = cap[1].replace(/\\([\[\]])/g, "$1");
			if (cap[0].charAt(0) !== "!") {
				lexer$1.state.inLink = true;
				var token = {
					type: "link",
					raw,
					href,
					title,
					text,
					tokens: lexer$1.inlineTokens(text, [])
				};
				lexer$1.state.inLink = false;
				return token;
			}
			return {
				type: "image",
				raw,
				href,
				title,
				text: escape$1(text)
			};
		}
		function indentCodeCompensation(raw, text) {
			var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
			if (matchIndentToCode === null) return text;
			var indentToCode = matchIndentToCode[1];
			return text.split("\n").map(function(node) {
				var matchIndentInNode = node.match(/^\s+/);
				if (matchIndentInNode === null) return node;
				if (matchIndentInNode[0].length >= indentToCode.length) return node.slice(indentToCode.length);
				return node;
			}).join("\n");
		}
		/**
		* Tokenizer
		*/
		var Tokenizer = /* @__PURE__ */ function() {
			function Tokenizer$1(options$1) {
				this.options = options$1 || exports$1.defaults;
			}
			var _proto = Tokenizer$1.prototype;
			_proto.space = function space(src) {
				var cap = this.rules.block.newline.exec(src);
				if (cap && cap[0].length > 0) return {
					type: "space",
					raw: cap[0]
				};
			};
			_proto.code = function code(src) {
				var cap = this.rules.block.code.exec(src);
				if (cap) {
					var text = cap[0].replace(/^ {1,4}/gm, "");
					return {
						type: "code",
						raw: cap[0],
						codeBlockStyle: "indented",
						text: !this.options.pedantic ? rtrim(text, "\n") : text
					};
				}
			};
			_proto.fences = function fences(src) {
				var cap = this.rules.block.fences.exec(src);
				if (cap) {
					var raw = cap[0];
					var text = indentCodeCompensation(raw, cap[3] || "");
					return {
						type: "code",
						raw,
						lang: cap[2] ? cap[2].trim() : cap[2],
						text
					};
				}
			};
			_proto.heading = function heading(src) {
				var cap = this.rules.block.heading.exec(src);
				if (cap) {
					var text = cap[2].trim();
					if (/#$/.test(text)) {
						var trimmed = rtrim(text, "#");
						if (this.options.pedantic) text = trimmed.trim();
						else if (!trimmed || / $/.test(trimmed)) text = trimmed.trim();
					}
					var token = {
						type: "heading",
						raw: cap[0],
						depth: cap[1].length,
						text,
						tokens: []
					};
					this.lexer.inline(token.text, token.tokens);
					return token;
				}
			};
			_proto.hr = function hr(src) {
				var cap = this.rules.block.hr.exec(src);
				if (cap) return {
					type: "hr",
					raw: cap[0]
				};
			};
			_proto.blockquote = function blockquote(src) {
				var cap = this.rules.block.blockquote.exec(src);
				if (cap) {
					var text = cap[0].replace(/^ *>[ \t]?/gm, "");
					return {
						type: "blockquote",
						raw: cap[0],
						tokens: this.lexer.blockTokens(text, []),
						text
					};
				}
			};
			_proto.list = function list(src) {
				var cap = this.rules.block.list.exec(src);
				if (cap) {
					var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
					var bull = cap[1].trim();
					var isordered = bull.length > 1;
					var list$1 = {
						type: "list",
						raw: "",
						ordered: isordered,
						start: isordered ? +bull.slice(0, -1) : "",
						loose: false,
						items: []
					};
					bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
					if (this.options.pedantic) bull = isordered ? bull : "[*+-]";
					var itemRegex = /* @__PURE__ */ new RegExp("^( {0,3}" + bull + ")((?:[	 ][^\\n]*)?(?:\\n|$))");
					while (src) {
						endEarly = false;
						if (!(cap = itemRegex.exec(src))) break;
						if (this.rules.block.hr.test(src)) break;
						raw = cap[0];
						src = src.substring(raw.length);
						line = cap[2].split("\n", 1)[0];
						nextLine = src.split("\n", 1)[0];
						if (this.options.pedantic) {
							indent = 2;
							itemContents = line.trimLeft();
						} else {
							indent = cap[2].search(/[^ ]/);
							indent = indent > 4 ? 1 : indent;
							itemContents = line.slice(indent);
							indent += cap[1].length;
						}
						blankLine = false;
						if (!line && /^ *$/.test(nextLine)) {
							raw += nextLine + "\n";
							src = src.substring(nextLine.length + 1);
							endEarly = true;
						}
						if (!endEarly) {
							var nextBulletRegex = /* @__PURE__ */ new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))");
							var hrRegex = /* @__PURE__ */ new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
							while (src) {
								rawLine = src.split("\n", 1)[0];
								line = rawLine;
								if (this.options.pedantic) line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
								if (nextBulletRegex.test(line)) break;
								if (hrRegex.test(src)) break;
								if (line.search(/[^ ]/) >= indent || !line.trim()) itemContents += "\n" + line.slice(indent);
								else if (!blankLine) itemContents += "\n" + line;
								else break;
								if (!blankLine && !line.trim()) blankLine = true;
								raw += rawLine + "\n";
								src = src.substring(rawLine.length + 1);
							}
						}
						if (!list$1.loose) {
							if (endsWithBlankLine) list$1.loose = true;
							else if (/\n *\n *$/.test(raw)) endsWithBlankLine = true;
						}
						if (this.options.gfm) {
							istask = /^\[[ xX]\] /.exec(itemContents);
							if (istask) {
								ischecked = istask[0] !== "[ ] ";
								itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
							}
						}
						list$1.items.push({
							type: "list_item",
							raw,
							task: !!istask,
							checked: ischecked,
							loose: false,
							text: itemContents
						});
						list$1.raw += raw;
					}
					list$1.items[list$1.items.length - 1].raw = raw.trimRight();
					list$1.items[list$1.items.length - 1].text = itemContents.trimRight();
					list$1.raw = list$1.raw.trimRight();
					var l = list$1.items.length;
					for (i = 0; i < l; i++) {
						this.lexer.state.top = false;
						list$1.items[i].tokens = this.lexer.blockTokens(list$1.items[i].text, []);
						var spacers = list$1.items[i].tokens.filter(function(t) {
							return t.type === "space";
						});
						var hasMultipleLineBreaks = spacers.every(function(t) {
							var chars = t.raw.split("");
							var lineBreaks = 0;
							for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done;) {
								if (_step.value === "\n") lineBreaks += 1;
								if (lineBreaks > 1) return true;
							}
							return false;
						});
						if (!list$1.loose && spacers.length && hasMultipleLineBreaks) {
							list$1.loose = true;
							list$1.items[i].loose = true;
						}
					}
					return list$1;
				}
			};
			_proto.html = function html(src) {
				var cap = this.rules.block.html.exec(src);
				if (cap) {
					var token = {
						type: "html",
						raw: cap[0],
						pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
						text: cap[0]
					};
					if (this.options.sanitize) {
						token.type = "paragraph";
						token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0]);
						token.tokens = [];
						this.lexer.inline(token.text, token.tokens);
					}
					return token;
				}
			};
			_proto.def = function def(src) {
				var cap = this.rules.block.def.exec(src);
				if (cap) {
					if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
					return {
						type: "def",
						tag: cap[1].toLowerCase().replace(/\s+/g, " "),
						raw: cap[0],
						href: cap[2],
						title: cap[3]
					};
				}
			};
			_proto.table = function table(src) {
				var cap = this.rules.block.table.exec(src);
				if (cap) {
					var item = {
						type: "table",
						header: splitCells(cap[1]).map(function(c) {
							return { text: c };
						}),
						align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
						rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
					};
					if (item.header.length === item.align.length) {
						item.raw = cap[0];
						var l = item.align.length;
						var i, j, k, row;
						for (i = 0; i < l; i++) if (/^ *-+: *$/.test(item.align[i])) item.align[i] = "right";
						else if (/^ *:-+: *$/.test(item.align[i])) item.align[i] = "center";
						else if (/^ *:-+ *$/.test(item.align[i])) item.align[i] = "left";
						else item.align[i] = null;
						l = item.rows.length;
						for (i = 0; i < l; i++) item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c) {
							return { text: c };
						});
						l = item.header.length;
						for (j = 0; j < l; j++) {
							item.header[j].tokens = [];
							this.lexer.inline(item.header[j].text, item.header[j].tokens);
						}
						l = item.rows.length;
						for (j = 0; j < l; j++) {
							row = item.rows[j];
							for (k = 0; k < row.length; k++) {
								row[k].tokens = [];
								this.lexer.inline(row[k].text, row[k].tokens);
							}
						}
						return item;
					}
				}
			};
			_proto.lheading = function lheading(src) {
				var cap = this.rules.block.lheading.exec(src);
				if (cap) {
					var token = {
						type: "heading",
						raw: cap[0],
						depth: cap[2].charAt(0) === "=" ? 1 : 2,
						text: cap[1],
						tokens: []
					};
					this.lexer.inline(token.text, token.tokens);
					return token;
				}
			};
			_proto.paragraph = function paragraph(src) {
				var cap = this.rules.block.paragraph.exec(src);
				if (cap) {
					var token = {
						type: "paragraph",
						raw: cap[0],
						text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
						tokens: []
					};
					this.lexer.inline(token.text, token.tokens);
					return token;
				}
			};
			_proto.text = function text(src) {
				var cap = this.rules.block.text.exec(src);
				if (cap) {
					var token = {
						type: "text",
						raw: cap[0],
						text: cap[0],
						tokens: []
					};
					this.lexer.inline(token.text, token.tokens);
					return token;
				}
			};
			_proto.escape = function escape$1$1(src) {
				var cap = this.rules.inline.escape.exec(src);
				if (cap) return {
					type: "escape",
					raw: cap[0],
					text: escape$1(cap[1])
				};
			};
			_proto.tag = function tag(src) {
				var cap = this.rules.inline.tag.exec(src);
				if (cap) {
					if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) this.lexer.state.inLink = true;
					else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) this.lexer.state.inLink = false;
					if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = true;
					else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = false;
					return {
						type: this.options.sanitize ? "text" : "html",
						raw: cap[0],
						inLink: this.lexer.state.inLink,
						inRawBlock: this.lexer.state.inRawBlock,
						text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0]) : cap[0]
					};
				}
			};
			_proto.link = function link(src) {
				var cap = this.rules.inline.link.exec(src);
				if (cap) {
					var trimmedUrl = cap[2].trim();
					if (!this.options.pedantic && /^</.test(trimmedUrl)) {
						if (!/>$/.test(trimmedUrl)) return;
						var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
						if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) return;
					} else {
						var lastParenIndex = findClosingBracket(cap[2], "()");
						if (lastParenIndex > -1) {
							var linkLen = (cap[0].indexOf("!") === 0 ? 5 : 4) + cap[1].length + lastParenIndex;
							cap[2] = cap[2].substring(0, lastParenIndex);
							cap[0] = cap[0].substring(0, linkLen).trim();
							cap[3] = "";
						}
					}
					var href = cap[2];
					var title = "";
					if (this.options.pedantic) {
						var link$1 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
						if (link$1) {
							href = link$1[1];
							title = link$1[3];
						}
					} else title = cap[3] ? cap[3].slice(1, -1) : "";
					href = href.trim();
					if (/^</.test(href)) if (this.options.pedantic && !/>$/.test(trimmedUrl)) href = href.slice(1);
					else href = href.slice(1, -1);
					return outputLink(cap, {
						href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
						title: title ? title.replace(this.rules.inline._escapes, "$1") : title
					}, cap[0], this.lexer);
				}
			};
			_proto.reflink = function reflink(src, links) {
				var cap;
				if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
					var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
					link = links[link.toLowerCase()];
					if (!link || !link.href) {
						var text = cap[0].charAt(0);
						return {
							type: "text",
							raw: text,
							text
						};
					}
					return outputLink(cap, link, cap[0], this.lexer);
				}
			};
			_proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
				if (prevChar === void 0) prevChar = "";
				var match = this.rules.inline.emStrong.lDelim.exec(src);
				if (!match) return;
				if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
				var nextChar = match[1] || match[2] || "";
				if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
					var lLength = match[0].length - 1;
					var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
					var endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
					endReg.lastIndex = 0;
					maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
					while ((match = endReg.exec(maskedSrc)) != null) {
						rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
						if (!rDelim) continue;
						rLength = rDelim.length;
						if (match[3] || match[4]) {
							delimTotal += rLength;
							continue;
						} else if (match[5] || match[6]) {
							if (lLength % 3 && !((lLength + rLength) % 3)) {
								midDelimTotal += rLength;
								continue;
							}
						}
						delimTotal -= rLength;
						if (delimTotal > 0) continue;
						rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
						if (Math.min(lLength, rLength) % 2) {
							var _text = src.slice(1, lLength + match.index + rLength);
							return {
								type: "em",
								raw: src.slice(0, lLength + match.index + rLength + 1),
								text: _text,
								tokens: this.lexer.inlineTokens(_text, [])
							};
						}
						var text = src.slice(2, lLength + match.index + rLength - 1);
						return {
							type: "strong",
							raw: src.slice(0, lLength + match.index + rLength + 1),
							text,
							tokens: this.lexer.inlineTokens(text, [])
						};
					}
				}
			};
			_proto.codespan = function codespan(src) {
				var cap = this.rules.inline.code.exec(src);
				if (cap) {
					var text = cap[2].replace(/\n/g, " ");
					var hasNonSpaceChars = /[^ ]/.test(text);
					var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
					if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) text = text.substring(1, text.length - 1);
					text = escape$1(text, true);
					return {
						type: "codespan",
						raw: cap[0],
						text
					};
				}
			};
			_proto.br = function br(src) {
				var cap = this.rules.inline.br.exec(src);
				if (cap) return {
					type: "br",
					raw: cap[0]
				};
			};
			_proto.del = function del(src) {
				var cap = this.rules.inline.del.exec(src);
				if (cap) return {
					type: "del",
					raw: cap[0],
					text: cap[2],
					tokens: this.lexer.inlineTokens(cap[2], [])
				};
			};
			_proto.autolink = function autolink(src, mangle$1) {
				var cap = this.rules.inline.autolink.exec(src);
				if (cap) {
					var text, href;
					if (cap[2] === "@") {
						text = escape$1(this.options.mangle ? mangle$1(cap[1]) : cap[1]);
						href = "mailto:" + text;
					} else {
						text = escape$1(cap[1]);
						href = text;
					}
					return {
						type: "link",
						raw: cap[0],
						text,
						href,
						tokens: [{
							type: "text",
							raw: text,
							text
						}]
					};
				}
			};
			_proto.url = function url(src, mangle$1) {
				var cap;
				if (cap = this.rules.inline.url.exec(src)) {
					var text, href;
					if (cap[2] === "@") {
						text = escape$1(this.options.mangle ? mangle$1(cap[0]) : cap[0]);
						href = "mailto:" + text;
					} else {
						var prevCapZero;
						do {
							prevCapZero = cap[0];
							cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
						} while (prevCapZero !== cap[0]);
						text = escape$1(cap[0]);
						if (cap[1] === "www.") href = "http://" + text;
						else href = text;
					}
					return {
						type: "link",
						raw: cap[0],
						text,
						href,
						tokens: [{
							type: "text",
							raw: text,
							text
						}]
					};
				}
			};
			_proto.inlineText = function inlineText(src, smartypants$1) {
				var cap = this.rules.inline.text.exec(src);
				if (cap) {
					var text;
					if (this.lexer.state.inRawBlock) text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0]) : cap[0];
					else text = escape$1(this.options.smartypants ? smartypants$1(cap[0]) : cap[0]);
					return {
						type: "text",
						raw: cap[0],
						text
					};
				}
			};
			return Tokenizer$1;
		}();
		/**
		* Block-Level Grammar
		*/
		var block = {
			newline: /^(?: *(?:\n|$))+/,
			code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
			fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
			hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
			heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
			blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
			list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
			html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
			def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
			table: noopTest,
			lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
			_paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
			text: /^[^\n]+/
		};
		block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
		block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
		block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
		block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
		block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
		block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
		block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
		block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
		block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
		block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
		block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
		/**
		* Normal Block Grammar
		*/
		block.normal = merge({}, block);
		/**
		* GFM Block Grammar
		*/
		block.gfm = merge({}, block.normal, { table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" });
		block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
		block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
		/**
		* Pedantic grammar (original John Gruber's loose markdown specification)
		*/
		block.pedantic = merge({}, block.normal, {
			html: edit("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
			def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
			heading: /^(#{1,6})(.*)(?:\n+|$)/,
			fences: noopTest,
			paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
		});
		/**
		* Inline-Level Grammar
		*/
		var inline = {
			escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
			autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
			url: noopTest,
			tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
			link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
			reflink: /^!?\[(label)\]\[(ref)\]/,
			nolink: /^!?\[(ref)\](?:\[\])?/,
			reflinkSearch: "reflink|nolink(?!\\()",
			emStrong: {
				lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
				rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
				rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
			},
			code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
			br: /^( {2,}|\\)\n(?!\s*$)/,
			del: noopTest,
			text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
			punctuation: /^([\spunctuation])/
		};
		inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
		inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
		inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
		inline.escapedEmSt = /\\\*|\\_/g;
		inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
		inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
		inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
		inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
		inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
		inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
		inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
		inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
		inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
		inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
		inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
		inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
		inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
		inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
		inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
		inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
		inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
		/**
		* Normal Inline Grammar
		*/
		inline.normal = merge({}, inline);
		/**
		* Pedantic Inline Grammar
		*/
		inline.pedantic = merge({}, inline.normal, {
			strong: {
				start: /^__|\*\*/,
				middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
				endAst: /\*\*(?!\*)/g,
				endUnd: /__(?!_)/g
			},
			em: {
				start: /^_|\*/,
				middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
				endAst: /\*(?!\*)/g,
				endUnd: /_(?!_)/g
			},
			link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
			reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
		});
		/**
		* GFM Inline Grammar
		*/
		inline.gfm = merge({}, inline.normal, {
			escape: edit(inline.escape).replace("])", "~|])").getRegex(),
			_extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
			url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
			_backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
			del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
			text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
		});
		inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
		/**
		* GFM + Line Breaks Inline Grammar
		*/
		inline.breaks = merge({}, inline.gfm, {
			br: edit(inline.br).replace("{2,}", "*").getRegex(),
			text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
		});
		/**
		* smartypants text replacement
		* @param {string} text
		*/
		function smartypants(text) {
			return text.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
		}
		/**
		* mangle email addresses
		* @param {string} text
		*/
		function mangle(text) {
			var out = "", i, ch;
			var l = text.length;
			for (i = 0; i < l; i++) {
				ch = text.charCodeAt(i);
				if (Math.random() > .5) ch = "x" + ch.toString(16);
				out += "&#" + ch + ";";
			}
			return out;
		}
		/**
		* Block Lexer
		*/
		var Lexer = /* @__PURE__ */ function() {
			function Lexer$1(options$1) {
				this.tokens = [];
				this.tokens.links = Object.create(null);
				this.options = options$1 || exports$1.defaults;
				this.options.tokenizer = this.options.tokenizer || new Tokenizer();
				this.tokenizer = this.options.tokenizer;
				this.tokenizer.options = this.options;
				this.tokenizer.lexer = this;
				this.inlineQueue = [];
				this.state = {
					inLink: false,
					inRawBlock: false,
					top: true
				};
				var rules = {
					block: block.normal,
					inline: inline.normal
				};
				if (this.options.pedantic) {
					rules.block = block.pedantic;
					rules.inline = inline.pedantic;
				} else if (this.options.gfm) {
					rules.block = block.gfm;
					if (this.options.breaks) rules.inline = inline.breaks;
					else rules.inline = inline.gfm;
				}
				this.tokenizer.rules = rules;
			}
			/**
			* Expose Rules
			*/
			/**
			* Static Lex Method
			*/
			Lexer$1.lex = function lex(src, options$1) {
				return new Lexer$1(options$1).lex(src);
			};
			Lexer$1.lexInline = function lexInline(src, options$1) {
				return new Lexer$1(options$1).inlineTokens(src);
			};
			var _proto = Lexer$1.prototype;
			_proto.lex = function lex(src) {
				src = src.replace(/\r\n|\r/g, "\n");
				this.blockTokens(src, this.tokens);
				var next;
				while (next = this.inlineQueue.shift()) this.inlineTokens(next.src, next.tokens);
				return this.tokens;
			};
			_proto.blockTokens = function blockTokens(src, tokens) {
				var _this = this;
				if (tokens === void 0) tokens = [];
				if (this.options.pedantic) src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
				else src = src.replace(/^( *)(\t+)/gm, function(_, leading, tabs) {
					return leading + "    ".repeat(tabs.length);
				});
				var token, lastToken, cutSrc, lastParagraphClipped;
				while (src) {
					if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
						if (token = extTokenizer.call({ lexer: _this }, src, tokens)) {
							src = src.substring(token.raw.length);
							tokens.push(token);
							return true;
						}
						return false;
					})) continue;
					if (token = this.tokenizer.space(src)) {
						src = src.substring(token.raw.length);
						if (token.raw.length === 1 && tokens.length > 0) tokens[tokens.length - 1].raw += "\n";
						else tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.code(src)) {
						src = src.substring(token.raw.length);
						lastToken = tokens[tokens.length - 1];
						if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
							lastToken.raw += "\n" + token.raw;
							lastToken.text += "\n" + token.text;
							this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
						} else tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.fences(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.heading(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.hr(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.blockquote(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.list(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.html(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.def(src)) {
						src = src.substring(token.raw.length);
						lastToken = tokens[tokens.length - 1];
						if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
							lastToken.raw += "\n" + token.raw;
							lastToken.text += "\n" + token.raw;
							this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
						} else if (!this.tokens.links[token.tag]) this.tokens.links[token.tag] = {
							href: token.href,
							title: token.title
						};
						continue;
					}
					if (token = this.tokenizer.table(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.lheading(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					cutSrc = src;
					if (this.options.extensions && this.options.extensions.startBlock) (function() {
						var startIndex = Infinity;
						var tempSrc = src.slice(1);
						var tempStart = void 0;
						_this.options.extensions.startBlock.forEach(function(getStartIndex) {
							tempStart = getStartIndex.call({ lexer: this }, tempSrc);
							if (typeof tempStart === "number" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);
						});
						if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);
					})();
					if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
						lastToken = tokens[tokens.length - 1];
						if (lastParagraphClipped && lastToken.type === "paragraph") {
							lastToken.raw += "\n" + token.raw;
							lastToken.text += "\n" + token.text;
							this.inlineQueue.pop();
							this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
						} else tokens.push(token);
						lastParagraphClipped = cutSrc.length !== src.length;
						src = src.substring(token.raw.length);
						continue;
					}
					if (token = this.tokenizer.text(src)) {
						src = src.substring(token.raw.length);
						lastToken = tokens[tokens.length - 1];
						if (lastToken && lastToken.type === "text") {
							lastToken.raw += "\n" + token.raw;
							lastToken.text += "\n" + token.text;
							this.inlineQueue.pop();
							this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
						} else tokens.push(token);
						continue;
					}
					if (src) {
						var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
						if (this.options.silent) {
							console.error(errMsg);
							break;
						} else throw new Error(errMsg);
					}
				}
				this.state.top = true;
				return tokens;
			};
			_proto.inline = function inline$1(src, tokens) {
				this.inlineQueue.push({
					src,
					tokens
				});
			};
			_proto.inlineTokens = function inlineTokens(src, tokens) {
				var _this2 = this;
				if (tokens === void 0) tokens = [];
				var token, lastToken, cutSrc;
				var maskedSrc = src;
				var match;
				var keepPrevChar, prevChar;
				if (this.tokens.links) {
					var links = Object.keys(this.tokens.links);
					if (links.length > 0) {
						while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
					}
				}
				while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
				while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
				while (src) {
					if (!keepPrevChar) prevChar = "";
					keepPrevChar = false;
					if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
						if (token = extTokenizer.call({ lexer: _this2 }, src, tokens)) {
							src = src.substring(token.raw.length);
							tokens.push(token);
							return true;
						}
						return false;
					})) continue;
					if (token = this.tokenizer.escape(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.tag(src)) {
						src = src.substring(token.raw.length);
						lastToken = tokens[tokens.length - 1];
						if (lastToken && token.type === "text" && lastToken.type === "text") {
							lastToken.raw += token.raw;
							lastToken.text += token.text;
						} else tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.link(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.reflink(src, this.tokens.links)) {
						src = src.substring(token.raw.length);
						lastToken = tokens[tokens.length - 1];
						if (lastToken && token.type === "text" && lastToken.type === "text") {
							lastToken.raw += token.raw;
							lastToken.text += token.text;
						} else tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.codespan(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.br(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.del(src)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (token = this.tokenizer.autolink(src, mangle)) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
						src = src.substring(token.raw.length);
						tokens.push(token);
						continue;
					}
					cutSrc = src;
					if (this.options.extensions && this.options.extensions.startInline) (function() {
						var startIndex = Infinity;
						var tempSrc = src.slice(1);
						var tempStart = void 0;
						_this2.options.extensions.startInline.forEach(function(getStartIndex) {
							tempStart = getStartIndex.call({ lexer: this }, tempSrc);
							if (typeof tempStart === "number" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);
						});
						if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);
					})();
					if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
						src = src.substring(token.raw.length);
						if (token.raw.slice(-1) !== "_") prevChar = token.raw.slice(-1);
						keepPrevChar = true;
						lastToken = tokens[tokens.length - 1];
						if (lastToken && lastToken.type === "text") {
							lastToken.raw += token.raw;
							lastToken.text += token.text;
						} else tokens.push(token);
						continue;
					}
					if (src) {
						var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
						if (this.options.silent) {
							console.error(errMsg);
							break;
						} else throw new Error(errMsg);
					}
				}
				return tokens;
			};
			_createClass(Lexer$1, null, [{
				key: "rules",
				get: function get() {
					return {
						block,
						inline
					};
				}
			}]);
			return Lexer$1;
		}();
		/**
		* Renderer
		*/
		var Renderer = /* @__PURE__ */ function() {
			function Renderer$1(options$1) {
				this.options = options$1 || exports$1.defaults;
			}
			var _proto = Renderer$1.prototype;
			_proto.code = function code(_code, infostring, escaped) {
				var lang = (infostring || "").match(/\S*/)[0];
				if (this.options.highlight) {
					var out = this.options.highlight(_code, lang);
					if (out != null && out !== _code) {
						escaped = true;
						_code = out;
					}
				}
				_code = _code.replace(/\n$/, "") + "\n";
				if (!lang) return "<pre><code>" + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
				return "<pre><code class=\"" + this.options.langPrefix + escape$1(lang, true) + "\">" + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
			};
			_proto.blockquote = function blockquote(quote) {
				return "<blockquote>\n" + quote + "</blockquote>\n";
			};
			_proto.html = function html(_html) {
				return _html;
			};
			_proto.heading = function heading(text, level, raw, slugger) {
				if (this.options.headerIds) {
					var id = this.options.headerPrefix + slugger.slug(raw);
					return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
				}
				return "<h" + level + ">" + text + "</h" + level + ">\n";
			};
			_proto.hr = function hr() {
				return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
			};
			_proto.list = function list(body, ordered, start) {
				var type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? " start=\"" + start + "\"" : "";
				return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
			};
			_proto.listitem = function listitem(text) {
				return "<li>" + text + "</li>\n";
			};
			_proto.checkbox = function checkbox(checked) {
				return "<input " + (checked ? "checked=\"\" " : "") + "disabled=\"\" type=\"checkbox\"" + (this.options.xhtml ? " /" : "") + "> ";
			};
			_proto.paragraph = function paragraph(text) {
				return "<p>" + text + "</p>\n";
			};
			_proto.table = function table(header, body) {
				if (body) body = "<tbody>" + body + "</tbody>";
				return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
			};
			_proto.tablerow = function tablerow(content) {
				return "<tr>\n" + content + "</tr>\n";
			};
			_proto.tablecell = function tablecell(content, flags) {
				var type = flags.header ? "th" : "td";
				return (flags.align ? "<" + type + " align=\"" + flags.align + "\">" : "<" + type + ">") + content + ("</" + type + ">\n");
			};
			_proto.strong = function strong(text) {
				return "<strong>" + text + "</strong>";
			};
			_proto.em = function em(text) {
				return "<em>" + text + "</em>";
			};
			_proto.codespan = function codespan(text) {
				return "<code>" + text + "</code>";
			};
			_proto.br = function br() {
				return this.options.xhtml ? "<br/>" : "<br>";
			};
			_proto.del = function del(text) {
				return "<del>" + text + "</del>";
			};
			_proto.link = function link(href, title, text) {
				href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
				if (href === null) return text;
				var out = "<a href=\"" + escape$1(href) + "\"";
				if (title) out += " title=\"" + title + "\"";
				out += ">" + text + "</a>";
				return out;
			};
			_proto.image = function image(href, title, text) {
				href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
				if (href === null) return text;
				var out = "<img src=\"" + href + "\" alt=\"" + text + "\"";
				if (title) out += " title=\"" + title + "\"";
				out += this.options.xhtml ? "/>" : ">";
				return out;
			};
			_proto.text = function text(_text) {
				return _text;
			};
			return Renderer$1;
		}();
		/**
		* TextRenderer
		* returns only the textual part of the token
		*/
		var TextRenderer = /* @__PURE__ */ function() {
			function TextRenderer$1() {}
			var _proto = TextRenderer$1.prototype;
			_proto.strong = function strong(text) {
				return text;
			};
			_proto.em = function em(text) {
				return text;
			};
			_proto.codespan = function codespan(text) {
				return text;
			};
			_proto.del = function del(text) {
				return text;
			};
			_proto.html = function html(text) {
				return text;
			};
			_proto.text = function text(_text) {
				return _text;
			};
			_proto.link = function link(href, title, text) {
				return "" + text;
			};
			_proto.image = function image(href, title, text) {
				return "" + text;
			};
			_proto.br = function br() {
				return "";
			};
			return TextRenderer$1;
		}();
		/**
		* Slugger generates header id
		*/
		var Slugger = /* @__PURE__ */ function() {
			function Slugger$1() {
				this.seen = {};
			}
			/**
			* @param {string} value
			*/
			var _proto = Slugger$1.prototype;
			_proto.serialize = function serialize(value) {
				return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
			};
			_proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
				var slug = originalSlug;
				var occurenceAccumulator = 0;
				if (this.seen.hasOwnProperty(slug)) {
					occurenceAccumulator = this.seen[originalSlug];
					do {
						occurenceAccumulator++;
						slug = originalSlug + "-" + occurenceAccumulator;
					} while (this.seen.hasOwnProperty(slug));
				}
				if (!isDryRun) {
					this.seen[originalSlug] = occurenceAccumulator;
					this.seen[slug] = 0;
				}
				return slug;
			};
			_proto.slug = function slug(value, options$1) {
				if (options$1 === void 0) options$1 = {};
				var slug$1 = this.serialize(value);
				return this.getNextSafeSlug(slug$1, options$1.dryrun);
			};
			return Slugger$1;
		}();
		/**
		* Parsing & Compiling
		*/
		var Parser = /* @__PURE__ */ function() {
			function Parser$1(options$1) {
				this.options = options$1 || exports$1.defaults;
				this.options.renderer = this.options.renderer || new Renderer();
				this.renderer = this.options.renderer;
				this.renderer.options = this.options;
				this.textRenderer = new TextRenderer();
				this.slugger = new Slugger();
			}
			/**
			* Static Parse Method
			*/
			Parser$1.parse = function parse$2(tokens, options$1) {
				return new Parser$1(options$1).parse(tokens);
			};
			Parser$1.parseInline = function parseInline$1(tokens, options$1) {
				return new Parser$1(options$1).parseInline(tokens);
			};
			var _proto = Parser$1.prototype;
			_proto.parse = function parse$2(tokens, top) {
				if (top === void 0) top = true;
				var out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
				var l = tokens.length;
				for (i = 0; i < l; i++) {
					token = tokens[i];
					if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
						ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
						if (ret !== false || ![
							"space",
							"hr",
							"heading",
							"code",
							"table",
							"blockquote",
							"list",
							"html",
							"paragraph",
							"text"
						].includes(token.type)) {
							out += ret || "";
							continue;
						}
					}
					switch (token.type) {
						case "space": continue;
						case "hr":
							out += this.renderer.hr();
							continue;
						case "heading":
							out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
							continue;
						case "code":
							out += this.renderer.code(token.text, token.lang, token.escaped);
							continue;
						case "table":
							header = "";
							cell = "";
							l2 = token.header.length;
							for (j = 0; j < l2; j++) cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
								header: true,
								align: token.align[j]
							});
							header += this.renderer.tablerow(cell);
							body = "";
							l2 = token.rows.length;
							for (j = 0; j < l2; j++) {
								row = token.rows[j];
								cell = "";
								l3 = row.length;
								for (k = 0; k < l3; k++) cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
									header: false,
									align: token.align[k]
								});
								body += this.renderer.tablerow(cell);
							}
							out += this.renderer.table(header, body);
							continue;
						case "blockquote":
							body = this.parse(token.tokens);
							out += this.renderer.blockquote(body);
							continue;
						case "list":
							ordered = token.ordered;
							start = token.start;
							loose = token.loose;
							l2 = token.items.length;
							body = "";
							for (j = 0; j < l2; j++) {
								item = token.items[j];
								checked = item.checked;
								task = item.task;
								itemBody = "";
								if (item.task) {
									checkbox = this.renderer.checkbox(checked);
									if (loose) if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
										item.tokens[0].text = checkbox + " " + item.tokens[0].text;
										if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
									} else item.tokens.unshift({
										type: "text",
										text: checkbox
									});
									else itemBody += checkbox;
								}
								itemBody += this.parse(item.tokens, loose);
								body += this.renderer.listitem(itemBody, task, checked);
							}
							out += this.renderer.list(body, ordered, start);
							continue;
						case "html":
							out += this.renderer.html(token.text);
							continue;
						case "paragraph":
							out += this.renderer.paragraph(this.parseInline(token.tokens));
							continue;
						case "text":
							body = token.tokens ? this.parseInline(token.tokens) : token.text;
							while (i + 1 < l && tokens[i + 1].type === "text") {
								token = tokens[++i];
								body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
							}
							out += top ? this.renderer.paragraph(body) : body;
							continue;
						default:
							var errMsg = "Token with \"" + token.type + "\" type was not found.";
							if (this.options.silent) {
								console.error(errMsg);
								return;
							} else throw new Error(errMsg);
					}
				}
				return out;
			};
			_proto.parseInline = function parseInline$1(tokens, renderer) {
				renderer = renderer || this.renderer;
				var out = "", i, token, ret;
				var l = tokens.length;
				for (i = 0; i < l; i++) {
					token = tokens[i];
					if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
						ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
						if (ret !== false || ![
							"escape",
							"html",
							"link",
							"image",
							"strong",
							"em",
							"codespan",
							"br",
							"del",
							"text"
						].includes(token.type)) {
							out += ret || "";
							continue;
						}
					}
					switch (token.type) {
						case "escape":
							out += renderer.text(token.text);
							break;
						case "html":
							out += renderer.html(token.text);
							break;
						case "link":
							out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
							break;
						case "image":
							out += renderer.image(token.href, token.title, token.text);
							break;
						case "strong":
							out += renderer.strong(this.parseInline(token.tokens, renderer));
							break;
						case "em":
							out += renderer.em(this.parseInline(token.tokens, renderer));
							break;
						case "codespan":
							out += renderer.codespan(token.text);
							break;
						case "br":
							out += renderer.br();
							break;
						case "del":
							out += renderer.del(this.parseInline(token.tokens, renderer));
							break;
						case "text":
							out += renderer.text(token.text);
							break;
						default:
							var errMsg = "Token with \"" + token.type + "\" type was not found.";
							if (this.options.silent) {
								console.error(errMsg);
								return;
							} else throw new Error(errMsg);
					}
				}
				return out;
			};
			return Parser$1;
		}();
		/**
		* Marked
		*/
		function marked$1(src, opt, callback) {
			if (typeof src === "undefined" || src === null) throw new Error("marked(): input parameter is undefined or null");
			if (typeof src !== "string") throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
			if (typeof opt === "function") {
				callback = opt;
				opt = null;
			}
			opt = merge({}, marked$1.defaults, opt || {});
			checkSanitizeDeprecation(opt);
			if (callback) {
				var highlight = opt.highlight;
				var tokens;
				try {
					tokens = Lexer.lex(src, opt);
				} catch (e) {
					return callback(e);
				}
				var done = function done$1(err) {
					var out;
					if (!err) try {
						if (opt.walkTokens) marked$1.walkTokens(tokens, opt.walkTokens);
						out = Parser.parse(tokens, opt);
					} catch (e) {
						err = e;
					}
					opt.highlight = highlight;
					return err ? callback(err) : callback(null, out);
				};
				if (!highlight || highlight.length < 3) return done();
				delete opt.highlight;
				if (!tokens.length) return done();
				var pending = 0;
				marked$1.walkTokens(tokens, function(token) {
					if (token.type === "code") {
						pending++;
						setTimeout(function() {
							highlight(token.text, token.lang, function(err, code) {
								if (err) return done(err);
								if (code != null && code !== token.text) {
									token.text = code;
									token.escaped = true;
								}
								pending--;
								if (pending === 0) done();
							});
						}, 0);
					}
				});
				if (pending === 0) done();
				return;
			}
			try {
				var _tokens = Lexer.lex(src, opt);
				if (opt.walkTokens) marked$1.walkTokens(_tokens, opt.walkTokens);
				return Parser.parse(_tokens, opt);
			} catch (e) {
				e.message += "\nPlease report this to https://github.com/markedjs/marked.";
				if (opt.silent) return "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
				throw e;
			}
		}
		/**
		* Options
		*/
		marked$1.options = marked$1.setOptions = function(opt) {
			merge(marked$1.defaults, opt);
			changeDefaults(marked$1.defaults);
			return marked$1;
		};
		marked$1.getDefaults = getDefaults;
		marked$1.defaults = exports$1.defaults;
		/**
		* Use Extension
		*/
		marked$1.use = function() {
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			var opts = merge.apply(void 0, [{}].concat(args));
			var extensions = marked$1.defaults.extensions || {
				renderers: {},
				childTokens: {}
			};
			var hasExtensions;
			args.forEach(function(pack) {
				if (pack.extensions) {
					hasExtensions = true;
					pack.extensions.forEach(function(ext) {
						if (!ext.name) throw new Error("extension name required");
						if (ext.renderer) {
							var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
							if (prevRenderer) extensions.renderers[ext.name] = function() {
								for (var _len2 = arguments.length, args$1 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args$1[_key2] = arguments[_key2];
								var ret = ext.renderer.apply(this, args$1);
								if (ret === false) ret = prevRenderer.apply(this, args$1);
								return ret;
							};
							else extensions.renderers[ext.name] = ext.renderer;
						}
						if (ext.tokenizer) {
							if (!ext.level || ext.level !== "block" && ext.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
							if (extensions[ext.level]) extensions[ext.level].unshift(ext.tokenizer);
							else extensions[ext.level] = [ext.tokenizer];
							if (ext.start) {
								if (ext.level === "block") if (extensions.startBlock) extensions.startBlock.push(ext.start);
								else extensions.startBlock = [ext.start];
								else if (ext.level === "inline") if (extensions.startInline) extensions.startInline.push(ext.start);
								else extensions.startInline = [ext.start];
							}
						}
						if (ext.childTokens) extensions.childTokens[ext.name] = ext.childTokens;
					});
				}
				if (pack.renderer) (function() {
					var renderer = marked$1.defaults.renderer || new Renderer();
					var _loop = function _loop$1(prop$1) {
						var prevRenderer = renderer[prop$1];
						renderer[prop$1] = function() {
							for (var _len3 = arguments.length, args$1 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args$1[_key3] = arguments[_key3];
							var ret = pack.renderer[prop$1].apply(renderer, args$1);
							if (ret === false) ret = prevRenderer.apply(renderer, args$1);
							return ret;
						};
					};
					for (var prop in pack.renderer) _loop(prop);
					opts.renderer = renderer;
				})();
				if (pack.tokenizer) (function() {
					var tokenizer = marked$1.defaults.tokenizer || new Tokenizer();
					var _loop2 = function _loop2$1(prop$1) {
						var prevTokenizer = tokenizer[prop$1];
						tokenizer[prop$1] = function() {
							for (var _len4 = arguments.length, args$1 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args$1[_key4] = arguments[_key4];
							var ret = pack.tokenizer[prop$1].apply(tokenizer, args$1);
							if (ret === false) ret = prevTokenizer.apply(tokenizer, args$1);
							return ret;
						};
					};
					for (var prop in pack.tokenizer) _loop2(prop);
					opts.tokenizer = tokenizer;
				})();
				if (pack.walkTokens) {
					var _walkTokens = marked$1.defaults.walkTokens;
					opts.walkTokens = function(token) {
						pack.walkTokens.call(this, token);
						if (_walkTokens) _walkTokens.call(this, token);
					};
				}
				if (hasExtensions) opts.extensions = extensions;
				marked$1.setOptions(opts);
			});
		};
		/**
		* Run callback for every token
		*/
		marked$1.walkTokens = function(tokens, callback) {
			var _loop3 = function _loop3$1() {
				var token = _step.value;
				callback.call(marked$1, token);
				switch (token.type) {
					case "table":
						for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
							var cell = _step2.value;
							marked$1.walkTokens(cell.tokens, callback);
						}
						for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {
							var row = _step3.value;
							for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
								var _cell = _step4.value;
								marked$1.walkTokens(_cell.tokens, callback);
							}
						}
						break;
					case "list":
						marked$1.walkTokens(token.items, callback);
						break;
					default: if (marked$1.defaults.extensions && marked$1.defaults.extensions.childTokens && marked$1.defaults.extensions.childTokens[token.type]) marked$1.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
						marked$1.walkTokens(token[childTokens], callback);
					});
					else if (token.tokens) marked$1.walkTokens(token.tokens, callback);
				}
			};
			for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) _loop3();
		};
		/**
		* Parse Inline
		* @param {string} src
		*/
		marked$1.parseInline = function(src, opt) {
			if (typeof src === "undefined" || src === null) throw new Error("marked.parseInline(): input parameter is undefined or null");
			if (typeof src !== "string") throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
			opt = merge({}, marked$1.defaults, opt || {});
			checkSanitizeDeprecation(opt);
			try {
				var tokens = Lexer.lexInline(src, opt);
				if (opt.walkTokens) marked$1.walkTokens(tokens, opt.walkTokens);
				return Parser.parseInline(tokens, opt);
			} catch (e) {
				e.message += "\nPlease report this to https://github.com/markedjs/marked.";
				if (opt.silent) return "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
				throw e;
			}
		};
		/**
		* Expose
		*/
		marked$1.Parser = Parser;
		marked$1.parser = Parser.parse;
		marked$1.Renderer = Renderer;
		marked$1.TextRenderer = TextRenderer;
		marked$1.Lexer = Lexer;
		marked$1.lexer = Lexer.lex;
		marked$1.Tokenizer = Tokenizer;
		marked$1.Slugger = Slugger;
		marked$1.parse = marked$1;
		var options = marked$1.options;
		var setOptions = marked$1.setOptions;
		var use = marked$1.use;
		var walkTokens = marked$1.walkTokens;
		var parseInline = marked$1.parseInline;
		var parse$1 = marked$1;
		var parser = Parser.parse;
		var lexer = Lexer.lex;
		exports$1.Lexer = Lexer;
		exports$1.Parser = Parser;
		exports$1.Renderer = Renderer;
		exports$1.Slugger = Slugger;
		exports$1.TextRenderer = TextRenderer;
		exports$1.Tokenizer = Tokenizer;
		exports$1.getDefaults = getDefaults;
		exports$1.lexer = lexer;
		exports$1.marked = marked$1;
		exports$1.options = options;
		exports$1.parse = parse$1;
		exports$1.parseInline = parseInline;
		exports$1.parser = parser;
		exports$1.setOptions = setOptions;
		exports$1.use = use;
		exports$1.walkTokens = walkTokens;
		Object.defineProperty(exports$1, "__esModule", { value: true });
	}));
})();
var marked = __marked_exports || exports;

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
/**
* Low-level way create a html element from a markdown string.
*
* **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)
* which comes with support for pretty code block rendering and which uses the default way of handling links.
*/
function renderMarkdown(markdown, options = {}, markedOptions = {}) {
	var _a$5;
	const disposables = new DisposableStore();
	let isDisposed = false;
	const element = createElement(options);
	const _uriMassage = function(part) {
		let data;
		try {
			data = parse(decodeURIComponent(part));
		} catch (e) {}
		if (!data) return part;
		data = cloneAndChange(data, (value$1) => {
			if (markdown.uris && markdown.uris[value$1]) return URI.revive(markdown.uris[value$1]);
			else return;
		});
		return encodeURIComponent(JSON.stringify(data));
	};
	const _href = function(href, isDomUri) {
		const data = markdown.uris && markdown.uris[href];
		let uri = URI.revive(data);
		if (isDomUri) {
			if (href.startsWith(Schemas.data + ":")) return href;
			if (!uri) uri = URI.parse(href);
			return FileAccess.asBrowserUri(uri).toString(true);
		}
		if (!uri) return href;
		if (URI.parse(href).toString() === uri.toString()) return href;
		if (uri.query) uri = uri.with({ query: _uriMassage(uri.query) });
		return uri.toString();
	};
	const renderer = new marked.Renderer();
	renderer.image = (href, title, text) => {
		let dimensions = [];
		let attributes = [];
		if (href) {
			({href, dimensions} = parseHrefAndDimensions(href));
			attributes.push(`src="${escapeDoubleQuotes(href)}"`);
		}
		if (text) attributes.push(`alt="${escapeDoubleQuotes(text)}"`);
		if (title) attributes.push(`title="${escapeDoubleQuotes(title)}"`);
		if (dimensions.length) attributes = attributes.concat(dimensions);
		return "<img " + attributes.join(" ") + ">";
	};
	renderer.link = (href, title, text) => {
		if (typeof href !== "string") return "";
		if (href === text) text = removeMarkdownEscapes(text);
		title = typeof title === "string" ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : "";
		href = removeMarkdownEscapes(href);
		href = href.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
		return `<a href="${href}" title="${title || href}">${text}</a>`;
	};
	renderer.paragraph = (text) => {
		return `<p>${text}</p>`;
	};
	const codeBlocks = [];
	if (options.codeBlockRenderer) renderer.code = (code, lang) => {
		const id = defaultGenerator.nextId();
		const value$1 = options.codeBlockRenderer(lang !== null && lang !== void 0 ? lang : "", code);
		codeBlocks.push(value$1.then((element$1) => [id, element$1]));
		return `<div class="code" data-code="${id}">${escape(code)}</div>`;
	};
	if (options.actionHandler) {
		const onClick = options.actionHandler.disposables.add(new DomEmitter(element, "click"));
		const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, "auxclick"));
		options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)((e) => {
			const mouseEvent = new StandardMouseEvent(e);
			if (!mouseEvent.leftButton && !mouseEvent.middleButton) return;
			let target = mouseEvent.target;
			if (target.tagName !== "A") {
				target = target.parentElement;
				if (!target || target.tagName !== "A") return;
			}
			try {
				let href = target.dataset["href"];
				if (href) {
					if (markdown.baseUri) href = resolveWithBaseUri(URI.from(markdown.baseUri), href);
					options.actionHandler.callback(href, mouseEvent);
				}
			} catch (err) {
				onUnexpectedError(err);
			} finally {
				mouseEvent.preventDefault();
			}
		}));
	}
	if (!markdown.supportHtml) {
		markedOptions.sanitizer = (html) => {
			return (markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? html : "";
		};
		markedOptions.sanitize = true;
		markedOptions.silent = true;
	}
	markedOptions.renderer = renderer;
	let value = (_a$5 = markdown.value) !== null && _a$5 !== void 0 ? _a$5 : "";
	if (value.length > 1e5) value = `${value.substr(0, 1e5)}`;
	if (markdown.supportThemeIcons) value = markdownEscapeEscapedIcons(value);
	let renderedMarkdown = marked.parse(value, markedOptions);
	if (markdown.supportThemeIcons) renderedMarkdown = renderLabelWithIcons(renderedMarkdown).map((e) => typeof e === "string" ? e : e.outerHTML).join("");
	const markdownHtmlDoc = new DOMParser().parseFromString(sanitizeRenderedMarkdown(markdown, renderedMarkdown), "text/html");
	markdownHtmlDoc.body.querySelectorAll("img").forEach((img) => {
		const src = img.getAttribute("src");
		if (src) {
			let href = src;
			try {
				if (markdown.baseUri) href = resolveWithBaseUri(URI.from(markdown.baseUri), href);
			} catch (err) {}
			img.src = _href(href, true);
		}
	});
	markdownHtmlDoc.body.querySelectorAll("a").forEach((a) => {
		const href = a.getAttribute("href");
		a.setAttribute("href", "");
		if (!href || /^data:|javascript:/i.test(href) || /^command:/i.test(href) && !markdown.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(href)) a.replaceWith(...a.childNodes);
		else {
			let resolvedHref = _href(href, false);
			if (markdown.baseUri) resolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);
			a.dataset.href = resolvedHref;
		}
	});
	element.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML);
	if (codeBlocks.length > 0) Promise.all(codeBlocks).then((tuples) => {
		var _a$6, _b$1;
		if (isDisposed) return;
		const renderedElements = new Map(tuples);
		const placeholderElements = element.querySelectorAll(`div[data-code]`);
		for (const placeholderElement of placeholderElements) {
			const renderedElement = renderedElements.get((_a$6 = placeholderElement.dataset["code"]) !== null && _a$6 !== void 0 ? _a$6 : "");
			if (renderedElement) reset(placeholderElement, renderedElement);
		}
		(_b$1 = options.asyncRenderCallback) === null || _b$1 === void 0 || _b$1.call(options);
	});
	if (options.asyncRenderCallback) for (const img of element.getElementsByTagName("img")) {
		const listener = disposables.add(addDisposableListener(img, "load", () => {
			listener.dispose();
			options.asyncRenderCallback();
		}));
	}
	return {
		element,
		dispose: () => {
			isDisposed = true;
			disposables.dispose();
		}
	};
}
function resolveWithBaseUri(baseUri, href) {
	if (/^\w[\w\d+.-]*:/.test(href)) return href;
	if (baseUri.path.endsWith("/")) return resolvePath(baseUri, href).toString();
	else return resolvePath(dirname(baseUri), href).toString();
}
function sanitizeRenderedMarkdown(options, renderedMarkdown) {
	const { config, allowedSchemes } = getSanitizerOptions(options);
	addHook("uponSanitizeAttribute", (element, e) => {
		if (e.attrName === "style" || e.attrName === "class") {
			if (element.tagName === "SPAN") {
				if (e.attrName === "style") {
					e.keepAttr = /^(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?$/.test(e.attrValue);
					return;
				} else if (e.attrName === "class") {
					e.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(e.attrValue);
					return;
				}
			}
			e.keepAttr = false;
			return;
		}
	});
	const hook = hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);
	try {
		return sanitize(renderedMarkdown, Object.assign(Object.assign({}, config), { RETURN_TRUSTED_TYPE: true }));
	} finally {
		removeHook("uponSanitizeAttribute");
		hook.dispose();
	}
}
function getSanitizerOptions(options) {
	const allowedSchemes = [
		Schemas.http,
		Schemas.https,
		Schemas.mailto,
		Schemas.data,
		Schemas.file,
		Schemas.vscodeFileResource,
		Schemas.vscodeRemote,
		Schemas.vscodeRemoteResource
	];
	if (options.isTrusted) allowedSchemes.push(Schemas.command);
	return {
		config: {
			ALLOWED_TAGS: [
				"ul",
				"li",
				"p",
				"b",
				"i",
				"code",
				"blockquote",
				"ol",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"hr",
				"em",
				"pre",
				"table",
				"thead",
				"tbody",
				"tr",
				"th",
				"td",
				"div",
				"del",
				"a",
				"strong",
				"br",
				"img",
				"span"
			],
			ALLOWED_ATTR: [
				"href",
				"data-href",
				"target",
				"title",
				"src",
				"alt",
				"class",
				"style",
				"data-code",
				"width",
				"height",
				"align"
			],
			ALLOW_UNKNOWN_PROTOCOLS: true
		},
		allowedSchemes
	};
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js
var __decorate$61 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$61 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$38 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var _a$3;
/**
* Markdown renderer that can render codeblocks with the editor mechanics. This
* renderer should always be preferred.
*/
var MarkdownRenderer = class MarkdownRenderer$1 {
	constructor(_options, _languageService, _openerService) {
		this._options = _options;
		this._languageService = _languageService;
		this._openerService = _openerService;
		this._onDidRenderAsync = new Emitter$1();
		this.onDidRenderAsync = this._onDidRenderAsync.event;
	}
	dispose() {
		this._onDidRenderAsync.dispose();
	}
	render(markdown, options, markedOptions) {
		if (!markdown) return {
			element: document.createElement("span"),
			dispose: () => {}
		};
		const disposables = new DisposableStore();
		return {
			element: disposables.add(renderMarkdown(markdown, Object.assign(Object.assign({}, this._getRenderOptions(markdown, disposables)), options), markedOptions)).element,
			dispose: () => disposables.dispose()
		};
	}
	_getRenderOptions(markdown, disposables) {
		return {
			codeBlockRenderer: (languageAlias, value) => __awaiter$38(this, void 0, void 0, function* () {
				var _a$5, _b$1, _c$1;
				let languageId;
				if (languageAlias) languageId = this._languageService.getLanguageIdByLanguageName(languageAlias);
				else if (this._options.editor) languageId = (_a$5 = this._options.editor.getModel()) === null || _a$5 === void 0 ? void 0 : _a$5.getLanguageId();
				if (!languageId) languageId = PLAINTEXT_LANGUAGE_ID;
				const html = yield tokenizeToString(this._languageService, value, languageId);
				const element = document.createElement("span");
				element.innerHTML = (_c$1 = (_b$1 = MarkdownRenderer$1._ttpTokenizer) === null || _b$1 === void 0 ? void 0 : _b$1.createHTML(html)) !== null && _c$1 !== void 0 ? _c$1 : html;
				if (this._options.editor) applyFontInfo(element, this._options.editor.getOption(46));
				else if (this._options.codeBlockFontFamily) element.style.fontFamily = this._options.codeBlockFontFamily;
				if (this._options.codeBlockFontSize !== void 0) element.style.fontSize = this._options.codeBlockFontSize;
				return element;
			}),
			asyncRenderCallback: () => this._onDidRenderAsync.fire(),
			actionHandler: {
				callback: (content) => this._openerService.open(content, {
					fromUserGesture: true,
					allowContributedOpeners: true,
					allowCommands: markdown.isTrusted
				}).catch(onUnexpectedError),
				disposables
			}
		};
	}
};
MarkdownRenderer._ttpTokenizer = (_a$3 = window.trustedTypes) === null || _a$3 === void 0 ? void 0 : _a$3.createPolicy("tokenizeToString", { createHTML(html) {
	return html;
} });
MarkdownRenderer = __decorate$61([__param$61(1, ILanguageService), __param$61(2, IOpenerService)], MarkdownRenderer);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/marginHover.js
var $$4 = $;
var MarginHoverWidget = class MarginHoverWidget extends Disposable {
	constructor(editor$1, languageService, openerService = NullOpenerService) {
		super();
		this._renderDisposeables = this._register(new DisposableStore());
		this._editor = editor$1;
		this._isVisible = false;
		this._messages = [];
		this._hover = this._register(new HoverWidget());
		this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
		this._markdownRenderer = this._register(new MarkdownRenderer({ editor: this._editor }, languageService, openerService));
		this._computer = new MarginHoverComputer(this._editor);
		this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
		this._register(this._hoverOperation.onResult((result) => {
			this._withResult(result.value);
		}));
		this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(46)) this._updateFont();
		}));
		this._editor.addOverlayWidget(this);
	}
	dispose() {
		this._editor.removeOverlayWidget(this);
		super.dispose();
	}
	getId() {
		return MarginHoverWidget.ID;
	}
	getDomNode() {
		return this._hover.containerDomNode;
	}
	getPosition() {
		return null;
	}
	_updateFont() {
		Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((node) => this._editor.applyFontInfo(node));
	}
	_onModelDecorationsChanged() {
		if (this._isVisible) {
			this._hoverOperation.cancel();
			this._hoverOperation.start(0);
		}
	}
	startShowingAt(lineNumber) {
		if (this._computer.lineNumber === lineNumber) return;
		this._hoverOperation.cancel();
		this.hide();
		this._computer.lineNumber = lineNumber;
		this._hoverOperation.start(0);
	}
	hide() {
		this._computer.lineNumber = -1;
		this._hoverOperation.cancel();
		if (!this._isVisible) return;
		this._isVisible = false;
		this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
	}
	_withResult(result) {
		this._messages = result;
		if (this._messages.length > 0) this._renderMessages(this._computer.lineNumber, this._messages);
		else this.hide();
	}
	_renderMessages(lineNumber, messages) {
		this._renderDisposeables.clear();
		const fragment = document.createDocumentFragment();
		for (const msg of messages) {
			const markdownHoverElement = $$4("div.hover-row.markdown-hover");
			const hoverContentsElement = append(markdownHoverElement, $$4("div.hover-contents"));
			const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
			hoverContentsElement.appendChild(renderedContents.element);
			fragment.appendChild(markdownHoverElement);
		}
		this._updateContents(fragment);
		this._showAt(lineNumber);
	}
	_updateContents(node) {
		this._hover.contentsDomNode.textContent = "";
		this._hover.contentsDomNode.appendChild(node);
		this._updateFont();
	}
	_showAt(lineNumber) {
		if (!this._isVisible) {
			this._isVisible = true;
			this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
		}
		const editorLayout = this._editor.getLayoutInfo();
		const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
		const editorScrollTop = this._editor.getScrollTop();
		const lineHeight = this._editor.getOption(61);
		const nodeHeight = this._hover.containerDomNode.clientHeight;
		const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
		this._hover.containerDomNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
		this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
	}
};
MarginHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";
var MarginHoverComputer = class {
	constructor(_editor) {
		this._editor = _editor;
		this._lineNumber = -1;
	}
	get lineNumber() {
		return this._lineNumber;
	}
	set lineNumber(value) {
		this._lineNumber = value;
	}
	computeSync() {
		const toHoverMessage = (contents) => {
			return { value: contents };
		};
		const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
		const result = [];
		if (!lineDecorations) return result;
		for (const d of lineDecorations) {
			if (!d.options.glyphMarginClassName) continue;
			const hoverMessage = d.options.glyphMarginHoverMessage;
			if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) continue;
			result.push(...asArray(hoverMessage).map(toHoverMessage));
		}
		return result;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/getHover.js
var __awaiter$37 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var HoverProviderResult = class {
	constructor(provider, hover, ordinal) {
		this.provider = provider;
		this.hover = hover;
		this.ordinal = ordinal;
	}
};
function executeProvider(provider, ordinal, model, position, token) {
	return __awaiter$37(this, void 0, void 0, function* () {
		try {
			const result = yield Promise.resolve(provider.provideHover(model, position, token));
			if (result && isValid(result)) return new HoverProviderResult(provider, result, ordinal);
		} catch (err) {
			onUnexpectedExternalError(err);
		}
	});
}
function getHover(registry, model, position, token) {
	const promises = registry.ordered(model).map((provider, index) => executeProvider(provider, index, model, position, token));
	return AsyncIterableObject.fromPromises(promises).coalesce();
}
function getHoverPromise(registry, model, position, token) {
	return getHover(registry, model, position, token).map((item) => item.hover).toPromise();
}
registerModelAndPositionCommand("_executeHoverProvider", (accessor, model, position) => {
	return getHoverPromise(accessor.get(ILanguageFeaturesService).hoverProvider, model, position, CancellationToken.None);
});
function isValid(result) {
	const hasRange = typeof result.range !== "undefined";
	const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
	return hasRange && hasHtmlContent;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
var __decorate$60 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$60 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var $$3 = $;
var MarkdownHover = class {
	constructor(owner, range, contents, ordinal) {
		this.owner = owner;
		this.range = range;
		this.contents = contents;
		this.ordinal = ordinal;
	}
	isValidForHoverAnchor(anchor) {
		return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
	}
};
var MarkdownHoverParticipant = class MarkdownHoverParticipant$1 {
	constructor(_editor, _languageService, _openerService, _configurationService, _languageFeaturesService) {
		this._editor = _editor;
		this._languageService = _languageService;
		this._openerService = _openerService;
		this._configurationService = _configurationService;
		this._languageFeaturesService = _languageFeaturesService;
		this.hoverOrdinal = 2;
	}
	createLoadingMessage(anchor) {
		return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))], 2e3);
	}
	computeSync(anchor, lineDecorations) {
		if (!this._editor.hasModel() || anchor.type !== 1) return [];
		const model = this._editor.getModel();
		const lineNumber = anchor.range.startLineNumber;
		const maxColumn = model.getLineMaxColumn(lineNumber);
		const result = [];
		let index = 1e3;
		const lineLength = model.getLineLength(lineNumber);
		const languageId = model.getLanguageIdAtPosition(anchor.range.startLineNumber, anchor.range.startColumn);
		const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", { overrideIdentifier: languageId });
		if (typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) result.push(new MarkdownHover(this, anchor.range, [{ value: localize("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.") }], index++));
		for (const d of lineDecorations) {
			const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
			const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
			const hoverMessage = d.options.hoverMessage;
			if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) continue;
			const range = new Range$1(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
			result.push(new MarkdownHover(this, range, asArray(hoverMessage), index++));
		}
		return result;
	}
	computeAsync(anchor, lineDecorations, token) {
		if (!this._editor.hasModel() || anchor.type !== 1) return AsyncIterableObject.EMPTY;
		const model = this._editor.getModel();
		if (!this._languageFeaturesService.hoverProvider.has(model)) return AsyncIterableObject.EMPTY;
		const position = new Position$1(anchor.range.startLineNumber, anchor.range.startColumn);
		return getHover(this._languageFeaturesService.hoverProvider, model, position, token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => {
			const rng = item.hover.range ? Range$1.lift(item.hover.range) : anchor.range;
			return new MarkdownHover(this, rng, item.hover.contents, item.ordinal);
		});
	}
	renderHoverParts(context, hoverParts) {
		return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
	}
};
MarkdownHoverParticipant = __decorate$60([
	__param$60(1, ILanguageService),
	__param$60(2, IOpenerService),
	__param$60(3, IConfigurationService),
	__param$60(4, ILanguageFeaturesService)
], MarkdownHoverParticipant);
function renderMarkdownHovers(context, hoverParts, editor$1, languageService, openerService) {
	hoverParts.sort((a, b) => a.ordinal - b.ordinal);
	const disposables = new DisposableStore();
	for (const hoverPart of hoverParts) for (const contents of hoverPart.contents) {
		if (isEmptyMarkdownString(contents)) continue;
		const markdownHoverElement = $$3("div.hover-row.markdown-hover");
		const hoverContentsElement = append(markdownHoverElement, $$3("div.hover-contents"));
		const renderer = disposables.add(new MarkdownRenderer({ editor: editor$1 }, languageService, openerService));
		disposables.add(renderer.onDidRenderAsync(() => {
			hoverContentsElement.className = "hover-contents code-hover-contents";
			context.onContentsChanged();
		}));
		const renderedContents = disposables.add(renderer.render(contents));
		hoverContentsElement.appendChild(renderedContents.element);
		context.fragment.appendChild(markdownHoverElement);
	}
	return disposables;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/markerNavigationService.js
var __decorate$59 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$59 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var MarkerCoordinate = class {
	constructor(marker, index, total) {
		this.marker = marker;
		this.index = index;
		this.total = total;
	}
};
var MarkerList = class MarkerList$1 {
	constructor(resourceFilter, _markerService, _configService) {
		this._markerService = _markerService;
		this._configService = _configService;
		this._onDidChange = new Emitter$1();
		this.onDidChange = this._onDidChange.event;
		this._dispoables = new DisposableStore();
		this._markers = [];
		this._nextIdx = -1;
		if (URI.isUri(resourceFilter)) this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
		else if (resourceFilter) this._resourceFilter = resourceFilter;
		const compareOrder = this._configService.getValue("problems.sortOrder");
		const compareMarker = (a, b) => {
			let res = compare(a.resource.toString(), b.resource.toString());
			if (res === 0) if (compareOrder === "position") res = Range$1.compareRangesUsingStarts(a, b) || MarkerSeverity$1.compare(a.severity, b.severity);
			else res = MarkerSeverity$1.compare(a.severity, b.severity) || Range$1.compareRangesUsingStarts(a, b);
			return res;
		};
		const updateMarker = () => {
			this._markers = this._markerService.read({
				resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
				severities: MarkerSeverity$1.Error | MarkerSeverity$1.Warning | MarkerSeverity$1.Info
			});
			if (typeof resourceFilter === "function") this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
			this._markers.sort(compareMarker);
		};
		updateMarker();
		this._dispoables.add(_markerService.onMarkerChanged((uris) => {
			if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
				updateMarker();
				this._nextIdx = -1;
				this._onDidChange.fire();
			}
		}));
	}
	dispose() {
		this._dispoables.dispose();
		this._onDidChange.dispose();
	}
	matches(uri) {
		if (!this._resourceFilter && !uri) return true;
		if (!this._resourceFilter || !uri) return false;
		return this._resourceFilter(uri);
	}
	get selected() {
		const marker = this._markers[this._nextIdx];
		return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
	}
	_initIdx(model, position, fwd) {
		let found = false;
		let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
		if (idx < 0) {
			idx = binarySearch(this._markers, { resource: model.uri }, (a, b) => compare(a.resource.toString(), b.resource.toString()));
			if (idx < 0) idx = ~idx;
		}
		for (let i = idx; i < this._markers.length; i++) {
			let range = Range$1.lift(this._markers[i]);
			if (range.isEmpty()) {
				const word = model.getWordAtPosition(range.getStartPosition());
				if (word) range = new Range$1(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
			}
			if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
				this._nextIdx = i;
				found = true;
				break;
			}
			if (this._markers[i].resource.toString() !== model.uri.toString()) break;
		}
		if (!found) this._nextIdx = fwd ? 0 : this._markers.length - 1;
		if (this._nextIdx < 0) this._nextIdx = this._markers.length - 1;
	}
	resetIndex() {
		this._nextIdx = -1;
	}
	move(fwd, model, position) {
		if (this._markers.length === 0) return false;
		const oldIdx = this._nextIdx;
		if (this._nextIdx === -1) this._initIdx(model, position, fwd);
		else if (fwd) this._nextIdx = (this._nextIdx + 1) % this._markers.length;
		else if (!fwd) this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
		if (oldIdx !== this._nextIdx) return true;
		return false;
	}
	find(uri, position) {
		let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
		if (idx < 0) return;
		for (; idx < this._markers.length; idx++) if (Range$1.containsPosition(this._markers[idx], position)) return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
	}
};
MarkerList = __decorate$59([__param$59(1, IMarkerService), __param$59(2, IConfigurationService)], MarkerList);
const IMarkerNavigationService = createDecorator("IMarkerNavigationService");
var MarkerNavigationService = class MarkerNavigationService$1 {
	constructor(_markerService, _configService) {
		this._markerService = _markerService;
		this._configService = _configService;
		this._provider = new LinkedList();
	}
	getMarkerList(resource) {
		for (const provider of this._provider) {
			const result = provider.getMarkerList(resource);
			if (result) return result;
		}
		return new MarkerList(resource, this._markerService, this._configService);
	}
};
MarkerNavigationService = __decorate$59([__param$59(0, IMarkerService), __param$59(1, IConfigurationService)], MarkerNavigationService);
registerSingleton(IMarkerNavigationService, MarkerNavigationService, true);

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js
var SeverityIcon;
(function(SeverityIcon$1) {
	function className(severity) {
		switch (severity) {
			case severity_default.Ignore: return "severity-ignore " + Codicon.info.classNames;
			case severity_default.Info: return Codicon.info.classNames;
			case severity_default.Warning: return Codicon.warning.classNames;
			case severity_default.Error: return Codicon.error.classNames;
			default: return "";
		}
	}
	SeverityIcon$1.className = className;
})(SeverityIcon || (SeverityIcon = {}));
registerThemingParticipant((theme, collector) => {
	const errorIconForeground = theme.getColor(problemsErrorIconForeground);
	if (errorIconForeground) {
		const errorCodiconSelector = Codicon.error.cssSelector;
		collector.addRule(`
			.monaco-editor .zone-widget ${errorCodiconSelector},
			.markers-panel .marker-icon${errorCodiconSelector},
			.text-search-provider-messages .providerMessage ${errorCodiconSelector},
			.extensions-viewlet > .extensions ${errorCodiconSelector} {
				color: ${errorIconForeground};
			}
		`);
	}
	const warningIconForeground = theme.getColor(problemsWarningIconForeground);
	if (warningIconForeground) {
		const warningCodiconSelector = Codicon.warning.cssSelector;
		collector.addRule(`
			.monaco-editor .zone-widget ${warningCodiconSelector},
			.markers-panel .marker-icon${warningCodiconSelector},
			.extensions-viewlet > .extensions ${warningCodiconSelector},
			.extension-editor ${warningCodiconSelector},
			.text-search-provider-messages .providerMessage ${warningCodiconSelector},
			.preferences-editor ${warningCodiconSelector} {
				color: ${warningIconForeground};
			}
		`);
	}
	const infoIconForeground = theme.getColor(problemsInfoIconForeground);
	if (infoIconForeground) {
		const infoCodiconSelector = Codicon.info.cssSelector;
		collector.addRule(`
			.monaco-editor .zone-widget ${infoCodiconSelector},
			.markers-panel .marker-icon${infoCodiconSelector},
			.extensions-viewlet > .extensions ${infoCodiconSelector},
			.text-search-provider-messages .providerMessage ${infoCodiconSelector},
			.extension-editor ${infoCodiconSelector} {
				color: ${infoIconForeground};
			}
		`);
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
var __decorate$58 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$58 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var MessageWidget = class {
	constructor(parent, editor$1, onRelatedInformation, _openerService, _labelService) {
		this._openerService = _openerService;
		this._labelService = _labelService;
		this._lines = 0;
		this._longestLineLength = 0;
		this._relatedDiagnostics = /* @__PURE__ */ new WeakMap();
		this._disposables = new DisposableStore();
		this._editor = editor$1;
		const domNode = document.createElement("div");
		domNode.className = "descriptioncontainer";
		this._messageBlock = document.createElement("div");
		this._messageBlock.classList.add("message");
		this._messageBlock.setAttribute("aria-live", "assertive");
		this._messageBlock.setAttribute("role", "alert");
		domNode.appendChild(this._messageBlock);
		this._relatedBlock = document.createElement("div");
		domNode.appendChild(this._relatedBlock);
		this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
			event.preventDefault();
			const related = this._relatedDiagnostics.get(event.target);
			if (related) onRelatedInformation(related);
		}));
		this._scrollable = new ScrollableElement(domNode, {
			horizontal: 1,
			vertical: 1,
			useShadows: false,
			horizontalScrollbarSize: 6,
			verticalScrollbarSize: 6
		});
		parent.appendChild(this._scrollable.getDomNode());
		this._disposables.add(this._scrollable.onScroll((e) => {
			domNode.style.left = `-${e.scrollLeft}px`;
			domNode.style.top = `-${e.scrollTop}px`;
		}));
		this._disposables.add(this._scrollable);
	}
	dispose() {
		dispose(this._disposables);
	}
	update(marker) {
		const { source, message, relatedInformation, code } = marker;
		let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + 2;
		if (code) if (typeof code === "string") sourceAndCodeLength += code.length;
		else sourceAndCodeLength += code.value.length;
		const lines = splitLines(message);
		this._lines = lines.length;
		this._longestLineLength = 0;
		for (const line of lines) this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
		clearNode(this._messageBlock);
		this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
		this._editor.applyFontInfo(this._messageBlock);
		let lastLineElement = this._messageBlock;
		for (const line of lines) {
			lastLineElement = document.createElement("div");
			lastLineElement.innerText = line;
			if (line === "") lastLineElement.style.height = this._messageBlock.style.lineHeight;
			this._messageBlock.appendChild(lastLineElement);
		}
		if (source || code) {
			const detailsElement = document.createElement("span");
			detailsElement.classList.add("details");
			lastLineElement.appendChild(detailsElement);
			if (source) {
				const sourceElement = document.createElement("span");
				sourceElement.innerText = source;
				sourceElement.classList.add("source");
				detailsElement.appendChild(sourceElement);
			}
			if (code) if (typeof code === "string") {
				const codeElement = document.createElement("span");
				codeElement.innerText = `(${code})`;
				codeElement.classList.add("code");
				detailsElement.appendChild(codeElement);
			} else {
				this._codeLink = $("a.code-link");
				this._codeLink.setAttribute("href", `${code.target.toString()}`);
				this._codeLink.onclick = (e) => {
					this._openerService.open(code.target, { allowCommands: true });
					e.preventDefault();
					e.stopPropagation();
				};
				const codeElement = append(this._codeLink, $("span"));
				codeElement.innerText = code.value;
				detailsElement.appendChild(this._codeLink);
			}
		}
		clearNode(this._relatedBlock);
		this._editor.applyFontInfo(this._relatedBlock);
		if (isNonEmptyArray(relatedInformation)) {
			const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
			relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(61) * .66)}px`;
			this._lines += 1;
			for (const related of relatedInformation) {
				const container = document.createElement("div");
				const relatedResource = document.createElement("a");
				relatedResource.classList.add("filename");
				relatedResource.innerText = `${this._labelService.getUriBasenameLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
				relatedResource.title = this._labelService.getUriLabel(related.resource);
				this._relatedDiagnostics.set(relatedResource, related);
				const relatedMessage = document.createElement("span");
				relatedMessage.innerText = related.message;
				container.appendChild(relatedResource);
				container.appendChild(relatedMessage);
				this._lines += 1;
				relatedInformationNode.appendChild(container);
			}
		}
		const fontInfo = this._editor.getOption(46);
		const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * .75);
		const scrollHeight = fontInfo.lineHeight * this._lines;
		this._scrollable.setScrollDimensions({
			scrollWidth,
			scrollHeight
		});
	}
	layout(height, width) {
		this._scrollable.getDomNode().style.height = `${height}px`;
		this._scrollable.getDomNode().style.width = `${width}px`;
		this._scrollable.setScrollDimensions({
			width,
			height
		});
	}
	getHeightInLines() {
		return Math.min(17, this._lines);
	}
	getAriaLabel(marker) {
		let severityLabel = "";
		switch (marker.severity) {
			case MarkerSeverity$1.Error:
				severityLabel = localize("Error", "Error");
				break;
			case MarkerSeverity$1.Warning:
				severityLabel = localize("Warning", "Warning");
				break;
			case MarkerSeverity$1.Info:
				severityLabel = localize("Info", "Info");
				break;
			case MarkerSeverity$1.Hint:
				severityLabel = localize("Hint", "Hint");
				break;
		}
		let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
		const model = this._editor.getModel();
		if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) ariaLabel = `${model.getLineContent(marker.startLineNumber)}, ${ariaLabel}`;
		return ariaLabel;
	}
};
var MarkerNavigationWidget = class MarkerNavigationWidget$1 extends PeekViewWidget {
	constructor(editor$1, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
		super(editor$1, {
			showArrow: true,
			showFrame: true,
			isAccessible: true,
			frameWidth: 1
		}, instantiationService);
		this._themeService = _themeService;
		this._openerService = _openerService;
		this._menuService = _menuService;
		this._contextKeyService = _contextKeyService;
		this._labelService = _labelService;
		this._callOnDispose = new DisposableStore();
		this._onDidSelectRelatedInformation = new Emitter$1();
		this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
		this._severity = MarkerSeverity$1.Warning;
		this._backgroundColor = Color.white;
		this._applyTheme(_themeService.getColorTheme());
		this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
		this.create();
	}
	_applyTheme(theme) {
		this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
		let colorId = editorMarkerNavigationError;
		let headerBackground = editorMarkerNavigationErrorHeader;
		if (this._severity === MarkerSeverity$1.Warning) {
			colorId = editorMarkerNavigationWarning;
			headerBackground = editorMarkerNavigationWarningHeader;
		} else if (this._severity === MarkerSeverity$1.Info) {
			colorId = editorMarkerNavigationInfo;
			headerBackground = editorMarkerNavigationInfoHeader;
		}
		const frameColor = theme.getColor(colorId);
		const headerBg = theme.getColor(headerBackground);
		this.style({
			arrowColor: frameColor,
			frameColor,
			headerBackgroundColor: headerBg,
			primaryHeadingColor: theme.getColor(peekViewTitleForeground),
			secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
		});
	}
	_applyStyles() {
		if (this._parentContainer) this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
		super._applyStyles();
	}
	dispose() {
		this._callOnDispose.dispose();
		super.dispose();
	}
	_fillHead(container) {
		super._fillHead(container);
		this._disposables.add(this._actionbarWidget.actionRunner.onBeforeRun((e) => this.editor.focus()));
		const actions = [];
		const menu = this._menuService.createMenu(MarkerNavigationWidget$1.TitleMenu, this._contextKeyService);
		createAndFillInActionBarActions(menu, void 0, actions);
		this._actionbarWidget.push(actions, {
			label: false,
			icon: true,
			index: 0
		});
		menu.dispose();
	}
	_fillTitleIcon(container) {
		this._icon = append(container, $(""));
	}
	_fillBody(container) {
		this._parentContainer = container;
		container.classList.add("marker-widget");
		this._parentContainer.tabIndex = 0;
		this._parentContainer.setAttribute("role", "tooltip");
		this._container = document.createElement("div");
		container.appendChild(this._container);
		this._message = new MessageWidget(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
		this._disposables.add(this._message);
	}
	show() {
		throw new Error("call showAtMarker");
	}
	showAtMarker(marker, markerIdx, markerCount) {
		this._container.classList.remove("stale");
		this._message.update(marker);
		this._severity = marker.severity;
		this._applyTheme(this._themeService.getColorTheme());
		const range = Range$1.lift(marker);
		const editorPosition = this.editor.getPosition();
		const position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
		super.show(position, this.computeRequiredHeight());
		const model = this.editor.getModel();
		if (model) {
			const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
			this.setTitle(basename(model.uri), detail);
		}
		this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity$1.toSeverity(this._severity))}`;
		this.editor.revealPositionNearTop(position, 0);
		this.editor.focus();
	}
	updateMarker(marker) {
		this._container.classList.remove("stale");
		this._message.update(marker);
	}
	showStale() {
		this._container.classList.add("stale");
		this._relayout();
	}
	_doLayoutBody(heightInPixel, widthInPixel) {
		super._doLayoutBody(heightInPixel, widthInPixel);
		this._heightInPixel = heightInPixel;
		this._message.layout(heightInPixel, widthInPixel);
		this._container.style.height = `${heightInPixel}px`;
	}
	_onWidth(widthInPixel) {
		this._message.layout(this._heightInPixel, widthInPixel);
	}
	_relayout() {
		super._relayout(this.computeRequiredHeight());
	}
	computeRequiredHeight() {
		return 3 + this._message.getHeightInLines();
	}
};
MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
MarkerNavigationWidget = __decorate$58([
	__param$58(1, IThemeService),
	__param$58(2, IOpenerService),
	__param$58(3, IMenuService),
	__param$58(4, IInstantiationService),
	__param$58(5, IContextKeyService),
	__param$58(6, ILabelService)
], MarkerNavigationWidget);
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
const editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", {
	dark: errorDefault,
	light: errorDefault,
	hcDark: contrastBorder,
	hcLight: contrastBorder
}, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
const editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", {
	dark: transparent(editorMarkerNavigationError, .1),
	light: transparent(editorMarkerNavigationError, .1),
	hcDark: null,
	hcLight: null
}, localize("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background."));
const editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", {
	dark: warningDefault,
	light: warningDefault,
	hcDark: contrastBorder,
	hcLight: contrastBorder
}, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
const editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", {
	dark: transparent(editorMarkerNavigationWarning, .1),
	light: transparent(editorMarkerNavigationWarning, .1),
	hcDark: "#0C141F",
	hcLight: transparent(editorMarkerNavigationWarning, .2)
}, localize("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background."));
const editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", {
	dark: infoDefault,
	light: infoDefault,
	hcDark: contrastBorder,
	hcLight: contrastBorder
}, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
const editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", {
	dark: transparent(editorMarkerNavigationInfo, .1),
	light: transparent(editorMarkerNavigationInfo, .1),
	hcDark: null,
	hcLight: null
}, localize("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background."));
const editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", {
	dark: editorBackground,
	light: editorBackground,
	hcDark: editorBackground,
	hcLight: editorBackground
}, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
var __decorate$57 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$57 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$36 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var MarkerController = class MarkerController$1 {
	constructor(editor$1, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
		this._markerNavigationService = _markerNavigationService;
		this._contextKeyService = _contextKeyService;
		this._editorService = _editorService;
		this._instantiationService = _instantiationService;
		this._sessionDispoables = new DisposableStore();
		this._editor = editor$1;
		this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
	}
	static get(editor$1) {
		return editor$1.getContribution(MarkerController$1.ID);
	}
	dispose() {
		this._cleanUp();
		this._sessionDispoables.dispose();
	}
	_cleanUp() {
		this._widgetVisible.reset();
		this._sessionDispoables.clear();
		this._widget = void 0;
		this._model = void 0;
	}
	_getOrCreateModel(uri) {
		if (this._model && this._model.matches(uri)) return this._model;
		let reusePosition = false;
		if (this._model) {
			reusePosition = true;
			this._cleanUp();
		}
		this._model = this._markerNavigationService.getMarkerList(uri);
		if (reusePosition) this._model.move(true, this._editor.getModel(), this._editor.getPosition());
		this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
		this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
		this._widgetVisible.set(true);
		this._sessionDispoables.add(this._model);
		this._sessionDispoables.add(this._widget);
		this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
			var _a$5, _b$1, _c$1;
			if (!((_a$5 = this._model) === null || _a$5 === void 0 ? void 0 : _a$5.selected) || !Range$1.containsPosition((_b$1 = this._model) === null || _b$1 === void 0 ? void 0 : _b$1.selected.marker, e.position)) (_c$1 = this._model) === null || _c$1 === void 0 || _c$1.resetIndex();
		}));
		this._sessionDispoables.add(this._model.onDidChange(() => {
			if (!this._widget || !this._widget.position || !this._model) return;
			const info = this._model.find(this._editor.getModel().uri, this._widget.position);
			if (info) this._widget.updateMarker(info.marker);
			else this._widget.showStale();
		}));
		this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
			this._editorService.openCodeEditor({
				resource: related.resource,
				options: {
					pinned: true,
					revealIfOpened: true,
					selection: Range$1.lift(related).collapseToStart()
				}
			}, this._editor);
			this.close(false);
		}));
		this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
		return this._model;
	}
	close(focusEditor = true) {
		this._cleanUp();
		if (focusEditor) this._editor.focus();
	}
	showAtMarker(marker) {
		if (this._editor.hasModel()) {
			const model = this._getOrCreateModel(this._editor.getModel().uri);
			model.resetIndex();
			model.move(true, this._editor.getModel(), new Position$1(marker.startLineNumber, marker.startColumn));
			if (model.selected) this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
		}
	}
	nagivate(next, multiFile) {
		var _a$5, _b$1;
		return __awaiter$36(this, void 0, void 0, function* () {
			if (this._editor.hasModel()) {
				const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
				model.move(next, this._editor.getModel(), this._editor.getPosition());
				if (!model.selected) return;
				if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
					this._cleanUp();
					const otherEditor = yield this._editorService.openCodeEditor({
						resource: model.selected.marker.resource,
						options: {
							pinned: false,
							revealIfOpened: true,
							selectionRevealType: 2,
							selection: model.selected.marker
						}
					}, this._editor);
					if (otherEditor) {
						(_a$5 = MarkerController$1.get(otherEditor)) === null || _a$5 === void 0 || _a$5.close();
						(_b$1 = MarkerController$1.get(otherEditor)) === null || _b$1 === void 0 || _b$1.nagivate(next, multiFile);
					}
				} else this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
			}
		});
	}
};
MarkerController.ID = "editor.contrib.markerController";
MarkerController = __decorate$57([
	__param$57(1, IMarkerNavigationService),
	__param$57(2, IContextKeyService),
	__param$57(3, ICodeEditorService),
	__param$57(4, IInstantiationService)
], MarkerController);
var MarkerNavigationAction = class extends EditorAction {
	constructor(_next, _multiFile, opts) {
		super(opts);
		this._next = _next;
		this._multiFile = _multiFile;
	}
	run(_accessor, editor$1) {
		var _a$5;
		return __awaiter$36(this, void 0, void 0, function* () {
			if (editor$1.hasModel()) (_a$5 = MarkerController.get(editor$1)) === null || _a$5 === void 0 || _a$5.nagivate(this._next, this._multiFile);
		});
	}
};
var NextMarkerAction = class NextMarkerAction extends MarkerNavigationAction {
	constructor() {
		super(true, false, {
			id: NextMarkerAction.ID,
			label: NextMarkerAction.LABEL,
			alias: "Go to Next Problem (Error, Warning, Info)",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 578,
				weight: 100
			},
			menuOpts: {
				menuId: MarkerNavigationWidget.TitleMenu,
				title: NextMarkerAction.LABEL,
				icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize("nextMarkerIcon", "Icon for goto next marker.")),
				group: "navigation",
				order: 1
			}
		});
	}
};
NextMarkerAction.ID = "editor.action.marker.next";
NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
var PrevMarkerAction = class PrevMarkerAction extends MarkerNavigationAction {
	constructor() {
		super(false, false, {
			id: PrevMarkerAction.ID,
			label: PrevMarkerAction.LABEL,
			alias: "Go to Previous Problem (Error, Warning, Info)",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 1602,
				weight: 100
			},
			menuOpts: {
				menuId: MarkerNavigationWidget.TitleMenu,
				title: PrevMarkerAction.LABEL,
				icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize("previousMarkerIcon", "Icon for goto previous marker.")),
				group: "navigation",
				order: 2
			}
		});
	}
};
PrevMarkerAction.ID = "editor.action.marker.prev";
PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
var NextMarkerInFilesAction = class extends MarkerNavigationAction {
	constructor() {
		super(true, true, {
			id: "editor.action.marker.nextInFiles",
			label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
			alias: "Go to Next Problem in Files (Error, Warning, Info)",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 66,
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarGoMenu,
				title: localize({
					key: "miGotoNextProblem",
					comment: ["&& denotes a mnemonic"]
				}, "Next &&Problem"),
				group: "6_problem_nav",
				order: 1
			}
		});
	}
};
var PrevMarkerInFilesAction = class extends MarkerNavigationAction {
	constructor() {
		super(false, true, {
			id: "editor.action.marker.prevInFiles",
			label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
			alias: "Go to Previous Problem in Files (Error, Warning, Info)",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 1090,
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarGoMenu,
				title: localize({
					key: "miGotoPreviousProblem",
					comment: ["&& denotes a mnemonic"]
				}, "Previous &&Problem"),
				group: "6_problem_nav",
				order: 2
			}
		});
	}
};
registerEditorContribution(MarkerController.ID, MarkerController);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
registerEditorCommand(new (EditorCommand.bindToContribution(MarkerController.get))({
	id: "closeMarkersNavigation",
	precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
	handler: (x) => x.close(),
	kbOpts: {
		weight: 150,
		kbExpr: EditorContextKeys.focus,
		primary: 9,
		secondary: [1033]
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markerHoverParticipant.js
var __decorate$56 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$56 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var $$2 = $;
var MarkerHover = class {
	constructor(owner, range, marker) {
		this.owner = owner;
		this.range = range;
		this.marker = marker;
	}
	isValidForHoverAnchor(anchor) {
		return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
	}
};
var markerCodeActionTrigger = {
	type: 1,
	filter: { include: CodeActionKind.QuickFix },
	triggerAction: CodeActionTriggerSource.QuickFixHover
};
var MarkerHoverParticipant = class MarkerHoverParticipant$1 {
	constructor(_editor, _markerDecorationsService, _openerService, _languageFeaturesService) {
		this._editor = _editor;
		this._markerDecorationsService = _markerDecorationsService;
		this._openerService = _openerService;
		this._languageFeaturesService = _languageFeaturesService;
		this.hoverOrdinal = 5;
		this.recentMarkerCodeActionsInfo = void 0;
	}
	computeSync(anchor, lineDecorations) {
		if (!this._editor.hasModel() || anchor.type !== 1) return [];
		const model = this._editor.getModel();
		const lineNumber = anchor.range.startLineNumber;
		const maxColumn = model.getLineMaxColumn(lineNumber);
		const result = [];
		for (const d of lineDecorations) {
			const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
			const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
			const marker = this._markerDecorationsService.getMarker(model.uri, d);
			if (!marker) continue;
			const range = new Range$1(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
			result.push(new MarkerHover(this, range, marker));
		}
		return result;
	}
	renderHoverParts(context, hoverParts) {
		if (!hoverParts.length) return Disposable.None;
		const disposables = new DisposableStore();
		hoverParts.forEach((msg) => context.fragment.appendChild(this.renderMarkerHover(msg, disposables)));
		const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity$1.compare(a.marker.severity, b.marker.severity))[0];
		this.renderMarkerStatusbar(context, markerHoverForStatusbar, disposables);
		return disposables;
	}
	renderMarkerHover(markerHover, disposables) {
		const hoverElement = $$2("div.hover-row");
		const markerElement = append(hoverElement, $$2("div.marker.hover-contents"));
		const { source, message, code, relatedInformation } = markerHover.marker;
		this._editor.applyFontInfo(markerElement);
		const messageElement = append(markerElement, $$2("span"));
		messageElement.style.whiteSpace = "pre-wrap";
		messageElement.innerText = message;
		if (source || code) if (code && typeof code !== "string") {
			const sourceAndCodeElement = $$2("span");
			if (source) {
				const sourceElement = append(sourceAndCodeElement, $$2("span"));
				sourceElement.innerText = source;
			}
			const codeLink = append(sourceAndCodeElement, $$2("a.code-link"));
			codeLink.setAttribute("href", code.target.toString());
			disposables.add(addDisposableListener(codeLink, "click", (e) => {
				this._openerService.open(code.target, { allowCommands: true });
				e.preventDefault();
				e.stopPropagation();
			}));
			const codeElement = append(codeLink, $$2("span"));
			codeElement.innerText = code.value;
			const detailsElement = append(markerElement, sourceAndCodeElement);
			detailsElement.style.opacity = "0.6";
			detailsElement.style.paddingLeft = "6px";
		} else {
			const detailsElement = append(markerElement, $$2("span"));
			detailsElement.style.opacity = "0.6";
			detailsElement.style.paddingLeft = "6px";
			detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
		}
		if (isNonEmptyArray(relatedInformation)) for (const { message: message$1, resource, startLineNumber, startColumn } of relatedInformation) {
			const relatedInfoContainer = append(markerElement, $$2("div"));
			relatedInfoContainer.style.marginTop = "8px";
			const a = append(relatedInfoContainer, $$2("a"));
			a.innerText = `${basename(resource)}(${startLineNumber}, ${startColumn}): `;
			a.style.cursor = "pointer";
			disposables.add(addDisposableListener(a, "click", (e) => {
				e.stopPropagation();
				e.preventDefault();
				if (this._openerService) this._openerService.open(resource, {
					fromUserGesture: true,
					editorOptions: { selection: {
						startLineNumber,
						startColumn
					} }
				}).catch(onUnexpectedError);
			}));
			const messageElement$1 = append(relatedInfoContainer, $$2("span"));
			messageElement$1.innerText = message$1;
			this._editor.applyFontInfo(messageElement$1);
		}
		return hoverElement;
	}
	renderMarkerStatusbar(context, markerHover, disposables) {
		if (markerHover.marker.severity === MarkerSeverity$1.Error || markerHover.marker.severity === MarkerSeverity$1.Warning || markerHover.marker.severity === MarkerSeverity$1.Info) context.statusBar.addAction({
			label: localize("view problem", "View Problem"),
			commandId: NextMarkerAction.ID,
			run: () => {
				var _a$5;
				context.hide();
				(_a$5 = MarkerController.get(this._editor)) === null || _a$5 === void 0 || _a$5.showAtMarker(markerHover.marker);
				this._editor.focus();
			}
		});
		if (!this._editor.getOption(83)) {
			const quickfixPlaceholderElement = context.statusBar.append($$2("div"));
			if (this.recentMarkerCodeActionsInfo) if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
				if (!this.recentMarkerCodeActionsInfo.hasCodeActions) quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
			} else this.recentMarkerCodeActionsInfo = void 0;
			const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes..."), 200));
			if (!quickfixPlaceholderElement.textContent) quickfixPlaceholderElement.textContent = String.fromCharCode(160);
			const codeActionsPromise = this.getCodeActions(markerHover.marker);
			disposables.add(toDisposable(() => codeActionsPromise.cancel()));
			codeActionsPromise.then((actions) => {
				updatePlaceholderDisposable.dispose();
				this.recentMarkerCodeActionsInfo = {
					marker: markerHover.marker,
					hasCodeActions: actions.validActions.length > 0
				};
				if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
					actions.dispose();
					quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
					return;
				}
				quickfixPlaceholderElement.style.display = "none";
				let showing = false;
				disposables.add(toDisposable(() => {
					if (!showing) actions.dispose();
				}));
				context.statusBar.addAction({
					label: localize("quick fixes", "Quick Fix..."),
					commandId: QuickFixAction.Id,
					run: (target) => {
						showing = true;
						const controller = QuickFixController.get(this._editor);
						const elementPosition = getDomNodePagePosition(target);
						context.hide();
						controller === null || controller === void 0 || controller.showCodeActions(markerCodeActionTrigger, actions, {
							x: elementPosition.left + 6,
							y: elementPosition.top + elementPosition.height + 6,
							width: elementPosition.width,
							height: elementPosition.height
						});
					}
				});
			}, onUnexpectedError);
		}
	}
	getCodeActions(marker) {
		return createCancelablePromise((cancellationToken) => {
			return getCodeActions(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new Range$1(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
		});
	}
};
MarkerHoverParticipant = __decorate$56([
	__param$56(1, IMarkerDecorationsService),
	__param$56(2, IOpenerService),
	__param$56(3, ILanguageFeaturesService)
], MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
	const linkFg = theme.getColor(textLinkForeground);
	if (linkFg) collector.addRule(`.monaco-hover .hover-contents a.code-link span { color: ${linkFg}; }`);
	const activeLinkFg = theme.getColor(textLinkActiveForeground);
	if (activeLinkFg) collector.addRule(`.monaco-hover .hover-contents a.code-link span:hover { color: ${activeLinkFg}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
var __decorate$55 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$55 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var ModesHoverController = class ModesHoverController$1 {
	constructor(_editor, _instantiationService, _openerService, _languageService, _contextKeyService) {
		this._editor = _editor;
		this._instantiationService = _instantiationService;
		this._openerService = _openerService;
		this._languageService = _languageService;
		this._toUnhook = new DisposableStore();
		this._isMouseDown = false;
		this._hoverClicked = false;
		this._contentWidget = null;
		this._glyphWidget = null;
		this._hookEvents();
		this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(55)) {
				this._unhookEvents();
				this._hookEvents();
			}
		});
	}
	static get(editor$1) {
		return editor$1.getContribution(ModesHoverController$1.ID);
	}
	_hookEvents() {
		const hideWidgetsEventHandler = () => this._hideWidgets();
		const hoverOpts = this._editor.getOption(55);
		this._isHoverEnabled = hoverOpts.enabled;
		this._isHoverSticky = hoverOpts.sticky;
		if (this._isHoverEnabled) {
			this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
			this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
			this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
			this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
		} else {
			this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
			this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
		}
		this._toUnhook.add(this._editor.onMouseLeave((e) => this._onEditorMouseLeave(e)));
		this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
		this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
	}
	_unhookEvents() {
		this._toUnhook.clear();
	}
	_onEditorScrollChanged(e) {
		if (e.scrollTopChanged || e.scrollLeftChanged) this._hideWidgets();
	}
	_onEditorMouseDown(mouseEvent) {
		this._isMouseDown = true;
		const target = mouseEvent.target;
		if (target.type === 9 && target.detail === ContentHoverWidget.ID) {
			this._hoverClicked = true;
			return;
		}
		if (target.type === 12 && target.detail === MarginHoverWidget.ID) return;
		if (target.type !== 12) this._hoverClicked = false;
		this._hideWidgets();
	}
	_onEditorMouseUp(mouseEvent) {
		this._isMouseDown = false;
	}
	_onEditorMouseLeave(mouseEvent) {
		var _a$5;
		const targetEm = mouseEvent.event.browserEvent.relatedTarget;
		if ((_a$5 = this._contentWidget) === null || _a$5 === void 0 ? void 0 : _a$5.containsNode(targetEm)) return;
		this._hideWidgets();
	}
	_onEditorMouseMove(mouseEvent) {
		var _a$5, _b$1, _c$1, _d$1, _e$1;
		const target = mouseEvent.target;
		if (this._isMouseDown && this._hoverClicked) return;
		if (this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID) return;
		if (this._isHoverSticky && !((_b$1 = (_a$5 = mouseEvent.event.browserEvent.view) === null || _a$5 === void 0 ? void 0 : _a$5.getSelection()) === null || _b$1 === void 0 ? void 0 : _b$1.isCollapsed)) return;
		if (!this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID && ((_c$1 = this._contentWidget) === null || _c$1 === void 0 ? void 0 : _c$1.isColorPickerVisible())) return;
		if (this._isHoverSticky && target.type === 12 && target.detail === MarginHoverWidget.ID) return;
		if (!this._isHoverEnabled) {
			this._hideWidgets();
			return;
		}
		if (this._getOrCreateContentWidget().maybeShowAt(mouseEvent)) {
			(_d$1 = this._glyphWidget) === null || _d$1 === void 0 || _d$1.hide();
			return;
		}
		if (target.type === 2 && target.position) {
			(_e$1 = this._contentWidget) === null || _e$1 === void 0 || _e$1.hide();
			if (!this._glyphWidget) this._glyphWidget = new MarginHoverWidget(this._editor, this._languageService, this._openerService);
			this._glyphWidget.startShowingAt(target.position.lineNumber);
			return;
		}
		this._hideWidgets();
	}
	_onKeyDown(e) {
		if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4) this._hideWidgets();
	}
	_hideWidgets() {
		var _a$5, _b$1, _c$1;
		if (this._isMouseDown && this._hoverClicked && ((_a$5 = this._contentWidget) === null || _a$5 === void 0 ? void 0 : _a$5.isColorPickerVisible())) return;
		this._hoverClicked = false;
		(_b$1 = this._glyphWidget) === null || _b$1 === void 0 || _b$1.hide();
		(_c$1 = this._contentWidget) === null || _c$1 === void 0 || _c$1.hide();
	}
	_getOrCreateContentWidget() {
		if (!this._contentWidget) this._contentWidget = this._instantiationService.createInstance(ContentHoverController, this._editor);
		return this._contentWidget;
	}
	isColorPickerVisible() {
		var _a$5;
		return ((_a$5 = this._contentWidget) === null || _a$5 === void 0 ? void 0 : _a$5.isColorPickerVisible()) || false;
	}
	showContentHover(range, mode, focus) {
		this._getOrCreateContentWidget().startShowingAtRange(range, mode, focus);
	}
	dispose() {
		var _a$5, _b$1;
		this._unhookEvents();
		this._toUnhook.dispose();
		this._didChangeConfigurationHandler.dispose();
		(_a$5 = this._glyphWidget) === null || _a$5 === void 0 || _a$5.dispose();
		(_b$1 = this._contentWidget) === null || _b$1 === void 0 || _b$1.dispose();
	}
};
ModesHoverController.ID = "editor.contrib.hover";
ModesHoverController = __decorate$55([
	__param$55(1, IInstantiationService),
	__param$55(2, IOpenerService),
	__param$55(3, ILanguageService),
	__param$55(4, IContextKeyService)
], ModesHoverController);
var ShowHoverAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.showHover",
			label: localize({
				key: "showHover",
				comment: ["Label for action that will trigger the showing of a hover in the editor.", "This allows for users to show the hover without using the mouse."]
			}, "Show Hover"),
			alias: "Show Hover",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2087),
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const controller = ModesHoverController.get(editor$1);
		if (!controller) return;
		const position = editor$1.getPosition();
		const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
		const focus = editor$1.getOption(2) === 2;
		controller.showContentHover(range, 1, focus);
	}
};
var ShowDefinitionPreviewHoverAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.showDefinitionPreviewHover",
			label: localize({
				key: "showDefinitionPreviewHover",
				comment: ["Label for action that will trigger the showing of definition preview hover in the editor.", "This allows for users to show the definition preview hover without using the mouse."]
			}, "Show Definition Preview Hover"),
			alias: "Show Definition Preview Hover",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		const controller = ModesHoverController.get(editor$1);
		if (!controller) return;
		const position = editor$1.getPosition();
		if (!position) return;
		const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
		const goto = GotoDefinitionAtPositionEditorContribution.get(editor$1);
		if (!goto) return;
		goto.startFindDefinitionFromCursor(position).then(() => {
			controller.showContentHover(range, 1, true);
		});
	}
};
registerEditorContribution(ModesHoverController.ID, ModesHoverController);
registerEditorAction(ShowHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
HoverParticipantRegistry.register(MarkdownHoverParticipant);
HoverParticipantRegistry.register(MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
	const editorHoverHighlightColor = theme.getColor(editorHoverHighlight);
	if (editorHoverHighlightColor) collector.addRule(`.monaco-editor .hoverHighlight { background-color: ${editorHoverHighlightColor}; }`);
	const hoverBackground = theme.getColor(editorHoverBackground);
	if (hoverBackground) collector.addRule(`.monaco-editor .monaco-hover { background-color: ${hoverBackground}; }`);
	const hoverBorder = theme.getColor(editorHoverBorder);
	if (hoverBorder) {
		collector.addRule(`.monaco-editor .monaco-hover { border: 1px solid ${hoverBorder}; }`);
		collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(.5)}; }`);
		collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(.5)}; }`);
		collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(.5)}; }`);
	}
	const link = theme.getColor(textLinkForeground);
	if (link) collector.addRule(`.monaco-editor .monaco-hover a { color: ${link}; }`);
	const linkHover = theme.getColor(textLinkActiveForeground);
	if (linkHover) collector.addRule(`.monaco-editor .monaco-hover a:hover { color: ${linkHover}; }`);
	const hoverForeground = theme.getColor(editorHoverForeground);
	if (hoverForeground) collector.addRule(`.monaco-editor .monaco-hover { color: ${hoverForeground}; }`);
	const actionsBackground = theme.getColor(editorHoverStatusBarBackground);
	if (actionsBackground) collector.addRule(`.monaco-editor .monaco-hover .hover-row .actions { background-color: ${actionsBackground}; }`);
	const codeBackground = theme.getColor(textCodeBlockBackground);
	if (codeBackground) collector.addRule(`.monaco-editor .monaco-hover code { background-color: ${codeBackground}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorContributions.js
var ColorContribution = class extends Disposable {
	constructor(_editor) {
		super();
		this._editor = _editor;
		this._register(_editor.onMouseDown((e) => this.onMouseDown(e)));
	}
	dispose() {
		super.dispose();
	}
	onMouseDown(mouseEvent) {
		const target = mouseEvent.target;
		if (target.type !== 6) return;
		if (!target.detail.injectedText) return;
		if (target.detail.injectedText.options.attachedData !== ColorDecorationInjectedTextMarker) return;
		if (!target.range) return;
		const hoverController = this._editor.getContribution(ModesHoverController.ID);
		if (!hoverController) return;
		if (!hoverController.isColorPickerVisible()) {
			const range = new Range$1(target.range.startLineNumber, target.range.startColumn + 1, target.range.endLineNumber, target.range.endColumn + 1);
			hoverController.showContentHover(range, 1, false);
		}
	}
};
ColorContribution.ID = "editor.contrib.colorContribution";
registerEditorContribution(ColorContribution.ID, ColorContribution);
HoverParticipantRegistry.register(ColorHoverParticipant);

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js
var __awaiter$35 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
function createStringDataTransferItem(stringOrPromise) {
	return {
		asString: () => __awaiter$35(this, void 0, void 0, function* () {
			return stringOrPromise;
		}),
		asFile: () => void 0,
		value: typeof stringOrPromise === "string" ? stringOrPromise : void 0
	};
}
function createFileDataTransferItem(fileName, uri, data) {
	return {
		asString: () => __awaiter$35(this, void 0, void 0, function* () {
			return "";
		}),
		asFile: () => ({
			name: fileName,
			uri,
			data
		}),
		value: void 0
	};
}
var VSDataTransfer = class {
	constructor() {
		this._entries = /* @__PURE__ */ new Map();
	}
	get size() {
		return this._entries.size;
	}
	has(mimeType) {
		return this._entries.has(this.toKey(mimeType));
	}
	get(mimeType) {
		var _a$5;
		return (_a$5 = this._entries.get(this.toKey(mimeType))) === null || _a$5 === void 0 ? void 0 : _a$5[0];
	}
	append(mimeType, value) {
		const existing = this._entries.get(mimeType);
		if (existing) existing.push(value);
		else this._entries.set(this.toKey(mimeType), [value]);
	}
	replace(mimeType, value) {
		this._entries.set(this.toKey(mimeType), [value]);
	}
	delete(mimeType) {
		this._entries.delete(this.toKey(mimeType));
	}
	*entries() {
		for (const [mine, items] of this._entries.entries()) for (const item of items) yield [mine, item];
	}
	values() {
		return Array.from(this._entries.values()).flat();
	}
	forEach(f) {
		for (const [mime, item] of this.entries()) f(item, mime);
	}
	toKey(mimeType) {
		return mimeType.toLowerCase();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/uuid.js
const generateUuid = (function() {
	if (typeof crypto === "object" && typeof crypto.randomUUID === "function") return crypto.randomUUID.bind(crypto);
	let getRandomValues;
	if (typeof crypto === "object" && typeof crypto.getRandomValues === "function") getRandomValues = crypto.getRandomValues.bind(crypto);
	else getRandomValues = function(bucket) {
		for (let i = 0; i < bucket.length; i++) bucket[i] = Math.floor(Math.random() * 256);
		return bucket;
	};
	const _data = new Uint8Array(16);
	const _hex = [];
	for (let i = 0; i < 256; i++) _hex.push(i.toString(16).padStart(2, "0"));
	return function generateUuid$1() {
		getRandomValues(_data);
		_data[6] = _data[6] & 15 | 64;
		_data[8] = _data[8] & 63 | 128;
		let i = 0;
		let result = "";
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += "-";
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += "-";
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += "-";
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += "-";
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		result += _hex[_data[i++]];
		return result;
	};
})();

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/dnd/browser/dnd.js
const CodeDataTransfers = {
	EDITORS: "CodeEditors",
	FILES: "CodeFiles"
};
function extractEditorsDropData(e) {
	var _a$5;
	const editors = [];
	if (e.dataTransfer && e.dataTransfer.types.length > 0) {
		const rawEditorsData = e.dataTransfer.getData(CodeDataTransfers.EDITORS);
		if (rawEditorsData) try {
			editors.push(...parse(rawEditorsData));
		} catch (error) {}
		else try {
			const rawResourcesData = e.dataTransfer.getData(DataTransfers.RESOURCES);
			editors.push(...createDraggedEditorInputFromRawResourcesData(rawResourcesData));
		} catch (error) {}
		if ((_a$5 = e.dataTransfer) === null || _a$5 === void 0 ? void 0 : _a$5.files) for (let i = 0; i < e.dataTransfer.files.length; i++) {
			const file = e.dataTransfer.files[i];
			if (file && file.path) try {
				editors.push({
					resource: URI.file(file.path),
					isExternal: true,
					allowWorkspaceOpen: true
				});
			} catch (error) {}
		}
		const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
		if (rawCodeFiles) try {
			const codeFiles = JSON.parse(rawCodeFiles);
			for (const codeFile of codeFiles) editors.push({
				resource: URI.file(codeFile),
				isExternal: true,
				allowWorkspaceOpen: true
			});
		} catch (error) {}
		const contributions = Registry.as(Extensions$2.DragAndDropContribution).getAll();
		for (const contribution of contributions) {
			const data = e.dataTransfer.getData(contribution.dataFormatKey);
			if (data) try {
				editors.push(...contribution.getEditorInputs(data));
			} catch (error) {}
		}
	}
	return editors;
}
function createDraggedEditorInputFromRawResourcesData(rawResourcesData) {
	const editors = [];
	if (rawResourcesData) {
		const resourcesRaw = JSON.parse(rawResourcesData);
		for (const resourceRaw of resourcesRaw) if (resourceRaw.indexOf(":") > 0) {
			const { selection, uri } = extractSelection(URI.parse(resourceRaw));
			editors.push({
				resource: uri,
				options: { selection }
			});
		}
	}
	return editors;
}
var DragAndDropContributionRegistry = class {
	constructor() {
		this._contributions = /* @__PURE__ */ new Map();
	}
	getAll() {
		return this._contributions.values();
	}
};
const Extensions$2 = { DragAndDropContribution: "workbench.contributions.dragAndDrop" };
Registry.add(Extensions$2.DragAndDropContribution, new DragAndDropContributionRegistry());

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/browser/dnd.js
var __awaiter$34 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
function toVSDataTransfer(dataTransfer) {
	const vsDataTransfer = new VSDataTransfer();
	for (const item of dataTransfer.items) {
		const type = item.type;
		if (item.kind === "string") {
			const asStringValue = new Promise((resolve) => item.getAsString(resolve));
			vsDataTransfer.append(type, createStringDataTransferItem(asStringValue));
		} else if (item.kind === "file") {
			const file = item.getAsFile();
			if (file) vsDataTransfer.append(type, createFileDataTransferItemFromFile(file));
		}
	}
	return vsDataTransfer;
}
function createFileDataTransferItemFromFile(file) {
	const uri = file.path ? URI.parse(file.path) : void 0;
	return createFileDataTransferItem(file.name, uri, () => __awaiter$34(this, void 0, void 0, function* () {
		return new Uint8Array(yield file.arrayBuffer());
	}));
}
var INTERNAL_DND_MIME_TYPES = Object.freeze([
	CodeDataTransfers.EDITORS,
	CodeDataTransfers.FILES,
	DataTransfers.RESOURCES
]);
function addExternalEditorsDropData(dataTransfer, dragEvent, overwriteUriList = false) {
	var _a$5;
	if (dragEvent.dataTransfer && (overwriteUriList || !dataTransfer.has(Mimes.uriList))) {
		const editorData = extractEditorsDropData(dragEvent).filter((input) => input.resource).map((input) => input.resource.toString());
		for (const item of (_a$5 = dragEvent.dataTransfer) === null || _a$5 === void 0 ? void 0 : _a$5.items) {
			const file = item.getAsFile();
			if (file) editorData.push(file.path ? URI.file(file.path).toString() : file.name);
		}
		if (editorData.length) dataTransfer.replace(Mimes.uriList, createStringDataTransferItem(UriList.create(editorData)));
	}
	for (const internal of INTERNAL_DND_MIME_TYPES) dataTransfer.delete(internal);
}
const UriList = Object.freeze({
	create: (entries) => {
		return distinct(entries.map((x) => x.toString())).join("\r\n");
	},
	parse: (str) => {
		return str.split("\r\n").filter((value) => !value.startsWith("#"));
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/labels.js
function normalizeDriveLetter(path, isWindowsOS = isWindows) {
	if (hasDriveLetter(path, isWindowsOS)) return path.charAt(0).toUpperCase() + path.slice(1);
	return path;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetVariables.js
var __decorate$54 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$54 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
const KnownSnippetVariableNames = Object.freeze({
	"CURRENT_YEAR": true,
	"CURRENT_YEAR_SHORT": true,
	"CURRENT_MONTH": true,
	"CURRENT_DATE": true,
	"CURRENT_HOUR": true,
	"CURRENT_MINUTE": true,
	"CURRENT_SECOND": true,
	"CURRENT_DAY_NAME": true,
	"CURRENT_DAY_NAME_SHORT": true,
	"CURRENT_MONTH_NAME": true,
	"CURRENT_MONTH_NAME_SHORT": true,
	"CURRENT_SECONDS_UNIX": true,
	"SELECTION": true,
	"CLIPBOARD": true,
	"TM_SELECTED_TEXT": true,
	"TM_CURRENT_LINE": true,
	"TM_CURRENT_WORD": true,
	"TM_LINE_INDEX": true,
	"TM_LINE_NUMBER": true,
	"TM_FILENAME": true,
	"TM_FILENAME_BASE": true,
	"TM_DIRECTORY": true,
	"TM_FILEPATH": true,
	"CURSOR_INDEX": true,
	"CURSOR_NUMBER": true,
	"RELATIVE_FILEPATH": true,
	"BLOCK_COMMENT_START": true,
	"BLOCK_COMMENT_END": true,
	"LINE_COMMENT": true,
	"WORKSPACE_NAME": true,
	"WORKSPACE_FOLDER": true,
	"RANDOM": true,
	"RANDOM_HEX": true,
	"UUID": true
});
var CompositeSnippetVariableResolver = class {
	constructor(_delegates) {
		this._delegates = _delegates;
	}
	resolve(variable) {
		for (const delegate of this._delegates) {
			const value = delegate.resolve(variable);
			if (value !== void 0) return value;
		}
	}
};
var SelectionBasedVariableResolver = class {
	constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {
		this._model = _model;
		this._selection = _selection;
		this._selectionIdx = _selectionIdx;
		this._overtypingCapturer = _overtypingCapturer;
	}
	resolve(variable) {
		const { name } = variable;
		if (name === "SELECTION" || name === "TM_SELECTED_TEXT") {
			let value = this._model.getValueInRange(this._selection) || void 0;
			let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;
			if (!value && this._overtypingCapturer) {
				const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
				if (info) {
					value = info.value;
					isMultiline = info.multiline;
				}
			}
			if (value && isMultiline && variable.snippet) {
				const lineLeadingWhitespace = getLeadingWhitespace(this._model.getLineContent(this._selection.startLineNumber), 0, this._selection.startColumn - 1);
				let varLeadingWhitespace = lineLeadingWhitespace;
				variable.snippet.walk((marker) => {
					if (marker === variable) return false;
					if (marker instanceof Text) varLeadingWhitespace = getLeadingWhitespace(splitLines(marker.value).pop());
					return true;
				});
				const whitespaceCommonLength = commonPrefixLength(varLeadingWhitespace, lineLeadingWhitespace);
				value = value.replace(/(\r\n|\r|\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);
			}
			return value;
		} else if (name === "TM_CURRENT_LINE") return this._model.getLineContent(this._selection.positionLineNumber);
		else if (name === "TM_CURRENT_WORD") {
			const info = this._model.getWordAtPosition({
				lineNumber: this._selection.positionLineNumber,
				column: this._selection.positionColumn
			});
			return info && info.word || void 0;
		} else if (name === "TM_LINE_INDEX") return String(this._selection.positionLineNumber - 1);
		else if (name === "TM_LINE_NUMBER") return String(this._selection.positionLineNumber);
		else if (name === "CURSOR_INDEX") return String(this._selectionIdx);
		else if (name === "CURSOR_NUMBER") return String(this._selectionIdx + 1);
	}
};
var ModelBasedVariableResolver = class {
	constructor(_labelService, _model) {
		this._labelService = _labelService;
		this._model = _model;
	}
	resolve(variable) {
		const { name } = variable;
		if (name === "TM_FILENAME") return basename$1(this._model.uri.fsPath);
		else if (name === "TM_FILENAME_BASE") {
			const name$1 = basename$1(this._model.uri.fsPath);
			const idx = name$1.lastIndexOf(".");
			if (idx <= 0) return name$1;
			else return name$1.slice(0, idx);
		} else if (name === "TM_DIRECTORY") {
			if (dirname$1(this._model.uri.fsPath) === ".") return "";
			return this._labelService.getUriLabel(dirname(this._model.uri));
		} else if (name === "TM_FILEPATH") return this._labelService.getUriLabel(this._model.uri);
		else if (name === "RELATIVE_FILEPATH") return this._labelService.getUriLabel(this._model.uri, {
			relative: true,
			noPrefix: true
		});
	}
};
var ClipboardBasedVariableResolver = class {
	constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {
		this._readClipboardText = _readClipboardText;
		this._selectionIdx = _selectionIdx;
		this._selectionCount = _selectionCount;
		this._spread = _spread;
	}
	resolve(variable) {
		if (variable.name !== "CLIPBOARD") return;
		const clipboardText = this._readClipboardText();
		if (!clipboardText) return;
		if (this._spread) {
			const lines = clipboardText.split(/\r\n|\n|\r/).filter((s) => !isFalsyOrWhitespace(s));
			if (lines.length === this._selectionCount) return lines[this._selectionIdx];
		}
		return clipboardText;
	}
};
var CommentBasedVariableResolver = class CommentBasedVariableResolver$1 {
	constructor(_model, _selection, _languageConfigurationService) {
		this._model = _model;
		this._selection = _selection;
		this._languageConfigurationService = _languageConfigurationService;
	}
	resolve(variable) {
		const { name } = variable;
		const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);
		const config = this._languageConfigurationService.getLanguageConfiguration(langId).comments;
		if (!config) return;
		if (name === "LINE_COMMENT") return config.lineCommentToken || void 0;
		else if (name === "BLOCK_COMMENT_START") return config.blockCommentStartToken || void 0;
		else if (name === "BLOCK_COMMENT_END") return config.blockCommentEndToken || void 0;
	}
};
CommentBasedVariableResolver = __decorate$54([__param$54(2, ILanguageConfigurationService)], CommentBasedVariableResolver);
var TimeBasedVariableResolver = class TimeBasedVariableResolver {
	constructor() {
		this._date = /* @__PURE__ */ new Date();
	}
	resolve(variable) {
		const { name } = variable;
		if (name === "CURRENT_YEAR") return String(this._date.getFullYear());
		else if (name === "CURRENT_YEAR_SHORT") return String(this._date.getFullYear()).slice(-2);
		else if (name === "CURRENT_MONTH") return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
		else if (name === "CURRENT_DATE") return String(this._date.getDate().valueOf()).padStart(2, "0");
		else if (name === "CURRENT_HOUR") return String(this._date.getHours().valueOf()).padStart(2, "0");
		else if (name === "CURRENT_MINUTE") return String(this._date.getMinutes().valueOf()).padStart(2, "0");
		else if (name === "CURRENT_SECOND") return String(this._date.getSeconds().valueOf()).padStart(2, "0");
		else if (name === "CURRENT_DAY_NAME") return TimeBasedVariableResolver.dayNames[this._date.getDay()];
		else if (name === "CURRENT_DAY_NAME_SHORT") return TimeBasedVariableResolver.dayNamesShort[this._date.getDay()];
		else if (name === "CURRENT_MONTH_NAME") return TimeBasedVariableResolver.monthNames[this._date.getMonth()];
		else if (name === "CURRENT_MONTH_NAME_SHORT") return TimeBasedVariableResolver.monthNamesShort[this._date.getMonth()];
		else if (name === "CURRENT_SECONDS_UNIX") return String(Math.floor(this._date.getTime() / 1e3));
	}
};
TimeBasedVariableResolver.dayNames = [
	localize("Sunday", "Sunday"),
	localize("Monday", "Monday"),
	localize("Tuesday", "Tuesday"),
	localize("Wednesday", "Wednesday"),
	localize("Thursday", "Thursday"),
	localize("Friday", "Friday"),
	localize("Saturday", "Saturday")
];
TimeBasedVariableResolver.dayNamesShort = [
	localize("SundayShort", "Sun"),
	localize("MondayShort", "Mon"),
	localize("TuesdayShort", "Tue"),
	localize("WednesdayShort", "Wed"),
	localize("ThursdayShort", "Thu"),
	localize("FridayShort", "Fri"),
	localize("SaturdayShort", "Sat")
];
TimeBasedVariableResolver.monthNames = [
	localize("January", "January"),
	localize("February", "February"),
	localize("March", "March"),
	localize("April", "April"),
	localize("May", "May"),
	localize("June", "June"),
	localize("July", "July"),
	localize("August", "August"),
	localize("September", "September"),
	localize("October", "October"),
	localize("November", "November"),
	localize("December", "December")
];
TimeBasedVariableResolver.monthNamesShort = [
	localize("JanuaryShort", "Jan"),
	localize("FebruaryShort", "Feb"),
	localize("MarchShort", "Mar"),
	localize("AprilShort", "Apr"),
	localize("MayShort", "May"),
	localize("JuneShort", "Jun"),
	localize("JulyShort", "Jul"),
	localize("AugustShort", "Aug"),
	localize("SeptemberShort", "Sep"),
	localize("OctoberShort", "Oct"),
	localize("NovemberShort", "Nov"),
	localize("DecemberShort", "Dec")
];
var WorkspaceBasedVariableResolver = class {
	constructor(_workspaceService) {
		this._workspaceService = _workspaceService;
	}
	resolve(variable) {
		if (!this._workspaceService) return;
		const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());
		if (!workspaceIdentifier) return;
		if (variable.name === "WORKSPACE_NAME") return this._resolveWorkspaceName(workspaceIdentifier);
		else if (variable.name === "WORKSPACE_FOLDER") return this._resoveWorkspacePath(workspaceIdentifier);
	}
	_resolveWorkspaceName(workspaceIdentifier) {
		if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) return basename$1(workspaceIdentifier.uri.path);
		let filename = basename$1(workspaceIdentifier.configPath.path);
		if (filename.endsWith(WORKSPACE_EXTENSION)) filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
		return filename;
	}
	_resoveWorkspacePath(workspaceIdentifier) {
		if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) return normalizeDriveLetter(workspaceIdentifier.uri.fsPath);
		const filename = basename$1(workspaceIdentifier.configPath.path);
		let folderpath = workspaceIdentifier.configPath.fsPath;
		if (folderpath.endsWith(filename)) folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);
		return folderpath ? normalizeDriveLetter(folderpath) : "/";
	}
};
var RandomBasedVariableResolver = class {
	resolve(variable) {
		const { name } = variable;
		if (name === "RANDOM") return Math.random().toString().slice(-6);
		else if (name === "RANDOM_HEX") return Math.random().toString(16).slice(-6);
		else if (name === "UUID") return generateUuid();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js
var __decorate$53 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$53 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var OneSnippet = class OneSnippet {
	constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {
		this._editor = _editor;
		this._snippet = _snippet;
		this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;
		this._offset = -1;
		this._nestingLevel = 1;
		this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);
		this._placeholderGroupsIdx = -1;
	}
	initialize(textChange) {
		this._offset = textChange.newPosition;
	}
	dispose() {
		if (this._placeholderDecorations) this._editor.removeDecorations([...this._placeholderDecorations.values()]);
		this._placeholderGroups.length = 0;
	}
	_initDecorations() {
		if (this._offset === -1) throw new Error(`Snippet not initialized!`);
		if (this._placeholderDecorations) return;
		this._placeholderDecorations = /* @__PURE__ */ new Map();
		const model = this._editor.getModel();
		this._editor.changeDecorations((accessor) => {
			for (const placeholder of this._snippet.placeholders) {
				const placeholderOffset = this._snippet.offset(placeholder);
				const placeholderLen = this._snippet.fullLen(placeholder);
				const range = Range$1.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));
				const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;
				const handle = accessor.addDecoration(range, options);
				this._placeholderDecorations.set(placeholder, handle);
			}
		});
	}
	move(fwd) {
		if (!this._editor.hasModel()) return [];
		this._initDecorations();
		if (this._placeholderGroupsIdx >= 0) {
			const operations = [];
			for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) if (placeholder.transform) {
				const id = this._placeholderDecorations.get(placeholder);
				const range = this._editor.getModel().getDecorationRange(id);
				const currentValue = this._editor.getModel().getValueInRange(range);
				const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\r\n|\r|\n/);
				for (let i = 1; i < transformedValueLines.length; i++) transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);
				operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));
			}
			if (operations.length > 0) this._editor.executeEdits("snippet.placeholderTransform", operations);
		}
		let couldSkipThisPlaceholder = false;
		if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
			this._placeholderGroupsIdx += 1;
			couldSkipThisPlaceholder = true;
		} else if (fwd === false && this._placeholderGroupsIdx > 0) {
			this._placeholderGroupsIdx -= 1;
			couldSkipThisPlaceholder = true;
		}
		const newSelections = this._editor.getModel().changeDecorations((accessor) => {
			const activePlaceholders = /* @__PURE__ */ new Set();
			const selections = [];
			for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
				const id = this._placeholderDecorations.get(placeholder);
				const range = this._editor.getModel().getDecorationRange(id);
				selections.push(new Selection$1(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));
				couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);
				accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
				activePlaceholders.add(placeholder);
				for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {
					const id$1 = this._placeholderDecorations.get(enclosingPlaceholder);
					accessor.changeDecorationOptions(id$1, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
					activePlaceholders.add(enclosingPlaceholder);
				}
			}
			for (const [placeholder, id] of this._placeholderDecorations) if (!activePlaceholders.has(placeholder)) accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);
			return selections;
		});
		return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);
	}
	_hasPlaceholderBeenCollapsed(placeholder) {
		let marker = placeholder;
		while (marker) {
			if (marker instanceof Placeholder) {
				const id = this._placeholderDecorations.get(marker);
				if (this._editor.getModel().getDecorationRange(id).isEmpty() && marker.toString().length > 0) return true;
			}
			marker = marker.parent;
		}
		return false;
	}
	get isAtFirstPlaceholder() {
		return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
	}
	get isAtLastPlaceholder() {
		return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
	}
	get hasPlaceholder() {
		return this._snippet.placeholders.length > 0;
	}
	get isTrivialSnippet() {
		return this._snippet.placeholders.length === 0 || this._snippet.placeholders.length === 1 && this._snippet.placeholders[0].isFinalTabstop;
	}
	computePossibleSelections() {
		const result = /* @__PURE__ */ new Map();
		for (const placeholdersWithEqualIndex of this._placeholderGroups) {
			let ranges;
			for (const placeholder of placeholdersWithEqualIndex) {
				if (placeholder.isFinalTabstop) break;
				if (!ranges) {
					ranges = [];
					result.set(placeholder.index, ranges);
				}
				const id = this._placeholderDecorations.get(placeholder);
				const range = this._editor.getModel().getDecorationRange(id);
				if (!range) {
					result.delete(placeholder.index);
					break;
				}
				ranges.push(range);
			}
		}
		return result;
	}
	get activeChoice() {
		if (!this._placeholderDecorations) return;
		const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];
		if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) return;
		const id = this._placeholderDecorations.get(placeholder);
		if (!id) return;
		const range = this._editor.getModel().getDecorationRange(id);
		if (!range) return;
		return {
			range,
			choice: placeholder.choice
		};
	}
	get hasChoice() {
		let result = false;
		this._snippet.walk((marker) => {
			result = marker instanceof Choice;
			return !result;
		});
		return result;
	}
	merge(others) {
		const model = this._editor.getModel();
		this._nestingLevel *= 10;
		this._editor.changeDecorations((accessor) => {
			for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
				const nested = others.shift();
				console.assert(nested._offset !== -1);
				console.assert(!nested._placeholderDecorations);
				const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;
				for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) if (nestedPlaceholder.isFinalTabstop) nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;
				else nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;
				this._snippet.replace(placeholder, nested._snippet.children);
				const id = this._placeholderDecorations.get(placeholder);
				accessor.removeDecoration(id);
				this._placeholderDecorations.delete(placeholder);
				for (const placeholder$1 of nested._snippet.placeholders) {
					const placeholderOffset = nested._snippet.offset(placeholder$1);
					const placeholderLen = nested._snippet.fullLen(placeholder$1);
					const range = Range$1.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
					const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);
					this._placeholderDecorations.set(placeholder$1, handle);
				}
			}
			this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
		});
	}
};
OneSnippet._decor = {
	active: ModelDecorationOptions.register({
		description: "snippet-placeholder-1",
		stickiness: 0,
		className: "snippet-placeholder"
	}),
	inactive: ModelDecorationOptions.register({
		description: "snippet-placeholder-2",
		stickiness: 1,
		className: "snippet-placeholder"
	}),
	activeFinal: ModelDecorationOptions.register({
		description: "snippet-placeholder-3",
		stickiness: 1,
		className: "finish-snippet-placeholder"
	}),
	inactiveFinal: ModelDecorationOptions.register({
		description: "snippet-placeholder-4",
		stickiness: 1,
		className: "finish-snippet-placeholder"
	})
};
var _defaultOptions$1 = {
	overwriteBefore: 0,
	overwriteAfter: 0,
	adjustWhitespace: true,
	clipboardText: void 0,
	overtypingCapturer: void 0
};
var SnippetSession = class SnippetSession$1 {
	constructor(_editor, _template, _options = _defaultOptions$1, _languageConfigurationService) {
		this._editor = _editor;
		this._template = _template;
		this._options = _options;
		this._languageConfigurationService = _languageConfigurationService;
		this._templateMerges = [];
		this._snippets = [];
	}
	static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {
		const lineLeadingWhitespace = getLeadingWhitespace(model.getLineContent(position.lineNumber), 0, position.column - 1);
		let snippetTextString;
		snippet.walk((marker) => {
			if (!(marker instanceof Text) || marker.parent instanceof Choice) return true;
			const lines = marker.value.split(/\r\n|\r|\n/);
			if (adjustIndentation) {
				const offset = snippet.offset(marker);
				if (offset === 0) lines[0] = model.normalizeIndentation(lines[0]);
				else {
					snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();
					const prevChar = snippetTextString.charCodeAt(offset - 1);
					if (prevChar === 10 || prevChar === 13) lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);
				}
				for (let i = 1; i < lines.length; i++) lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);
			}
			const newValue = lines.join(model.getEOL());
			if (newValue !== marker.value) {
				marker.parent.replace(marker, [new Text(newValue)]);
				snippetTextString = void 0;
			}
			return true;
		});
		return lineLeadingWhitespace;
	}
	static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {
		if (overwriteBefore !== 0 || overwriteAfter !== 0) {
			const { positionLineNumber, positionColumn } = selection;
			const positionColumnBefore = positionColumn - overwriteBefore;
			const positionColumnAfter = positionColumn + overwriteAfter;
			const range = model.validateRange({
				startLineNumber: positionLineNumber,
				startColumn: positionColumnBefore,
				endLineNumber: positionLineNumber,
				endColumn: positionColumnAfter
			});
			selection = Selection$1.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());
		}
		return selection;
	}
	static createEditsAndSnippetsFromSelections(editor$1, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {
		const edits = [];
		const snippets = [];
		if (!editor$1.hasModel()) return {
			edits,
			snippets
		};
		const model = editor$1.getModel();
		const workspaceService = editor$1.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService));
		const modelBasedVariableResolver = editor$1.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model));
		const readClipboardText = () => clipboardText;
		const firstBeforeText = model.getValueInRange(SnippetSession$1.adjustSelection(model, editor$1.getSelection(), overwriteBefore, 0));
		const firstAfterText = model.getValueInRange(SnippetSession$1.adjustSelection(model, editor$1.getSelection(), 0, overwriteAfter));
		const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor$1.getSelection().positionLineNumber);
		const indexedSelections = editor$1.getSelections().map((selection, idx) => ({
			selection,
			idx
		})).sort((a, b) => Range$1.compareRangesUsingStarts(a.selection, b.selection));
		for (const { selection, idx } of indexedSelections) {
			let extensionBefore = SnippetSession$1.adjustSelection(model, selection, overwriteBefore, 0);
			let extensionAfter = SnippetSession$1.adjustSelection(model, selection, 0, overwriteAfter);
			if (firstBeforeText !== model.getValueInRange(extensionBefore)) extensionBefore = selection;
			if (firstAfterText !== model.getValueInRange(extensionAfter)) extensionAfter = selection;
			const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
			const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);
			const start = snippetSelection.getStartPosition();
			const snippetLineLeadingWhitespace = SnippetSession$1.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);
			snippet.resolveVariables(new CompositeSnippetVariableResolver([
				modelBasedVariableResolver,
				new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor$1.getOption(73) === "spread"),
				new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),
				new CommentBasedVariableResolver(model, selection, languageConfigurationService),
				new TimeBasedVariableResolver(),
				new WorkspaceBasedVariableResolver(workspaceService),
				new RandomBasedVariableResolver()
			]));
			edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
			edits[idx].identifier = {
				major: idx,
				minor: 0
			};
			edits[idx]._isTracked = true;
			snippets[idx] = new OneSnippet(editor$1, snippet, snippetLineLeadingWhitespace);
		}
		return {
			edits,
			snippets
		};
	}
	static createEditsAndSnippetsFromEdits(editor$1, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {
		if (!editor$1.hasModel() || snippetEdits.length === 0) return {
			edits: [],
			snippets: []
		};
		const edits = [];
		const model = editor$1.getModel();
		const parser = new SnippetParser();
		const snippet = new TextmateSnippet();
		const resolver = new CompositeSnippetVariableResolver([
			editor$1.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model)),
			new ClipboardBasedVariableResolver(() => clipboardText, 0, editor$1.getSelections().length, editor$1.getOption(73) === "spread"),
			new SelectionBasedVariableResolver(model, editor$1.getSelection(), 0, overtypingCapturer),
			new CommentBasedVariableResolver(model, editor$1.getSelection(), languageConfigurationService),
			new TimeBasedVariableResolver(),
			new WorkspaceBasedVariableResolver(editor$1.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService))),
			new RandomBasedVariableResolver()
		]);
		snippetEdits = snippetEdits.sort((a, b) => Range$1.compareRangesUsingStarts(a.range, b.range));
		let offset = 0;
		for (let i = 0; i < snippetEdits.length; i++) {
			const { range, template } = snippetEdits[i];
			if (i > 0) {
				const lastRange = snippetEdits[i - 1].range;
				const textRange = Range$1.fromPositions(lastRange.getEndPosition(), range.getStartPosition());
				const textNode = new Text(model.getValueInRange(textRange));
				snippet.appendChild(textNode);
				offset += textNode.value.length;
			}
			parser.parseFragment(template, snippet);
			snippet.resolveVariables(resolver);
			const snippetText = snippet.toString();
			const snippetFragmentText = snippetText.slice(offset);
			offset = snippetText.length;
			const edit = EditOperation.replace(range, snippetFragmentText);
			edit.identifier = {
				major: i,
				minor: 0
			};
			edit._isTracked = true;
			edits.push(edit);
		}
		parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);
		return {
			edits,
			snippets: [new OneSnippet(editor$1, snippet, "")]
		};
	}
	dispose() {
		dispose(this._snippets);
	}
	_logInfo() {
		return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
	}
	insert() {
		if (!this._editor.hasModel()) return;
		const { edits, snippets } = typeof this._template === "string" ? SnippetSession$1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : SnippetSession$1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);
		this._snippets = snippets;
		this._editor.executeEdits("snippet", edits, (_undoEdits) => {
			const undoEdits = _undoEdits.filter((edit) => !!edit.identifier);
			for (let idx = 0; idx < snippets.length; idx++) snippets[idx].initialize(undoEdits[idx].textChange);
			if (this._snippets[0].hasPlaceholder) return this._move(true);
			else return undoEdits.map((edit) => Selection$1.fromPositions(edit.range.getEndPosition()));
		});
		this._editor.revealRange(this._editor.getSelections()[0]);
	}
	merge(template, options = _defaultOptions$1) {
		if (!this._editor.hasModel()) return;
		this._templateMerges.push([
			this._snippets[0]._nestingLevel,
			this._snippets[0]._placeholderGroupsIdx,
			template
		]);
		const { edits, snippets } = SnippetSession$1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);
		this._editor.executeEdits("snippet", edits, (_undoEdits) => {
			const undoEdits = _undoEdits.filter((edit) => !!edit.identifier);
			for (let idx = 0; idx < snippets.length; idx++) snippets[idx].initialize(undoEdits[idx].textChange);
			const isTrivialSnippet = snippets[0].isTrivialSnippet;
			if (!isTrivialSnippet) {
				for (const snippet of this._snippets) snippet.merge(snippets);
				console.assert(snippets.length === 0);
			}
			if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) return this._move(void 0);
			else return undoEdits.map((edit) => Selection$1.fromPositions(edit.range.getEndPosition()));
		});
	}
	next() {
		const newSelections = this._move(true);
		this._editor.setSelections(newSelections);
		this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
	}
	prev() {
		const newSelections = this._move(false);
		this._editor.setSelections(newSelections);
		this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
	}
	_move(fwd) {
		const selections = [];
		for (const snippet of this._snippets) {
			const oneSelection = snippet.move(fwd);
			selections.push(...oneSelection);
		}
		return selections;
	}
	get isAtFirstPlaceholder() {
		return this._snippets[0].isAtFirstPlaceholder;
	}
	get isAtLastPlaceholder() {
		return this._snippets[0].isAtLastPlaceholder;
	}
	get hasPlaceholder() {
		return this._snippets[0].hasPlaceholder;
	}
	get hasChoice() {
		return this._snippets[0].hasChoice;
	}
	get activeChoice() {
		return this._snippets[0].activeChoice;
	}
	isSelectionWithinPlaceholders() {
		if (!this.hasPlaceholder) return false;
		const selections = this._editor.getSelections();
		if (selections.length < this._snippets.length) return false;
		const allPossibleSelections = /* @__PURE__ */ new Map();
		for (const snippet of this._snippets) {
			const possibleSelections = snippet.computePossibleSelections();
			if (allPossibleSelections.size === 0) for (const [index, ranges] of possibleSelections) {
				ranges.sort(Range$1.compareRangesUsingStarts);
				for (const selection of selections) if (ranges[0].containsRange(selection)) {
					allPossibleSelections.set(index, []);
					break;
				}
			}
			if (allPossibleSelections.size === 0) return false;
			allPossibleSelections.forEach((array$1, index) => {
				array$1.push(...possibleSelections.get(index));
			});
		}
		selections.sort(Range$1.compareRangesUsingStarts);
		for (const [index, ranges] of allPossibleSelections) {
			if (ranges.length !== selections.length) {
				allPossibleSelections.delete(index);
				continue;
			}
			ranges.sort(Range$1.compareRangesUsingStarts);
			for (let i = 0; i < ranges.length; i++) if (!ranges[i].containsRange(selections[i])) {
				allPossibleSelections.delete(index);
				continue;
			}
		}
		return allPossibleSelections.size > 0;
	}
};
SnippetSession = __decorate$53([__param$53(3, ILanguageConfigurationService)], SnippetSession);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js
var __decorate$52 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$52 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var _defaultOptions = {
	overwriteBefore: 0,
	overwriteAfter: 0,
	undoStopBefore: true,
	undoStopAfter: true,
	adjustWhitespace: true,
	clipboardText: void 0,
	overtypingCapturer: void 0
};
var SnippetController2 = class SnippetController2$1 {
	constructor(_editor, _logService, _languageFeaturesService, contextKeyService, _languageConfigurationService) {
		this._editor = _editor;
		this._logService = _logService;
		this._languageFeaturesService = _languageFeaturesService;
		this._languageConfigurationService = _languageConfigurationService;
		this._snippetListener = new DisposableStore();
		this._modelVersionId = -1;
		this._inSnippet = SnippetController2$1.InSnippetMode.bindTo(contextKeyService);
		this._hasNextTabstop = SnippetController2$1.HasNextTabstop.bindTo(contextKeyService);
		this._hasPrevTabstop = SnippetController2$1.HasPrevTabstop.bindTo(contextKeyService);
	}
	static get(editor$1) {
		return editor$1.getContribution(SnippetController2$1.ID);
	}
	dispose() {
		var _a$5;
		this._inSnippet.reset();
		this._hasPrevTabstop.reset();
		this._hasNextTabstop.reset();
		(_a$5 = this._session) === null || _a$5 === void 0 || _a$5.dispose();
		this._snippetListener.dispose();
	}
	apply(edits, opts) {
		try {
			this._doInsert(edits, typeof opts === "undefined" ? _defaultOptions : Object.assign(Object.assign({}, _defaultOptions), opts));
		} catch (e) {
			this.cancel();
			this._logService.error(e);
			this._logService.error("snippet_error");
			this._logService.error("insert_edits=", edits);
			this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
		}
	}
	insert(template, opts) {
		try {
			this._doInsert(template, typeof opts === "undefined" ? _defaultOptions : Object.assign(Object.assign({}, _defaultOptions), opts));
		} catch (e) {
			this.cancel();
			this._logService.error(e);
			this._logService.error("snippet_error");
			this._logService.error("insert_template=", template);
			this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
		}
	}
	_doInsert(template, opts) {
		var _a$5;
		if (!this._editor.hasModel()) return;
		this._snippetListener.clear();
		if (opts.undoStopBefore) this._editor.getModel().pushStackElement();
		if (this._session && typeof template !== "string") this.cancel();
		if (!this._session) {
			this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
			this._session = new SnippetSession(this._editor, template, opts, this._languageConfigurationService);
			this._session.insert();
		} else {
			assertType(typeof template === "string");
			this._session.merge(template, opts);
		}
		if (opts.undoStopAfter) this._editor.getModel().pushStackElement();
		if ((_a$5 = this._session) === null || _a$5 === void 0 ? void 0 : _a$5.hasChoice) {
			this._choiceCompletionItemProvider = { provideCompletionItems: (model, position) => {
				if (!this._session || model !== this._editor.getModel() || !Position$1.equals(this._editor.getPosition(), position)) return;
				const { activeChoice } = this._session;
				if (!activeChoice || activeChoice.choice.options.length === 0) return;
				const word = model.getValueInRange(activeChoice.range);
				const isAnyOfOptions = Boolean(activeChoice.choice.options.find((o) => o.value === word));
				const suggestions = [];
				for (let i = 0; i < activeChoice.choice.options.length; i++) {
					const option = activeChoice.choice.options[i];
					suggestions.push({
						kind: 13,
						label: option.value,
						insertText: option.value,
						sortText: "a".repeat(i + 1),
						range: activeChoice.range,
						filterText: isAnyOfOptions ? `${word}_${option.value}` : void 0,
						command: {
							id: "jumpToNextSnippetPlaceholder",
							title: localize("next", "Go to next placeholder...")
						}
					});
				}
				return { suggestions };
			} };
			const registration = this._languageFeaturesService.completionProvider.register({
				language: this._editor.getModel().getLanguageId(),
				pattern: this._editor.getModel().uri.fsPath,
				scheme: this._editor.getModel().uri.scheme
			}, this._choiceCompletionItemProvider);
			this._snippetListener.add(registration);
		}
		this._updateState();
		this._snippetListener.add(this._editor.onDidChangeModelContent((e) => e.isFlush && this.cancel()));
		this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));
		this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
	}
	_updateState() {
		if (!this._session || !this._editor.hasModel()) return;
		if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) return this.cancel();
		if (!this._session.hasPlaceholder) return this.cancel();
		if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
			this._editor.getModel().pushStackElement();
			return this.cancel();
		}
		this._inSnippet.set(true);
		this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
		this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
		this._handleChoice();
	}
	_handleChoice() {
		if (!this._session || !this._editor.hasModel()) {
			this._currentChoice = void 0;
			return;
		}
		const { activeChoice } = this._session;
		if (!activeChoice || !this._choiceCompletionItemProvider) {
			this._currentChoice = void 0;
			return;
		}
		if (this._currentChoice !== activeChoice.choice) {
			this._currentChoice = activeChoice.choice;
			queueMicrotask(() => {
				showSimpleSuggestions(this._editor, this._choiceCompletionItemProvider);
			});
		}
	}
	finish() {
		while (this._inSnippet.get()) this.next();
	}
	cancel(resetSelection = false) {
		var _a$5;
		this._inSnippet.reset();
		this._hasPrevTabstop.reset();
		this._hasNextTabstop.reset();
		this._snippetListener.clear();
		this._currentChoice = void 0;
		(_a$5 = this._session) === null || _a$5 === void 0 || _a$5.dispose();
		this._session = void 0;
		this._modelVersionId = -1;
		if (resetSelection) this._editor.setSelections([this._editor.getSelection()]);
	}
	prev() {
		if (this._session) this._session.prev();
		this._updateState();
	}
	next() {
		if (this._session) this._session.next();
		this._updateState();
	}
	isInSnippet() {
		return Boolean(this._inSnippet.get());
	}
};
SnippetController2.ID = "snippetController2";
SnippetController2.InSnippetMode = new RawContextKey("inSnippetMode", false, localize("inSnippetMode", "Whether the editor in current in snippet mode"));
SnippetController2.HasNextTabstop = new RawContextKey("hasNextTabstop", false, localize("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
SnippetController2.HasPrevTabstop = new RawContextKey("hasPrevTabstop", false, localize("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
SnippetController2 = __decorate$52([
	__param$52(1, ILogService),
	__param$52(2, ILanguageFeaturesService),
	__param$52(3, IContextKeyService),
	__param$52(4, ILanguageConfigurationService)
], SnippetController2);
registerEditorContribution(SnippetController2.ID, SnippetController2);
var CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
registerEditorCommand(new CommandCtor({
	id: "jumpToNextSnippetPlaceholder",
	precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
	handler: (ctrl) => ctrl.next(),
	kbOpts: {
		weight: 130,
		kbExpr: EditorContextKeys.editorTextFocus,
		primary: 2
	}
}));
registerEditorCommand(new CommandCtor({
	id: "jumpToPrevSnippetPlaceholder",
	precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
	handler: (ctrl) => ctrl.prev(),
	kbOpts: {
		weight: 130,
		kbExpr: EditorContextKeys.editorTextFocus,
		primary: 1026
	}
}));
registerEditorCommand(new CommandCtor({
	id: "leaveSnippet",
	precondition: SnippetController2.InSnippetMode,
	handler: (ctrl) => ctrl.cancel(true),
	kbOpts: {
		weight: 130,
		kbExpr: EditorContextKeys.editorTextFocus,
		primary: 9,
		secondary: [1033]
	}
}));
registerEditorCommand(new CommandCtor({
	id: "acceptSnippet",
	precondition: SnippetController2.InSnippetMode,
	handler: (ctrl) => ctrl.finish()
}));
function performSnippetEdit(editor$1, snippet, selections) {
	const controller = SnippetController2.get(editor$1);
	if (!controller) return false;
	editor$1.focus();
	controller.apply(selections.map((selection) => {
		return {
			range: Selection$1.liftSelection(selection),
			template: snippet
		};
	}));
	return controller.isInSnippet();
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteController.js
var __decorate$51 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$51 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$33 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var vscodeClipboardMime = "application/vnd.code.copyMetadata";
var CopyPasteController = class CopyPasteController$1 extends Disposable {
	constructor(editor$1, _bulkEditService, _clipboardService, _configurationService, _languageFeaturesService) {
		super();
		this._bulkEditService = _bulkEditService;
		this._clipboardService = _clipboardService;
		this._configurationService = _configurationService;
		this._languageFeaturesService = _languageFeaturesService;
		this._editor = editor$1;
		const container = editor$1.getContainerDomNode();
		this._register(addDisposableListener(container, "copy", (e) => this.handleCopy(e)));
		this._register(addDisposableListener(container, "cut", (e) => this.handleCopy(e)));
		this._register(addDisposableListener(container, "paste", (e) => this.handlePaste(e), true));
	}
	arePasteActionsEnabled(model) {
		return this._configurationService.getValue("editor.experimental.pasteActions.enabled", { resource: model.uri });
	}
	handleCopy(e) {
		var _a$5;
		if (!e.clipboardData || !this._editor.hasTextFocus()) return;
		const model = this._editor.getModel();
		const selections = this._editor.getSelections();
		if (!model || !(selections === null || selections === void 0 ? void 0 : selections.length)) return;
		if (!this.arePasteActionsEnabled(model)) return;
		const ranges = [...selections];
		const primarySelection = selections[0];
		const wasFromEmptySelection = primarySelection.isEmpty();
		if (wasFromEmptySelection) {
			if (!this._editor.getOption(33)) return;
			ranges[0] = new Range$1(primarySelection.startLineNumber, 0, primarySelection.startLineNumber, model.getLineLength(primarySelection.startLineNumber));
		}
		const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((x) => !!x.prepareDocumentPaste);
		if (!providers.length) {
			this.setCopyMetadata(e.clipboardData, { wasFromEmptySelection });
			return;
		}
		const dataTransfer = toVSDataTransfer(e.clipboardData);
		const handle = generateUuid();
		this.setCopyMetadata(e.clipboardData, {
			id: handle,
			wasFromEmptySelection
		});
		const promise = createCancelablePromise((token) => __awaiter$33(this, void 0, void 0, function* () {
			const results = yield Promise.all(providers.map((provider) => {
				return provider.prepareDocumentPaste(model, ranges, dataTransfer, token);
			}));
			for (const result of results) result === null || result === void 0 || result.forEach((value, key) => {
				dataTransfer.replace(key, value);
			});
			return dataTransfer;
		}));
		(_a$5 = this._currentClipboardItem) === null || _a$5 === void 0 || _a$5.dataTransferPromise.cancel();
		this._currentClipboardItem = {
			handle,
			dataTransferPromise: promise
		};
	}
	setCopyMetadata(dataTransfer, metadata) {
		dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));
	}
	handlePaste(e) {
		var _a$5, _b$1, _c$1;
		return __awaiter$33(this, void 0, void 0, function* () {
			if (!e.clipboardData || !this._editor.hasTextFocus()) return;
			const selections = this._editor.getSelections();
			if (!(selections === null || selections === void 0 ? void 0 : selections.length) || !this._editor.hasModel()) return;
			const model = this._editor.getModel();
			if (!this.arePasteActionsEnabled(model)) return;
			let metadata;
			const rawMetadata = (_a$5 = e.clipboardData) === null || _a$5 === void 0 ? void 0 : _a$5.getData(vscodeClipboardMime);
			if (rawMetadata && typeof rawMetadata === "string") metadata = JSON.parse(rawMetadata);
			const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model);
			if (!providers.length) return;
			e.preventDefault();
			e.stopImmediatePropagation();
			const originalDocVersion = model.getVersionId();
			const tokenSource = new EditorStateCancellationTokenSource(this._editor, 3);
			try {
				const dataTransfer = toVSDataTransfer(e.clipboardData);
				if ((metadata === null || metadata === void 0 ? void 0 : metadata.id) && ((_b$1 = this._currentClipboardItem) === null || _b$1 === void 0 ? void 0 : _b$1.handle) === metadata.id) (yield this._currentClipboardItem.dataTransferPromise).forEach((value, key) => {
					dataTransfer.replace(key, value);
				});
				if (!dataTransfer.has(Mimes.uriList)) {
					const resources = yield this._clipboardService.readResources();
					if (resources.length) dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
				}
				dataTransfer.delete(vscodeClipboardMime);
				for (const provider of providers) {
					if (!provider.pasteMimeTypes.some((type) => {
						if (type.toLowerCase() === DataTransfers.FILES.toLowerCase()) return [...dataTransfer.values()].some((item) => item.asFile());
						return dataTransfer.has(type);
					})) continue;
					const edit = yield provider.provideDocumentPasteEdits(model, selections, dataTransfer, tokenSource.token);
					if (originalDocVersion !== model.getVersionId()) return;
					if (edit) {
						performSnippetEdit(this._editor, typeof edit.insertText === "string" ? SnippetParser.escape(edit.insertText) : edit.insertText.snippet, selections);
						if (edit.additionalEdit) yield this._bulkEditService.apply(ResourceEdit.convert(edit.additionalEdit), { editor: this._editor });
						return;
					}
				}
				const textDataTransfer = (_c$1 = dataTransfer.get(Mimes.text)) !== null && _c$1 !== void 0 ? _c$1 : dataTransfer.get("text");
				if (!textDataTransfer) return;
				const text = yield textDataTransfer.asString();
				if (originalDocVersion !== model.getVersionId()) return;
				this._editor.trigger("keyboard", "paste", {
					text,
					pasteOnNewLine: metadata === null || metadata === void 0 ? void 0 : metadata.wasFromEmptySelection,
					multicursorText: null
				});
			} finally {
				tokenSource.dispose();
			}
		});
	}
};
CopyPasteController.ID = "editor.contrib.copyPasteActionController";
CopyPasteController = __decorate$51([
	__param$51(1, IBulkEditService),
	__param$51(2, IClipboardService),
	__param$51(3, IConfigurationService),
	__param$51(4, ILanguageFeaturesService)
], CopyPasteController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteContribution.js
registerEditorContribution(CopyPasteController.ID, CopyPasteController);
Registry.as(Extensions$1.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: { "editor.experimental.pasteActions.enabled": {
	type: "boolean",
	scope: 5,
	description: localize("pasteActions", "Enable/disable running edits from extensions on paste."),
	default: false
} } }));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/blockCommentCommand.js
var BlockCommentCommand = class BlockCommentCommand {
	constructor(selection, insertSpace, languageConfigurationService) {
		this.languageConfigurationService = languageConfigurationService;
		this._selection = selection;
		this._insertSpace = insertSpace;
		this._usedEndToken = null;
	}
	static _haystackHasNeedleAtOffset(haystack, needle, offset) {
		if (offset < 0) return false;
		const needleLength = needle.length;
		const haystackLength = haystack.length;
		if (offset + needleLength > haystackLength) return false;
		for (let i = 0; i < needleLength; i++) {
			const codeA = haystack.charCodeAt(offset + i);
			const codeB = needle.charCodeAt(i);
			if (codeA === codeB) continue;
			if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) continue;
			if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) continue;
			return false;
		}
		return true;
	}
	_createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
		const startLineNumber = selection.startLineNumber;
		const startColumn = selection.startColumn;
		const endLineNumber = selection.endLineNumber;
		const endColumn = selection.endColumn;
		const startLineText = model.getLineContent(startLineNumber);
		const endLineText = model.getLineContent(endLineNumber);
		let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
		let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
		if (startTokenIndex !== -1 && endTokenIndex !== -1) if (startLineNumber === endLineNumber) {
			if (startLineText.substring(startTokenIndex + startToken.length, endTokenIndex).indexOf(endToken) >= 0) {
				startTokenIndex = -1;
				endTokenIndex = -1;
			}
		} else {
			const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
			const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
			if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
				startTokenIndex = -1;
				endTokenIndex = -1;
			}
		}
		let ops;
		if (startTokenIndex !== -1 && endTokenIndex !== -1) {
			if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) startToken = startToken + " ";
			if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
				endToken = " " + endToken;
				endTokenIndex -= 1;
			}
			ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range$1(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
		} else {
			ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
			this._usedEndToken = ops.length === 1 ? endToken : null;
		}
		for (const op of ops) builder.addTrackedEditOperation(op.range, op.text);
	}
	static _createRemoveBlockCommentOperations(r, startToken, endToken) {
		const res = [];
		if (!Range$1.isEmpty(r)) {
			res.push(EditOperation.delete(new Range$1(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
			res.push(EditOperation.delete(new Range$1(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
		} else res.push(EditOperation.delete(new Range$1(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
		return res;
	}
	static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
		const res = [];
		if (!Range$1.isEmpty(r)) {
			res.push(EditOperation.insert(new Position$1(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
			res.push(EditOperation.insert(new Position$1(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
		} else res.push(EditOperation.replace(new Range$1(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
		return res;
	}
	getEditOperations(model, builder) {
		const startLineNumber = this._selection.startLineNumber;
		const startColumn = this._selection.startColumn;
		model.tokenization.tokenizeIfCheap(startLineNumber);
		const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
		const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
		if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) return;
		this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
	}
	computeCursorState(model, helper) {
		const inverseEditOperations = helper.getInverseEditOperations();
		if (inverseEditOperations.length === 2) {
			const startTokenEditOperation = inverseEditOperations[0];
			const endTokenEditOperation = inverseEditOperations[1];
			return new Selection$1(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
		} else {
			const srcRange = inverseEditOperations[0].range;
			const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
			return new Selection$1(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js
var LineCommentCommand = class LineCommentCommand {
	constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
		this.languageConfigurationService = languageConfigurationService;
		this._selection = selection;
		this._tabSize = tabSize;
		this._type = type;
		this._insertSpace = insertSpace;
		this._selectionId = null;
		this._deltaColumn = 0;
		this._moveEndPositionDown = false;
		this._ignoreEmptyLines = ignoreEmptyLines;
		this._ignoreFirstLine = ignoreFirstLine || false;
	}
	/**
	* Do an initial pass over the lines and gather info about the line comment string.
	* Returns null if any of the lines doesn't support a line comment string.
	*/
	static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {
		model.tokenization.tokenizeIfCheap(startLineNumber);
		const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
		const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;
		const commentStr = config ? config.lineCommentToken : null;
		if (!commentStr) return null;
		const lines = [];
		for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) lines[i] = {
			ignore: false,
			commentStr,
			commentStrOffset: 0,
			commentStrLength: commentStr.length
		};
		return lines;
	}
	/**
	* Analyze lines and decide which lines are relevant and what the toggle should do.
	* Also, build up several offsets and lengths useful in the generation of editor operations.
	*/
	static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
		let onlyWhitespaceLines = true;
		let shouldRemoveComments;
		if (type === 0) shouldRemoveComments = true;
		else if (type === 1) shouldRemoveComments = false;
		else shouldRemoveComments = true;
		for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
			const lineData = lines[i];
			const lineNumber = startLineNumber + i;
			if (lineNumber === startLineNumber && ignoreFirstLine) {
				lineData.ignore = true;
				continue;
			}
			const lineContent = model.getLineContent(lineNumber);
			const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
			if (lineContentStartOffset === -1) {
				lineData.ignore = ignoreEmptyLines;
				lineData.commentStrOffset = lineContent.length;
				continue;
			}
			onlyWhitespaceLines = false;
			lineData.ignore = false;
			lineData.commentStrOffset = lineContentStartOffset;
			if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) if (type === 0) shouldRemoveComments = false;
			else if (type === 1) {} else lineData.ignore = true;
			if (shouldRemoveComments && insertSpace) {
				const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
				if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) lineData.commentStrLength += 1;
			}
		}
		if (type === 0 && onlyWhitespaceLines) {
			shouldRemoveComments = false;
			for (let i = 0, lineCount = lines.length; i < lineCount; i++) lines[i].ignore = false;
		}
		return {
			supported: true,
			shouldRemoveComments,
			lines
		};
	}
	/**
	* Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
	*/
	static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
		const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);
		if (lines === null) return { supported: false };
		return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);
	}
	/**
	* Given a successful analysis, execute either insert line comments, either remove line comments
	*/
	_executeLineComments(model, builder, data, s) {
		let ops;
		if (data.shouldRemoveComments) ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
		else {
			LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
			ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
		}
		const cursorPosition = new Position$1(s.positionLineNumber, s.positionColumn);
		for (let i = 0, len = ops.length; i < len; i++) {
			builder.addEditOperation(ops[i].range, ops[i].text);
			if (Range$1.isEmpty(ops[i].range) && Range$1.getStartPosition(ops[i].range).equals(cursorPosition)) {
				if (model.getLineContent(cursorPosition.lineNumber).length + 1 === cursorPosition.column) this._deltaColumn = (ops[i].text || "").length;
			}
		}
		this._selectionId = builder.trackSelection(s);
	}
	_attemptRemoveBlockComment(model, s, startToken, endToken) {
		let startLineNumber = s.startLineNumber;
		let endLineNumber = s.endLineNumber;
		const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
		let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
		let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
		if (startTokenIndex !== -1 && endTokenIndex === -1) {
			endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
			endLineNumber = startLineNumber;
		}
		if (startTokenIndex === -1 && endTokenIndex !== -1) {
			startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
			startLineNumber = endLineNumber;
		}
		if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
			startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
			if (startTokenIndex !== -1) endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
		}
		if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) startToken += " ";
		if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
			endToken = " " + endToken;
			endTokenIndex -= 1;
		}
		if (startTokenIndex !== -1 && endTokenIndex !== -1) return BlockCommentCommand._createRemoveBlockCommentOperations(new Range$1(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
		return null;
	}
	/**
	* Given an unsuccessful analysis, delegate to the block comment command
	*/
	_executeBlockComment(model, builder, s) {
		model.tokenization.tokenizeIfCheap(s.startLineNumber);
		const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
		const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
		if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) return;
		const startToken = config.blockCommentStartToken;
		const endToken = config.blockCommentEndToken;
		let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
		if (!ops) {
			if (s.isEmpty()) {
				const lineContent = model.getLineContent(s.startLineNumber);
				let firstNonWhitespaceIndex$1 = firstNonWhitespaceIndex(lineContent);
				if (firstNonWhitespaceIndex$1 === -1) firstNonWhitespaceIndex$1 = lineContent.length;
				ops = BlockCommentCommand._createAddBlockCommentOperations(new Range$1(s.startLineNumber, firstNonWhitespaceIndex$1 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
			} else ops = BlockCommentCommand._createAddBlockCommentOperations(new Range$1(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
			if (ops.length === 1) this._deltaColumn = startToken.length + 1;
		}
		this._selectionId = builder.trackSelection(s);
		for (const op of ops) builder.addEditOperation(op.range, op.text);
	}
	getEditOperations(model, builder) {
		let s = this._selection;
		this._moveEndPositionDown = false;
		if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
			builder.addEditOperation(new Range$1(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
			this._selectionId = builder.trackSelection(s);
			return;
		}
		if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
			this._moveEndPositionDown = true;
			s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
		}
		const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
		if (data.supported) return this._executeLineComments(model, builder, data, s);
		return this._executeBlockComment(model, builder, s);
	}
	computeCursorState(model, helper) {
		let result = helper.getTrackedSelection(this._selectionId);
		if (this._moveEndPositionDown) result = result.setEndPosition(result.endLineNumber + 1, 1);
		return new Selection$1(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
	}
	/**
	* Generate edit operations in the remove line comment case
	*/
	static _createRemoveLineCommentsOperations(lines, startLineNumber) {
		const res = [];
		for (let i = 0, len = lines.length; i < len; i++) {
			const lineData = lines[i];
			if (lineData.ignore) continue;
			res.push(EditOperation.delete(new Range$1(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
		}
		return res;
	}
	/**
	* Generate edit operations in the add line comment case
	*/
	_createAddLineCommentsOperations(lines, startLineNumber) {
		const res = [];
		const afterCommentStr = this._insertSpace ? " " : "";
		for (let i = 0, len = lines.length; i < len; i++) {
			const lineData = lines[i];
			if (lineData.ignore) continue;
			res.push(EditOperation.insert(new Position$1(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
		}
		return res;
	}
	static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
		if (isTab) return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
		return currentVisibleColumn + columnSize;
	}
	/**
	* Adjust insertion points to have them vertically aligned in the add line comment case
	*/
	static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
		let minVisibleColumn = 1073741824;
		let j;
		let lenJ;
		for (let i = 0, len = lines.length; i < len; i++) {
			if (lines[i].ignore) continue;
			const lineContent = model.getLineContent(startLineNumber + i);
			let currentVisibleColumn = 0;
			for (let j$1 = 0, lenJ$1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j$1 < lenJ$1; j$1++) currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j$1) === 9, 1);
			if (currentVisibleColumn < minVisibleColumn) minVisibleColumn = currentVisibleColumn;
		}
		minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
		for (let i = 0, len = lines.length; i < len; i++) {
			if (lines[i].ignore) continue;
			const lineContent = model.getLineContent(startLineNumber + i);
			let currentVisibleColumn = 0;
			for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
			if (currentVisibleColumn > minVisibleColumn) lines[i].commentStrOffset = j - 1;
			else lines[i].commentStrOffset = j;
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
var CommentLineAction = class extends EditorAction {
	constructor(type, opts) {
		super(opts);
		this._type = type;
	}
	run(accessor, editor$1) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		if (!editor$1.hasModel()) return;
		const model = editor$1.getModel();
		const commands = [];
		const modelOptions = model.getOptions();
		const commentsOptions = editor$1.getOption(19);
		const selections = editor$1.getSelections().map((selection, index) => ({
			selection,
			index,
			ignoreFirstLine: false
		}));
		selections.sort((a, b) => Range$1.compareRangesUsingStarts(a.selection, b.selection));
		let prev = selections[0];
		for (let i = 1; i < selections.length; i++) {
			const curr = selections[i];
			if (prev.selection.endLineNumber === curr.selection.startLineNumber) if (prev.index < curr.index) curr.ignoreFirstLine = true;
			else {
				prev.ignoreFirstLine = true;
				prev = curr;
			}
		}
		for (const selection of selections) commands.push(new LineCommentCommand(languageConfigurationService, selection.selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var ToggleCommentLineAction = class extends CommentLineAction {
	constructor() {
		super(0, {
			id: "editor.action.commentLine",
			label: localize("comment.line", "Toggle Line Comment"),
			alias: "Toggle Line Comment",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2133,
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarEditMenu,
				group: "5_insert",
				title: localize({
					key: "miToggleLineComment",
					comment: ["&& denotes a mnemonic"]
				}, "&&Toggle Line Comment"),
				order: 1
			}
		});
	}
};
var AddLineCommentAction = class extends CommentLineAction {
	constructor() {
		super(1, {
			id: "editor.action.addCommentLine",
			label: localize("comment.line.add", "Add Line Comment"),
			alias: "Add Line Comment",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2081),
				weight: 100
			}
		});
	}
};
var RemoveLineCommentAction = class extends CommentLineAction {
	constructor() {
		super(2, {
			id: "editor.action.removeCommentLine",
			label: localize("comment.line.remove", "Remove Line Comment"),
			alias: "Remove Line Comment",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2099),
				weight: 100
			}
		});
	}
};
var BlockCommentAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.blockComment",
			label: localize("comment.block", "Toggle Block Comment"),
			alias: "Toggle Block Comment",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1567,
				linux: { primary: 3103 },
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarEditMenu,
				group: "5_insert",
				title: localize({
					key: "miToggleBlockComment",
					comment: ["&& denotes a mnemonic"]
				}, "Toggle &&Block Comment"),
				order: 2
			}
		});
	}
	run(accessor, editor$1) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		if (!editor$1.hasModel()) return;
		const commentsOptions = editor$1.getOption(19);
		const commands = [];
		const selections = editor$1.getSelections();
		for (const selection of selections) commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace, languageConfigurationService));
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/browser/contextmenu.js
var __decorate$50 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$50 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var ContextMenuController = class ContextMenuController$1 {
	constructor(editor$1, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService, _configurationService) {
		this._contextMenuService = _contextMenuService;
		this._contextViewService = _contextViewService;
		this._contextKeyService = _contextKeyService;
		this._keybindingService = _keybindingService;
		this._menuService = _menuService;
		this._configurationService = _configurationService;
		this._toDispose = new DisposableStore();
		this._contextMenuIsBeingShownCount = 0;
		this._editor = editor$1;
		this._toDispose.add(this._editor.onContextMenu((e) => this._onContextMenu(e)));
		this._toDispose.add(this._editor.onMouseWheel((e) => {
			if (this._contextMenuIsBeingShownCount > 0) {
				const view = this._contextViewService.getContextViewElement();
				const target = e.srcElement;
				if (!(target.shadowRoot && getShadowRoot(view) === target.shadowRoot)) this._contextViewService.hideContextView();
			}
		}));
		this._toDispose.add(this._editor.onKeyDown((e) => {
			if (!this._editor.getOption(20)) return;
			if (e.keyCode === 58) {
				e.preventDefault();
				e.stopPropagation();
				this.showContextMenu();
			}
		}));
	}
	static get(editor$1) {
		return editor$1.getContribution(ContextMenuController$1.ID);
	}
	_onContextMenu(e) {
		if (!this._editor.hasModel()) return;
		if (!this._editor.getOption(20)) {
			this._editor.focus();
			if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) this._editor.setPosition(e.target.position);
			return;
		}
		if (e.target.type === 12) return;
		if (e.target.type === 6 && e.target.detail.injectedText) return;
		e.event.preventDefault();
		e.event.stopPropagation();
		if (e.target.type === 11) return this._showScrollbarContextMenu({
			x: e.event.posx - 1,
			width: 2,
			y: e.event.posy - 1,
			height: 2
		});
		if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1) return;
		this._editor.focus();
		if (e.target.position) {
			let hasSelectionAtPosition = false;
			for (const selection of this._editor.getSelections()) if (selection.containsPosition(e.target.position)) {
				hasSelectionAtPosition = true;
				break;
			}
			if (!hasSelectionAtPosition) this._editor.setPosition(e.target.position);
		}
		let anchor = null;
		if (e.target.type !== 1) anchor = {
			x: e.event.posx - 1,
			width: 2,
			y: e.event.posy - 1,
			height: 2
		};
		this.showContextMenu(anchor);
	}
	showContextMenu(anchor) {
		if (!this._editor.getOption(20)) return;
		if (!this._editor.hasModel()) return;
		const menuActions = this._getMenuActions(this._editor.getModel(), this._editor.isSimpleWidget ? MenuId.SimpleEditorContext : MenuId.EditorContext);
		if (menuActions.length > 0) this._doShowContextMenu(menuActions, anchor);
	}
	_getMenuActions(model, menuId) {
		const result = [];
		const menu = this._menuService.createMenu(menuId, this._contextKeyService);
		const groups = menu.getActions({ arg: model.uri });
		menu.dispose();
		for (const group of groups) {
			const [, actions] = group;
			let addedItems = 0;
			for (const action of actions) if (action instanceof SubmenuItemAction) {
				const subActions = this._getMenuActions(model, action.item.submenu);
				if (subActions.length > 0) {
					result.push(new SubmenuAction(action.id, action.label, subActions));
					addedItems++;
				}
			} else {
				result.push(action);
				addedItems++;
			}
			if (addedItems) result.push(new Separator());
		}
		if (result.length) result.pop();
		return result;
	}
	_doShowContextMenu(actions, anchor = null) {
		if (!this._editor.hasModel()) return;
		const oldHoverSetting = this._editor.getOption(55);
		this._editor.updateOptions({ hover: { enabled: false } });
		if (!anchor) {
			this._editor.revealPosition(this._editor.getPosition(), 1);
			this._editor.render();
			const cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
			const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
			anchor = {
				x: editorCoords.left + cursorCoords.left,
				y: editorCoords.top + cursorCoords.top + cursorCoords.height
			};
		}
		const useShadowDOM = this._editor.getOption(117) && !isIOS;
		this._contextMenuIsBeingShownCount++;
		this._contextMenuService.showContextMenu({
			domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
			getAnchor: () => anchor,
			getActions: () => actions,
			getActionViewItem: (action) => {
				const keybinding = this._keybindingFor(action);
				if (keybinding) return new ActionViewItem(action, action, {
					label: true,
					keybinding: keybinding.getLabel(),
					isMenu: true
				});
				const customActionViewItem = action;
				if (typeof customActionViewItem.getActionViewItem === "function") return customActionViewItem.getActionViewItem();
				return new ActionViewItem(action, action, {
					icon: true,
					label: true,
					isMenu: true
				});
			},
			getKeyBinding: (action) => {
				return this._keybindingFor(action);
			},
			onHide: (wasCancelled) => {
				this._contextMenuIsBeingShownCount--;
				this._editor.focus();
				this._editor.updateOptions({ hover: oldHoverSetting });
			}
		});
	}
	_showScrollbarContextMenu(anchor) {
		if (!this._editor.hasModel()) return;
		const minimapOptions = this._editor.getOption(67);
		let lastId = 0;
		const createAction = (opts) => {
			return {
				id: `menu-action-${++lastId}`,
				label: opts.label,
				tooltip: "",
				class: void 0,
				enabled: typeof opts.enabled === "undefined" ? true : opts.enabled,
				checked: opts.checked,
				run: opts.run,
				dispose: () => null
			};
		};
		const createSubmenuAction = (label, actions$1) => {
			return new SubmenuAction(`menu-action-${++lastId}`, label, actions$1, void 0);
		};
		const createEnumAction = (label, enabled, configName, configuredValue, options) => {
			if (!enabled) return createAction({
				label,
				enabled,
				run: () => {}
			});
			const createRunner = (value) => {
				return () => {
					this._configurationService.updateValue(configName, value);
				};
			};
			const actions$1 = [];
			for (const option of options) actions$1.push(createAction({
				label: option.label,
				checked: configuredValue === option.value,
				run: createRunner(option.value)
			}));
			return createSubmenuAction(label, actions$1);
		};
		const actions = [];
		actions.push(createAction({
			label: localize("context.minimap.minimap", "Minimap"),
			checked: minimapOptions.enabled,
			run: () => {
				this._configurationService.updateValue(`editor.minimap.enabled`, !minimapOptions.enabled);
			}
		}));
		actions.push(new Separator());
		actions.push(createAction({
			label: localize("context.minimap.renderCharacters", "Render Characters"),
			enabled: minimapOptions.enabled,
			checked: minimapOptions.renderCharacters,
			run: () => {
				this._configurationService.updateValue(`editor.minimap.renderCharacters`, !minimapOptions.renderCharacters);
			}
		}));
		actions.push(createEnumAction(localize("context.minimap.size", "Vertical size"), minimapOptions.enabled, "editor.minimap.size", minimapOptions.size, [
			{
				label: localize("context.minimap.size.proportional", "Proportional"),
				value: "proportional"
			},
			{
				label: localize("context.minimap.size.fill", "Fill"),
				value: "fill"
			},
			{
				label: localize("context.minimap.size.fit", "Fit"),
				value: "fit"
			}
		]));
		actions.push(createEnumAction(localize("context.minimap.slider", "Slider"), minimapOptions.enabled, "editor.minimap.showSlider", minimapOptions.showSlider, [{
			label: localize("context.minimap.slider.mouseover", "Mouse Over"),
			value: "mouseover"
		}, {
			label: localize("context.minimap.slider.always", "Always"),
			value: "always"
		}]));
		const useShadowDOM = this._editor.getOption(117) && !isIOS;
		this._contextMenuIsBeingShownCount++;
		this._contextMenuService.showContextMenu({
			domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
			getAnchor: () => anchor,
			getActions: () => actions,
			onHide: (wasCancelled) => {
				this._contextMenuIsBeingShownCount--;
				this._editor.focus();
			}
		});
	}
	_keybindingFor(action) {
		return this._keybindingService.lookupKeybinding(action.id);
	}
	dispose() {
		if (this._contextMenuIsBeingShownCount > 0) this._contextViewService.hideContextView();
		this._toDispose.dispose();
	}
};
ContextMenuController.ID = "editor.contrib.contextmenu";
ContextMenuController = __decorate$50([
	__param$50(1, IContextMenuService),
	__param$50(2, IContextViewService),
	__param$50(3, IContextKeyService),
	__param$50(4, IKeybindingService),
	__param$50(5, IMenuService),
	__param$50(6, IConfigurationService)
], ContextMenuController);
var ShowContextMenu = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.showContextMenu",
			label: localize("action.showContextMenu.label", "Show Editor Context Menu"),
			alias: "Show Editor Context Menu",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 1092,
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		var _a$5;
		(_a$5 = ContextMenuController.get(editor$1)) === null || _a$5 === void 0 || _a$5.showContextMenu();
	}
};
registerEditorContribution(ContextMenuController.ID, ContextMenuController);
registerEditorAction(ShowContextMenu);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/browser/cursorUndo.js
var CursorState$1 = class {
	constructor(selections) {
		this.selections = selections;
	}
	equals(other) {
		const thisLen = this.selections.length;
		if (thisLen !== other.selections.length) return false;
		for (let i = 0; i < thisLen; i++) if (!this.selections[i].equalsSelection(other.selections[i])) return false;
		return true;
	}
};
var StackElement = class {
	constructor(cursorState, scrollTop, scrollLeft) {
		this.cursorState = cursorState;
		this.scrollTop = scrollTop;
		this.scrollLeft = scrollLeft;
	}
};
var CursorUndoRedoController = class CursorUndoRedoController extends Disposable {
	constructor(editor$1) {
		super();
		this._editor = editor$1;
		this._isCursorUndoRedo = false;
		this._undoStack = [];
		this._redoStack = [];
		this._register(editor$1.onDidChangeModel((e) => {
			this._undoStack = [];
			this._redoStack = [];
		}));
		this._register(editor$1.onDidChangeModelContent((e) => {
			this._undoStack = [];
			this._redoStack = [];
		}));
		this._register(editor$1.onDidChangeCursorSelection((e) => {
			if (this._isCursorUndoRedo) return;
			if (!e.oldSelections) return;
			if (e.oldModelVersionId !== e.modelVersionId) return;
			const prevState = new CursorState$1(e.oldSelections);
			if (!(this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState))) {
				this._undoStack.push(new StackElement(prevState, editor$1.getScrollTop(), editor$1.getScrollLeft()));
				this._redoStack = [];
				if (this._undoStack.length > 50) this._undoStack.shift();
			}
		}));
	}
	static get(editor$1) {
		return editor$1.getContribution(CursorUndoRedoController.ID);
	}
	cursorUndo() {
		if (!this._editor.hasModel() || this._undoStack.length === 0) return;
		this._redoStack.push(new StackElement(new CursorState$1(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
		this._applyState(this._undoStack.pop());
	}
	cursorRedo() {
		if (!this._editor.hasModel() || this._redoStack.length === 0) return;
		this._undoStack.push(new StackElement(new CursorState$1(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
		this._applyState(this._redoStack.pop());
	}
	_applyState(stackElement) {
		this._isCursorUndoRedo = true;
		this._editor.setSelections(stackElement.cursorState.selections);
		this._editor.setScrollPosition({
			scrollTop: stackElement.scrollTop,
			scrollLeft: stackElement.scrollLeft
		});
		this._isCursorUndoRedo = false;
	}
};
CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
var CursorUndo = class extends EditorAction {
	constructor() {
		super({
			id: "cursorUndo",
			label: localize("cursor.undo", "Cursor Undo"),
			alias: "Cursor Undo",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 2099,
				weight: 100
			}
		});
	}
	run(accessor, editor$1, args) {
		var _a$5;
		(_a$5 = CursorUndoRedoController.get(editor$1)) === null || _a$5 === void 0 || _a$5.cursorUndo();
	}
};
var CursorRedo = class extends EditorAction {
	constructor() {
		super({
			id: "cursorRedo",
			label: localize("cursor.redo", "Cursor Redo"),
			alias: "Cursor Redo",
			precondition: void 0
		});
	}
	run(accessor, editor$1, args) {
		var _a$5;
		(_a$5 = CursorUndoRedoController.get(editor$1)) === null || _a$5 === void 0 || _a$5.cursorRedo();
	}
};
registerEditorContribution(CursorUndoRedoController.ID, CursorUndoRedoController);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dragAndDropCommand.js
var DragAndDropCommand = class {
	constructor(selection, targetPosition, copy) {
		this.selection = selection;
		this.targetPosition = targetPosition;
		this.copy = copy;
		this.targetSelection = null;
	}
	getEditOperations(model, builder) {
		const text = model.getValueInRange(this.selection);
		if (!this.copy) builder.addEditOperation(this.selection, null);
		builder.addEditOperation(new Range$1(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
		if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
			this.targetSelection = this.selection;
			return;
		}
		if (this.copy) {
			this.targetSelection = new Selection$1(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
			return;
		}
		if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
			this.targetSelection = new Selection$1(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
			return;
		}
		if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
			this.targetSelection = new Selection$1(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
			return;
		}
		if (this.selection.endColumn <= this.targetPosition.column) this.targetSelection = new Selection$1(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
		else this.targetSelection = new Selection$1(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
	}
	computeCursorState(model, helper) {
		return this.targetSelection;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
function hasTriggerModifier(e) {
	if (isMacintosh) return e.altKey;
	else return e.ctrlKey;
}
var DragAndDropController = class DragAndDropController extends Disposable {
	constructor(editor$1) {
		super();
		this._editor = editor$1;
		this._dndDecorationIds = this._editor.createDecorationsCollection();
		this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
		this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
		this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
		this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
		this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
		this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
		this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
		this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
		this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
		this._mouseDown = false;
		this._modifierPressed = false;
		this._dragSelection = null;
	}
	onEditorBlur() {
		this._removeDecoration();
		this._dragSelection = null;
		this._mouseDown = false;
		this._modifierPressed = false;
	}
	onEditorKeyDown(e) {
		if (!this._editor.getOption(31) || this._editor.getOption(18)) return;
		if (hasTriggerModifier(e)) this._modifierPressed = true;
		if (this._mouseDown && hasTriggerModifier(e)) this._editor.updateOptions({ mouseStyle: "copy" });
	}
	onEditorKeyUp(e) {
		if (!this._editor.getOption(31) || this._editor.getOption(18)) return;
		if (hasTriggerModifier(e)) this._modifierPressed = false;
		if (this._mouseDown && e.keyCode === DragAndDropController.TRIGGER_KEY_VALUE) this._editor.updateOptions({ mouseStyle: "default" });
	}
	_onEditorMouseDown(mouseEvent) {
		this._mouseDown = true;
	}
	_onEditorMouseUp(mouseEvent) {
		this._mouseDown = false;
		this._editor.updateOptions({ mouseStyle: "text" });
	}
	_onEditorMouseDrag(mouseEvent) {
		const target = mouseEvent.target;
		if (this._dragSelection === null) {
			const possibleSelections = (this._editor.getSelections() || []).filter((selection) => target.position && selection.containsPosition(target.position));
			if (possibleSelections.length === 1) this._dragSelection = possibleSelections[0];
			else return;
		}
		if (hasTriggerModifier(mouseEvent.event)) this._editor.updateOptions({ mouseStyle: "copy" });
		else this._editor.updateOptions({ mouseStyle: "default" });
		if (target.position) if (this._dragSelection.containsPosition(target.position)) this._removeDecoration();
		else this.showAt(target.position);
	}
	_onEditorMouseDropCanceled() {
		this._editor.updateOptions({ mouseStyle: "text" });
		this._removeDecoration();
		this._dragSelection = null;
		this._mouseDown = false;
	}
	_onEditorMouseDrop(mouseEvent) {
		if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
			const newCursorPosition = new Position$1(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
			if (this._dragSelection === null) {
				let newSelections = null;
				if (mouseEvent.event.shiftKey) {
					const primarySelection = this._editor.getSelection();
					if (primarySelection) {
						const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
						newSelections = [new Selection$1(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
					}
				} else newSelections = (this._editor.getSelections() || []).map((selection) => {
					if (selection.containsPosition(newCursorPosition)) return new Selection$1(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
					else return selection;
				});
				this._editor.setSelections(newSelections || [], "mouse", 3);
			} else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
				this._editor.pushUndoStop();
				this._editor.executeCommand(DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
				this._editor.pushUndoStop();
			}
		}
		this._editor.updateOptions({ mouseStyle: "text" });
		this._removeDecoration();
		this._dragSelection = null;
		this._mouseDown = false;
	}
	showAt(position) {
		this._dndDecorationIds.set([{
			range: new Range$1(position.lineNumber, position.column, position.lineNumber, position.column),
			options: DragAndDropController._DECORATION_OPTIONS
		}]);
		this._editor.revealPosition(position, 1);
	}
	_removeDecoration() {
		this._dndDecorationIds.clear();
	}
	_hitContent(target) {
		return target.type === 6 || target.type === 7;
	}
	_hitMargin(target) {
		return target.type === 2 || target.type === 3 || target.type === 4;
	}
	dispose() {
		this._removeDecoration();
		this._dragSelection = null;
		this._mouseDown = false;
		this._modifierPressed = false;
		super.dispose();
	}
};
DragAndDropController.ID = "editor.contrib.dragAndDrop";
DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
	description: "dnd-target",
	className: "dnd-target"
});
registerEditorContribution(DragAndDropController.ID, DragAndDropController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/dropIntoEditor/browser/dropIntoEditorContribution.js
var __decorate$49 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$49 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$32 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var DropIntoEditorController = class DropIntoEditorController$1 extends Disposable {
	constructor(editor$1, _bulkEditService, _languageFeaturesService, _progressService, workspaceContextService) {
		super();
		this._bulkEditService = _bulkEditService;
		this._languageFeaturesService = _languageFeaturesService;
		this._progressService = _progressService;
		this._register(editor$1.onDropIntoEditor((e) => this.onDropIntoEditor(editor$1, e.position, e.event)));
		this._languageFeaturesService.documentOnDropEditProvider.register("*", new DefaultOnDropProvider(workspaceContextService));
	}
	onDropIntoEditor(editor$1, position, dragEvent) {
		return __awaiter$32(this, void 0, void 0, function* () {
			if (!dragEvent.dataTransfer || !editor$1.hasModel()) return;
			const model = editor$1.getModel();
			const initialModelVersion = model.getVersionId();
			const ourDataTransfer = yield this.extractDataTransferData(dragEvent);
			if (ourDataTransfer.size === 0) return;
			if (editor$1.getModel().getVersionId() !== initialModelVersion) return;
			const tokenSource = new EditorStateCancellationTokenSource(editor$1, 1);
			try {
				const providers = this._languageFeaturesService.documentOnDropEditProvider.ordered(model);
				const edit = yield this._progressService.withProgress({
					location: 15,
					delay: 750,
					title: localize("dropProgressTitle", "Running drop handlers..."),
					cancellable: true
				}, () => {
					return raceCancellation((() => __awaiter$32(this, void 0, void 0, function* () {
						for (const provider of providers) {
							const edit$1 = yield provider.provideDocumentOnDropEdits(model, position, ourDataTransfer, tokenSource.token);
							if (tokenSource.token.isCancellationRequested) return;
							if (edit$1) return edit$1;
						}
					}))(), tokenSource.token);
				}, () => {
					tokenSource.cancel();
				});
				if (tokenSource.token.isCancellationRequested || editor$1.getModel().getVersionId() !== initialModelVersion) return;
				if (edit) {
					const range = new Range$1(position.lineNumber, position.column, position.lineNumber, position.column);
					performSnippetEdit(editor$1, typeof edit.insertText === "string" ? SnippetParser.escape(edit.insertText) : edit.insertText.snippet, [Selection$1.fromRange(range, 0)]);
					if (edit.additionalEdit) yield this._bulkEditService.apply(ResourceEdit.convert(edit.additionalEdit), { editor: editor$1 });
					return;
				}
			} finally {
				tokenSource.dispose();
			}
		});
	}
	extractDataTransferData(dragEvent) {
		return __awaiter$32(this, void 0, void 0, function* () {
			if (!dragEvent.dataTransfer) return new VSDataTransfer();
			const textEditorDataTransfer = toVSDataTransfer(dragEvent.dataTransfer);
			addExternalEditorsDropData(textEditorDataTransfer, dragEvent);
			return textEditorDataTransfer;
		});
	}
};
DropIntoEditorController.ID = "editor.contrib.dropIntoEditorController";
DropIntoEditorController = __decorate$49([
	__param$49(1, IBulkEditService),
	__param$49(2, ILanguageFeaturesService),
	__param$49(3, IProgressService),
	__param$49(4, IWorkspaceContextService)
], DropIntoEditorController);
var DefaultOnDropProvider = class DefaultOnDropProvider$1 {
	constructor(_workspaceContextService) {
		this._workspaceContextService = _workspaceContextService;
	}
	provideDocumentOnDropEdits(_model, _position, dataTransfer, _token) {
		var _a$5;
		return __awaiter$32(this, void 0, void 0, function* () {
			const urlListEntry = dataTransfer.get(Mimes.uriList);
			if (urlListEntry) {
				const urlList = yield urlListEntry.asString();
				const snippet = this.getUriListInsertText(urlList);
				if (snippet) return { insertText: snippet };
			}
			const textEntry = (_a$5 = dataTransfer.get("text")) !== null && _a$5 !== void 0 ? _a$5 : dataTransfer.get(Mimes.text);
			if (textEntry) return { insertText: yield textEntry.asString() };
		});
	}
	getUriListInsertText(strUriList) {
		const uris = [];
		for (const resource of UriList.parse(strUriList)) try {
			uris.push(URI.parse(resource));
		} catch (_a$5) {}
		if (!uris.length) return;
		return uris.map((uri) => {
			const root = this._workspaceContextService.getWorkspaceFolder(uri);
			if (root) {
				const rel = relativePath(root.uri, uri);
				if (rel) return rel;
			}
			return uri.fsPath;
		}).join(" ");
	}
};
DefaultOnDropProvider = __decorate$49([__param$49(0, IWorkspaceContextService)], DefaultOnDropProvider);
registerEditorContribution(DropIntoEditorController.ID, DropIntoEditorController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findDecorations.js
var FindDecorations = class FindDecorations {
	constructor(editor$1) {
		this._editor = editor$1;
		this._decorations = [];
		this._overviewRulerApproximateDecorations = [];
		this._findScopeDecorationIds = [];
		this._rangeHighlightDecorationId = null;
		this._highlightedDecorationId = null;
		this._startPosition = this._editor.getPosition();
	}
	dispose() {
		this._editor.removeDecorations(this._allDecorations());
		this._decorations = [];
		this._overviewRulerApproximateDecorations = [];
		this._findScopeDecorationIds = [];
		this._rangeHighlightDecorationId = null;
		this._highlightedDecorationId = null;
	}
	reset() {
		this._decorations = [];
		this._overviewRulerApproximateDecorations = [];
		this._findScopeDecorationIds = [];
		this._rangeHighlightDecorationId = null;
		this._highlightedDecorationId = null;
	}
	getCount() {
		return this._decorations.length;
	}
	/** @deprecated use getFindScopes to support multiple selections */
	getFindScope() {
		if (this._findScopeDecorationIds[0]) return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
		return null;
	}
	getFindScopes() {
		if (this._findScopeDecorationIds.length) {
			const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
			if (scopes.length) return scopes;
		}
		return null;
	}
	getStartPosition() {
		return this._startPosition;
	}
	setStartPosition(newStartPosition) {
		this._startPosition = newStartPosition;
		this.setCurrentFindMatch(null);
	}
	_getDecorationIndex(decorationId) {
		const index = this._decorations.indexOf(decorationId);
		if (index >= 0) return index + 1;
		return 1;
	}
	getCurrentMatchesPosition(desiredRange) {
		const candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
		for (const candidate of candidates) {
			const candidateOpts = candidate.options;
			if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) return this._getDecorationIndex(candidate.id);
		}
		return 0;
	}
	setCurrentFindMatch(nextMatch) {
		let newCurrentDecorationId = null;
		let matchPosition = 0;
		if (nextMatch) for (let i = 0, len = this._decorations.length; i < len; i++) {
			const range = this._editor.getModel().getDecorationRange(this._decorations[i]);
			if (nextMatch.equalsRange(range)) {
				newCurrentDecorationId = this._decorations[i];
				matchPosition = i + 1;
				break;
			}
		}
		if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) this._editor.changeDecorations((changeAccessor) => {
			if (this._highlightedDecorationId !== null) {
				changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);
				this._highlightedDecorationId = null;
			}
			if (newCurrentDecorationId !== null) {
				this._highlightedDecorationId = newCurrentDecorationId;
				changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);
			}
			if (this._rangeHighlightDecorationId !== null) {
				changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
				this._rangeHighlightDecorationId = null;
			}
			if (newCurrentDecorationId !== null) {
				let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
				if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
					const lineBeforeEnd = rng.endLineNumber - 1;
					const lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
					rng = new Range$1(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
				}
				this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);
			}
		});
		return matchPosition;
	}
	set(findMatches, findScopes) {
		this._editor.changeDecorations((accessor) => {
			let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;
			const newOverviewRulerApproximateDecorations = [];
			if (findMatches.length > 1e3) {
				findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
				const lineCount = this._editor.getModel().getLineCount();
				const approxPixelsPerLine = this._editor.getLayoutInfo().height / lineCount;
				const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
				let prevStartLineNumber = findMatches[0].range.startLineNumber;
				let prevEndLineNumber = findMatches[0].range.endLineNumber;
				for (let i = 1, len = findMatches.length; i < len; i++) {
					const range = findMatches[i].range;
					if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
						if (range.endLineNumber > prevEndLineNumber) prevEndLineNumber = range.endLineNumber;
					} else {
						newOverviewRulerApproximateDecorations.push({
							range: new Range$1(prevStartLineNumber, 1, prevEndLineNumber, 1),
							options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
						});
						prevStartLineNumber = range.startLineNumber;
						prevEndLineNumber = range.endLineNumber;
					}
				}
				newOverviewRulerApproximateDecorations.push({
					range: new Range$1(prevStartLineNumber, 1, prevEndLineNumber, 1),
					options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
				});
			}
			const newFindMatchesDecorations = new Array(findMatches.length);
			for (let i = 0, len = findMatches.length; i < len; i++) newFindMatchesDecorations[i] = {
				range: findMatches[i].range,
				options: findMatchesOptions
			};
			this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
			this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
			if (this._rangeHighlightDecorationId) {
				accessor.removeDecoration(this._rangeHighlightDecorationId);
				this._rangeHighlightDecorationId = null;
			}
			if (this._findScopeDecorationIds.length) {
				this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
				this._findScopeDecorationIds = [];
			}
			if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));
		});
	}
	matchBeforePosition(position) {
		if (this._decorations.length === 0) return null;
		for (let i = this._decorations.length - 1; i >= 0; i--) {
			const decorationId = this._decorations[i];
			const r = this._editor.getModel().getDecorationRange(decorationId);
			if (!r || r.endLineNumber > position.lineNumber) continue;
			if (r.endLineNumber < position.lineNumber) return r;
			if (r.endColumn > position.column) continue;
			return r;
		}
		return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
	}
	matchAfterPosition(position) {
		if (this._decorations.length === 0) return null;
		for (let i = 0, len = this._decorations.length; i < len; i++) {
			const decorationId = this._decorations[i];
			const r = this._editor.getModel().getDecorationRange(decorationId);
			if (!r || r.startLineNumber < position.lineNumber) continue;
			if (r.startLineNumber > position.lineNumber) return r;
			if (r.startColumn < position.column) continue;
			return r;
		}
		return this._editor.getModel().getDecorationRange(this._decorations[0]);
	}
	_allDecorations() {
		let result = [];
		result = result.concat(this._decorations);
		result = result.concat(this._overviewRulerApproximateDecorations);
		if (this._findScopeDecorationIds.length) result.push(...this._findScopeDecorationIds);
		if (this._rangeHighlightDecorationId) result.push(this._rangeHighlightDecorationId);
		return result;
	}
};
FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
	description: "current-find-match",
	stickiness: 1,
	zIndex: 13,
	className: "currentFindMatch",
	showIfCollapsed: true,
	overviewRuler: {
		color: themeColorFromId(overviewRulerFindMatchForeground),
		position: OverviewRulerLane.Center
	},
	minimap: {
		color: themeColorFromId(minimapFindMatch),
		position: MinimapPosition.Inline
	}
});
FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
	description: "find-match",
	stickiness: 1,
	zIndex: 10,
	className: "findMatch",
	showIfCollapsed: true,
	overviewRuler: {
		color: themeColorFromId(overviewRulerFindMatchForeground),
		position: OverviewRulerLane.Center
	},
	minimap: {
		color: themeColorFromId(minimapFindMatch),
		position: MinimapPosition.Inline
	}
});
FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
	description: "find-match-no-overview",
	stickiness: 1,
	className: "findMatch",
	showIfCollapsed: true
});
FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
	description: "find-match-only-overview",
	stickiness: 1,
	overviewRuler: {
		color: themeColorFromId(overviewRulerFindMatchForeground),
		position: OverviewRulerLane.Center
	}
});
FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
	description: "find-range-highlight",
	stickiness: 1,
	className: "rangeHighlight",
	isWholeLine: true
});
FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
	description: "find-scope",
	className: "findScope",
	isWholeLine: true
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replaceAllCommand.js
var ReplaceAllCommand = class {
	constructor(editorSelection, ranges, replaceStrings) {
		this._editorSelection = editorSelection;
		this._ranges = ranges;
		this._replaceStrings = replaceStrings;
		this._trackedEditorSelectionId = null;
	}
	getEditOperations(model, builder) {
		if (this._ranges.length > 0) {
			const ops = [];
			for (let i = 0; i < this._ranges.length; i++) ops.push({
				range: this._ranges[i],
				text: this._replaceStrings[i]
			});
			ops.sort((o1, o2) => {
				return Range$1.compareRangesUsingStarts(o1.range, o2.range);
			});
			const resultOps = [];
			let previousOp = ops[0];
			for (let i = 1; i < ops.length; i++) if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
				previousOp.range = previousOp.range.plusRange(ops[i].range);
				previousOp.text = previousOp.text + ops[i].text;
			} else {
				resultOps.push(previousOp);
				previousOp = ops[i];
			}
			resultOps.push(previousOp);
			for (const op of resultOps) builder.addEditOperation(op.range, op.text);
		}
		this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
	}
	computeCursorState(model, helper) {
		return helper.getTrackedSelection(this._trackedEditorSelectionId);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/search.js
function buildReplaceStringWithCasePreserved(matches, pattern) {
	if (matches && matches[0] !== "") {
		const containsHyphens = validateSpecificSpecialCharacter(matches, pattern, "-");
		const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern, "_");
		if (containsHyphens && !containsUnderscores) return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "-");
		else if (!containsHyphens && containsUnderscores) return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "_");
		if (matches[0].toUpperCase() === matches[0]) return pattern.toUpperCase();
		else if (matches[0].toLowerCase() === matches[0]) return pattern.toLowerCase();
		else if (containsUppercaseCharacter(matches[0][0]) && pattern.length > 0) return pattern[0].toUpperCase() + pattern.substr(1);
		else if (matches[0][0].toUpperCase() !== matches[0][0] && pattern.length > 0) return pattern[0].toLowerCase() + pattern.substr(1);
		else return pattern;
	} else return pattern;
}
function validateSpecificSpecialCharacter(matches, pattern, specialCharacter) {
	return matches[0].indexOf(specialCharacter) !== -1 && pattern.indexOf(specialCharacter) !== -1 && matches[0].split(specialCharacter).length === pattern.split(specialCharacter).length;
}
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern, specialCharacter) {
	const splitPatternAtSpecialCharacter = pattern.split(specialCharacter);
	const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
	let replaceString = "";
	splitPatternAtSpecialCharacter.forEach((splitValue, index) => {
		replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index]], splitValue) + specialCharacter;
	});
	return replaceString.slice(0, -1);
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js
/**
* Assigned when the replace pattern is entirely static.
*/
var StaticValueReplacePattern = class {
	constructor(staticValue) {
		this.staticValue = staticValue;
		this.kind = 0;
	}
};
/**
* Assigned when the replace pattern has replacement patterns.
*/
var DynamicPiecesReplacePattern = class {
	constructor(pieces) {
		this.pieces = pieces;
		this.kind = 1;
	}
};
var ReplacePattern = class ReplacePattern {
	constructor(pieces) {
		if (!pieces || pieces.length === 0) this._state = new StaticValueReplacePattern("");
		else if (pieces.length === 1 && pieces[0].staticValue !== null) this._state = new StaticValueReplacePattern(pieces[0].staticValue);
		else this._state = new DynamicPiecesReplacePattern(pieces);
	}
	static fromStaticValue(value) {
		return new ReplacePattern([ReplacePiece.staticValue(value)]);
	}
	get hasReplacementPatterns() {
		return this._state.kind === 1;
	}
	buildReplaceString(matches, preserveCase) {
		if (this._state.kind === 0) if (preserveCase) return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
		else return this._state.staticValue;
		let result = "";
		for (let i = 0, len = this._state.pieces.length; i < len; i++) {
			const piece = this._state.pieces[i];
			if (piece.staticValue !== null) {
				result += piece.staticValue;
				continue;
			}
			let match = ReplacePattern._substitute(piece.matchIndex, matches);
			if (piece.caseOps !== null && piece.caseOps.length > 0) {
				const repl = [];
				const lenOps = piece.caseOps.length;
				let opIdx = 0;
				for (let idx = 0, len$1 = match.length; idx < len$1; idx++) {
					if (opIdx >= lenOps) {
						repl.push(match.slice(idx));
						break;
					}
					switch (piece.caseOps[opIdx]) {
						case "U":
							repl.push(match[idx].toUpperCase());
							break;
						case "u":
							repl.push(match[idx].toUpperCase());
							opIdx++;
							break;
						case "L":
							repl.push(match[idx].toLowerCase());
							break;
						case "l":
							repl.push(match[idx].toLowerCase());
							opIdx++;
							break;
						default: repl.push(match[idx]);
					}
				}
				match = repl.join("");
			}
			result += match;
		}
		return result;
	}
	static _substitute(matchIndex, matches) {
		if (matches === null) return "";
		if (matchIndex === 0) return matches[0];
		let remainder = "";
		while (matchIndex > 0) {
			if (matchIndex < matches.length) return (matches[matchIndex] || "") + remainder;
			remainder = String(matchIndex % 10) + remainder;
			matchIndex = Math.floor(matchIndex / 10);
		}
		return "$" + remainder;
	}
};
/**
* A replace piece can either be a static string or an index to a specific match.
*/
var ReplacePiece = class ReplacePiece {
	constructor(staticValue, matchIndex, caseOps) {
		this.staticValue = staticValue;
		this.matchIndex = matchIndex;
		if (!caseOps || caseOps.length === 0) this.caseOps = null;
		else this.caseOps = caseOps.slice(0);
	}
	static staticValue(value) {
		return new ReplacePiece(value, -1, null);
	}
	static caseOps(index, caseOps) {
		return new ReplacePiece(null, index, caseOps);
	}
};
var ReplacePieceBuilder = class {
	constructor(source) {
		this._source = source;
		this._lastCharIndex = 0;
		this._result = [];
		this._resultLen = 0;
		this._currentStaticPiece = "";
	}
	emitUnchanged(toCharIndex) {
		this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
		this._lastCharIndex = toCharIndex;
	}
	emitStatic(value, toCharIndex) {
		this._emitStatic(value);
		this._lastCharIndex = toCharIndex;
	}
	_emitStatic(value) {
		if (value.length === 0) return;
		this._currentStaticPiece += value;
	}
	emitMatchIndex(index, toCharIndex, caseOps) {
		if (this._currentStaticPiece.length !== 0) {
			this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
			this._currentStaticPiece = "";
		}
		this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);
		this._lastCharIndex = toCharIndex;
	}
	finalize() {
		this.emitUnchanged(this._source.length);
		if (this._currentStaticPiece.length !== 0) {
			this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
			this._currentStaticPiece = "";
		}
		return new ReplacePattern(this._result);
	}
};
/**
* \n			=> inserts a LF
* \t			=> inserts a TAB
* \\			=> inserts a "\".
* \u			=> upper-cases one character in a match.
* \U			=> upper-cases ALL remaining characters in a match.
* \l			=> lower-cases one character in a match.
* \L			=> lower-cases ALL remaining characters in a match.
* $$			=> inserts a "$".
* $& and $0	=> inserts the matched substring.
* $n			=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string
* everything else stays untouched
*
* Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter
*/
function parseReplaceString(replaceString) {
	if (!replaceString || replaceString.length === 0) return new ReplacePattern(null);
	const caseOps = [];
	const result = new ReplacePieceBuilder(replaceString);
	for (let i = 0, len = replaceString.length; i < len; i++) {
		const chCode = replaceString.charCodeAt(i);
		if (chCode === 92) {
			i++;
			if (i >= len) break;
			const nextChCode = replaceString.charCodeAt(i);
			switch (nextChCode) {
				case 92:
					result.emitUnchanged(i - 1);
					result.emitStatic("\\", i + 1);
					break;
				case 110:
					result.emitUnchanged(i - 1);
					result.emitStatic("\n", i + 1);
					break;
				case 116:
					result.emitUnchanged(i - 1);
					result.emitStatic("	", i + 1);
					break;
				case 117:
				case 85:
				case 108:
				case 76:
					result.emitUnchanged(i - 1);
					result.emitStatic("", i + 1);
					caseOps.push(String.fromCharCode(nextChCode));
					break;
			}
			continue;
		}
		if (chCode === 36) {
			i++;
			if (i >= len) break;
			const nextChCode = replaceString.charCodeAt(i);
			if (nextChCode === 36) {
				result.emitUnchanged(i - 1);
				result.emitStatic("$", i + 1);
				continue;
			}
			if (nextChCode === 48 || nextChCode === 38) {
				result.emitUnchanged(i - 1);
				result.emitMatchIndex(0, i + 1, caseOps);
				caseOps.length = 0;
				continue;
			}
			if (49 <= nextChCode && nextChCode <= 57) {
				let matchIndex = nextChCode - 48;
				if (i + 1 < len) {
					const nextNextChCode = replaceString.charCodeAt(i + 1);
					if (48 <= nextNextChCode && nextNextChCode <= 57) {
						i++;
						matchIndex = matchIndex * 10 + (nextNextChCode - 48);
						result.emitUnchanged(i - 2);
						result.emitMatchIndex(matchIndex, i + 1, caseOps);
						caseOps.length = 0;
						continue;
					}
				}
				result.emitUnchanged(i - 1);
				result.emitMatchIndex(matchIndex, i + 1, caseOps);
				caseOps.length = 0;
				continue;
			}
		}
	}
	return result.finalize();
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
const ToggleCaseSensitiveKeybinding = {
	primary: 545,
	mac: { primary: 2593 }
};
const ToggleWholeWordKeybinding = {
	primary: 565,
	mac: { primary: 2613 }
};
const ToggleRegexKeybinding = {
	primary: 560,
	mac: { primary: 2608 }
};
const ToggleSearchScopeKeybinding = {
	primary: 554,
	mac: { primary: 2602 }
};
const TogglePreserveCaseKeybinding = {
	primary: 558,
	mac: { primary: 2606 }
};
const FIND_IDS = {
	StartFindAction: "actions.find",
	StartFindWithSelection: "actions.findWithSelection",
	StartFindWithArgs: "editor.actions.findWithArgs",
	NextMatchFindAction: "editor.action.nextMatchFindAction",
	PreviousMatchFindAction: "editor.action.previousMatchFindAction",
	NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
	PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
	StartFindReplaceAction: "editor.action.startFindReplaceAction",
	CloseFindWidgetCommand: "closeFindWidget",
	ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
	ToggleWholeWordCommand: "toggleFindWholeWord",
	ToggleRegexCommand: "toggleFindRegex",
	ToggleSearchScopeCommand: "toggleFindInSelection",
	TogglePreserveCaseCommand: "togglePreserveCase",
	ReplaceOneAction: "editor.action.replaceOne",
	ReplaceAllAction: "editor.action.replaceAll",
	SelectAllMatchesAction: "editor.action.selectAllMatches"
};
const MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = class FindModelBoundToEditorModel {
	constructor(editor$1, state) {
		this._toDispose = new DisposableStore();
		this._editor = editor$1;
		this._state = state;
		this._isDisposed = false;
		this._startSearchingTimer = new TimeoutTimer();
		this._decorations = new FindDecorations(editor$1);
		this._toDispose.add(this._decorations);
		this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
		this._toDispose.add(this._updateDecorationsScheduler);
		this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
			if (e.reason === 3 || e.reason === 5 || e.reason === 6) this._decorations.setStartPosition(this._editor.getPosition());
		}));
		this._ignoreModelContentChanged = false;
		this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
			if (this._ignoreModelContentChanged) return;
			if (e.isFlush) this._decorations.reset();
			this._decorations.setStartPosition(this._editor.getPosition());
			this._updateDecorationsScheduler.schedule();
		}));
		this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
		this.research(false, this._state.searchScope);
	}
	dispose() {
		this._isDisposed = true;
		dispose(this._startSearchingTimer);
		this._toDispose.dispose();
	}
	_onStateChanged(e) {
		if (this._isDisposed) return;
		if (!this._editor.hasModel()) return;
		if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) if (this._editor.getModel().isTooLargeForSyncing()) {
			this._startSearchingTimer.cancel();
			this._startSearchingTimer.setIfNotSet(() => {
				if (e.searchScope) this.research(e.moveCursor, this._state.searchScope);
				else this.research(e.moveCursor);
			}, RESEARCH_DELAY);
		} else if (e.searchScope) this.research(e.moveCursor, this._state.searchScope);
		else this.research(e.moveCursor);
	}
	static _getSearchRange(model, findScope) {
		if (findScope) return findScope;
		return model.getFullModelRange();
	}
	research(moveCursor, newFindScope) {
		let findScopes = null;
		if (typeof newFindScope !== "undefined") {
			if (newFindScope !== null) if (!Array.isArray(newFindScope)) findScopes = [newFindScope];
			else findScopes = newFindScope;
		} else findScopes = this._decorations.getFindScopes();
		if (findScopes !== null) findScopes = findScopes.map((findScope) => {
			if (findScope.startLineNumber !== findScope.endLineNumber) {
				let endLineNumber = findScope.endLineNumber;
				if (findScope.endColumn === 1) endLineNumber = endLineNumber - 1;
				return new Range$1(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
			}
			return findScope;
		});
		const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
		this._decorations.set(findMatches, findScopes);
		const editorSelection = this._editor.getSelection();
		let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
		if (currentMatchesPosition === 0 && findMatches.length > 0) {
			const matchAfterSelection = findFirstInSorted(findMatches.map((match) => match.range), (range) => Range$1.compareRangesUsingStarts(range, editorSelection) >= 0);
			currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
		}
		this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
		if (moveCursor && this._editor.getOption(37).cursorMoveOnType) this._moveToNextMatch(this._decorations.getStartPosition());
	}
	_hasMatches() {
		return this._state.matchesCount > 0;
	}
	_cannotFind() {
		if (!this._hasMatches()) {
			const findScope = this._decorations.getFindScope();
			if (findScope) this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0);
			return true;
		}
		return false;
	}
	_setCurrentFindMatch(match) {
		const matchesPosition = this._decorations.setCurrentFindMatch(match);
		this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
		this._editor.setSelection(match);
		this._editor.revealRangeInCenterIfOutsideViewport(match, 0);
	}
	_prevSearchPosition(before) {
		const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
		let { lineNumber, column } = before;
		const model = this._editor.getModel();
		if (isUsingLineStops || column === 1) {
			if (lineNumber === 1) lineNumber = model.getLineCount();
			else lineNumber--;
			column = model.getLineMaxColumn(lineNumber);
		} else column--;
		return new Position$1(lineNumber, column);
	}
	_moveToPrevMatch(before, isRecursed = false) {
		if (!this._state.canNavigateBack()) {
			const nextMatchRange = this._decorations.matchAfterPosition(before);
			if (nextMatchRange) this._setCurrentFindMatch(nextMatchRange);
			return;
		}
		if (this._decorations.getCount() < MATCHES_LIMIT) {
			let prevMatchRange = this._decorations.matchBeforePosition(before);
			if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
				before = this._prevSearchPosition(before);
				prevMatchRange = this._decorations.matchBeforePosition(before);
			}
			if (prevMatchRange) this._setCurrentFindMatch(prevMatchRange);
			return;
		}
		if (this._cannotFind()) return;
		const findScope = this._decorations.getFindScope();
		const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
		if (searchRange.getEndPosition().isBefore(before)) before = searchRange.getEndPosition();
		if (before.isBefore(searchRange.getStartPosition())) before = searchRange.getEndPosition();
		const { lineNumber, column } = before;
		const model = this._editor.getModel();
		let position = new Position$1(lineNumber, column);
		let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119) : null, false);
		if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
			position = this._prevSearchPosition(position);
			prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119) : null, false);
		}
		if (!prevMatch) return;
		if (!isRecursed && !searchRange.containsRange(prevMatch.range)) return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
		this._setCurrentFindMatch(prevMatch.range);
	}
	moveToPrevMatch() {
		this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
	}
	_nextSearchPosition(after) {
		const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
		let { lineNumber, column } = after;
		const model = this._editor.getModel();
		if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
			if (lineNumber === model.getLineCount()) lineNumber = 1;
			else lineNumber++;
			column = 1;
		} else column++;
		return new Position$1(lineNumber, column);
	}
	_moveToNextMatch(after) {
		if (!this._state.canNavigateForward()) {
			const prevMatchRange = this._decorations.matchBeforePosition(after);
			if (prevMatchRange) this._setCurrentFindMatch(prevMatchRange);
			return;
		}
		if (this._decorations.getCount() < MATCHES_LIMIT) {
			let nextMatchRange = this._decorations.matchAfterPosition(after);
			if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
				after = this._nextSearchPosition(after);
				nextMatchRange = this._decorations.matchAfterPosition(after);
			}
			if (nextMatchRange) this._setCurrentFindMatch(nextMatchRange);
			return;
		}
		const nextMatch = this._getNextMatch(after, false, true);
		if (nextMatch) this._setCurrentFindMatch(nextMatch.range);
	}
	_getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
		if (this._cannotFind()) return null;
		const findScope = this._decorations.getFindScope();
		const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
		if (searchRange.getEndPosition().isBefore(after)) after = searchRange.getStartPosition();
		if (after.isBefore(searchRange.getStartPosition())) after = searchRange.getStartPosition();
		const { lineNumber, column } = after;
		const model = this._editor.getModel();
		let position = new Position$1(lineNumber, column);
		let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119) : null, captureMatches);
		if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
			position = this._nextSearchPosition(position);
			nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119) : null, captureMatches);
		}
		if (!nextMatch) return null;
		if (!isRecursed && !searchRange.containsRange(nextMatch.range)) return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
		return nextMatch;
	}
	moveToNextMatch() {
		this._moveToNextMatch(this._editor.getSelection().getEndPosition());
	}
	_getReplacePattern() {
		if (this._state.isRegex) return parseReplaceString(this._state.replaceString);
		return ReplacePattern.fromStaticValue(this._state.replaceString);
	}
	replace() {
		if (!this._hasMatches()) return;
		const replacePattern = this._getReplacePattern();
		const selection = this._editor.getSelection();
		const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
		if (nextMatch) if (selection.equalsRange(nextMatch.range)) {
			const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
			const command = new ReplaceCommand(selection, replaceString);
			this._executeEditorCommand("replace", command);
			this._decorations.setStartPosition(new Position$1(selection.startLineNumber, selection.startColumn + replaceString.length));
			this.research(true);
		} else {
			this._decorations.setStartPosition(this._editor.getPosition());
			this._setCurrentFindMatch(nextMatch.range);
		}
	}
	_findMatches(findScopes, captureMatches, limitResultCount) {
		const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
		return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119) : null, captureMatches, limitResultCount);
	}
	replaceAll() {
		if (!this._hasMatches()) return;
		const findScopes = this._decorations.getFindScopes();
		if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) this._largeReplaceAll();
		else this._regularReplaceAll(findScopes);
		this.research(false);
	}
	_largeReplaceAll() {
		const searchData = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(119) : null).parseSearchRequest();
		if (!searchData) return;
		let searchRegex = searchData.regex;
		if (!searchRegex.multiline) {
			let mod = "mu";
			if (searchRegex.ignoreCase) mod += "i";
			if (searchRegex.global) mod += "g";
			searchRegex = new RegExp(searchRegex.source, mod);
		}
		const model = this._editor.getModel();
		const modelText = model.getValue(1);
		const fullModelRange = model.getFullModelRange();
		const replacePattern = this._getReplacePattern();
		let resultText;
		const preserveCase = this._state.preserveCase;
		if (replacePattern.hasReplacementPatterns || preserveCase) resultText = modelText.replace(searchRegex, function() {
			return replacePattern.buildReplaceString(arguments, preserveCase);
		});
		else resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
		const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
		this._executeEditorCommand("replaceAll", command);
	}
	_regularReplaceAll(findScopes) {
		const replacePattern = this._getReplacePattern();
		const matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824);
		const replaceStrings = [];
		for (let i = 0, len = matches.length; i < len; i++) replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
		const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
		this._executeEditorCommand("replaceAll", command);
	}
	selectAllMatches() {
		if (!this._hasMatches()) return;
		const findScopes = this._decorations.getFindScopes();
		let selections = this._findMatches(findScopes, false, 1073741824).map((m) => new Selection$1(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
		const editorSelection = this._editor.getSelection();
		for (let i = 0, len = selections.length; i < len; i++) if (selections[i].equalsRange(editorSelection)) {
			selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
			break;
		}
		this._editor.setSelections(selections);
	}
	_executeEditorCommand(source, command) {
		try {
			this._ignoreModelContentChanged = true;
			this._editor.pushUndoStop();
			this._editor.executeCommand(source, command);
			this._editor.pushUndoStop();
		} finally {
			this._ignoreModelContentChanged = false;
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.js
var FindOptionsWidget = class FindOptionsWidget extends Widget {
	constructor(editor$1, state, keybindingService, themeService) {
		super();
		this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
		this._isVisible = false;
		this._editor = editor$1;
		this._state = state;
		this._keybindingService = keybindingService;
		this._domNode = document.createElement("div");
		this._domNode.className = "findOptionsWidget";
		this._domNode.style.display = "none";
		this._domNode.style.top = "10px";
		this._domNode.setAttribute("role", "presentation");
		this._domNode.setAttribute("aria-hidden", "true");
		const inputActiveOptionBorderColor = themeService.getColorTheme().getColor(inputActiveOptionBorder);
		const inputActiveOptionForegroundColor = themeService.getColorTheme().getColor(inputActiveOptionForeground);
		const inputActiveOptionBackgroundColor = themeService.getColorTheme().getColor(inputActiveOptionBackground);
		this.caseSensitive = this._register(new CaseSensitiveToggle({
			appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
			isChecked: this._state.matchCase,
			inputActiveOptionBorder: inputActiveOptionBorderColor,
			inputActiveOptionForeground: inputActiveOptionForegroundColor,
			inputActiveOptionBackground: inputActiveOptionBackgroundColor
		}));
		this._domNode.appendChild(this.caseSensitive.domNode);
		this._register(this.caseSensitive.onChange(() => {
			this._state.change({ matchCase: this.caseSensitive.checked }, false);
		}));
		this.wholeWords = this._register(new WholeWordsToggle({
			appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
			isChecked: this._state.wholeWord,
			inputActiveOptionBorder: inputActiveOptionBorderColor,
			inputActiveOptionForeground: inputActiveOptionForegroundColor,
			inputActiveOptionBackground: inputActiveOptionBackgroundColor
		}));
		this._domNode.appendChild(this.wholeWords.domNode);
		this._register(this.wholeWords.onChange(() => {
			this._state.change({ wholeWord: this.wholeWords.checked }, false);
		}));
		this.regex = this._register(new RegexToggle({
			appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
			isChecked: this._state.isRegex,
			inputActiveOptionBorder: inputActiveOptionBorderColor,
			inputActiveOptionForeground: inputActiveOptionForegroundColor,
			inputActiveOptionBackground: inputActiveOptionBackgroundColor
		}));
		this._domNode.appendChild(this.regex.domNode);
		this._register(this.regex.onChange(() => {
			this._state.change({ isRegex: this.regex.checked }, false);
		}));
		this._editor.addOverlayWidget(this);
		this._register(this._state.onFindReplaceStateChange((e) => {
			let somethingChanged = false;
			if (e.isRegex) {
				this.regex.checked = this._state.isRegex;
				somethingChanged = true;
			}
			if (e.wholeWord) {
				this.wholeWords.checked = this._state.wholeWord;
				somethingChanged = true;
			}
			if (e.matchCase) {
				this.caseSensitive.checked = this._state.matchCase;
				somethingChanged = true;
			}
			if (!this._state.isRevealed && somethingChanged) this._revealTemporarily();
		}));
		this._register(addDisposableListener(this._domNode, EventType$1.MOUSE_LEAVE, (e) => this._onMouseLeave()));
		this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
		this._applyTheme(themeService.getColorTheme());
		this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
	}
	_keybindingLabelFor(actionId) {
		const kb = this._keybindingService.lookupKeybinding(actionId);
		if (!kb) return "";
		return ` (${kb.getLabel()})`;
	}
	dispose() {
		this._editor.removeOverlayWidget(this);
		super.dispose();
	}
	getId() {
		return FindOptionsWidget.ID;
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		return { preference: 0 };
	}
	highlightFindOptions() {
		this._revealTemporarily();
	}
	_revealTemporarily() {
		this._show();
		this._hideSoon.schedule();
	}
	_onMouseLeave() {
		this._hideSoon.schedule();
	}
	_onMouseOver() {
		this._hideSoon.cancel();
	}
	_show() {
		if (this._isVisible) return;
		this._isVisible = true;
		this._domNode.style.display = "block";
	}
	_hide() {
		if (!this._isVisible) return;
		this._isVisible = false;
		this._domNode.style.display = "none";
	}
	_applyTheme(theme) {
		const inputStyles = {
			inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
			inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),
			inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground)
		};
		this.caseSensitive.style(inputStyles);
		this.wholeWords.style(inputStyles);
		this.regex.style(inputStyles);
	}
};
FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";
registerThemingParticipant((theme, collector) => {
	const widgetBackground = theme.getColor(editorWidgetBackground);
	if (widgetBackground) collector.addRule(`.monaco-editor .findOptionsWidget { background-color: ${widgetBackground}; }`);
	const widgetForeground = theme.getColor(editorWidgetForeground);
	if (widgetForeground) collector.addRule(`.monaco-editor .findOptionsWidget { color: ${widgetForeground}; }`);
	const widgetShadowColor = theme.getColor(widgetShadow);
	if (widgetShadowColor) collector.addRule(`.monaco-editor .findOptionsWidget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
	const hcBorder = theme.getColor(contrastBorder);
	if (hcBorder) collector.addRule(`.monaco-editor .findOptionsWidget { border: 2px solid ${hcBorder}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findState.js
function effectiveOptionValue(override, value) {
	if (override === 1) return true;
	if (override === 2) return false;
	return value;
}
var FindReplaceState = class extends Disposable {
	constructor() {
		super();
		this._onFindReplaceStateChange = this._register(new Emitter$1());
		this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
		this._searchString = "";
		this._replaceString = "";
		this._isRevealed = false;
		this._isReplaceRevealed = false;
		this._isRegex = false;
		this._isRegexOverride = 0;
		this._wholeWord = false;
		this._wholeWordOverride = 0;
		this._matchCase = false;
		this._matchCaseOverride = 0;
		this._preserveCase = false;
		this._preserveCaseOverride = 0;
		this._searchScope = null;
		this._matchesPosition = 0;
		this._matchesCount = 0;
		this._currentMatch = null;
		this._loop = true;
		this._isSearching = false;
		this._filters = null;
	}
	get searchString() {
		return this._searchString;
	}
	get replaceString() {
		return this._replaceString;
	}
	get isRevealed() {
		return this._isRevealed;
	}
	get isReplaceRevealed() {
		return this._isReplaceRevealed;
	}
	get isRegex() {
		return effectiveOptionValue(this._isRegexOverride, this._isRegex);
	}
	get wholeWord() {
		return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
	}
	get matchCase() {
		return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
	}
	get preserveCase() {
		return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
	}
	get actualIsRegex() {
		return this._isRegex;
	}
	get actualWholeWord() {
		return this._wholeWord;
	}
	get actualMatchCase() {
		return this._matchCase;
	}
	get actualPreserveCase() {
		return this._preserveCase;
	}
	get searchScope() {
		return this._searchScope;
	}
	get matchesPosition() {
		return this._matchesPosition;
	}
	get matchesCount() {
		return this._matchesCount;
	}
	get currentMatch() {
		return this._currentMatch;
	}
	changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
		const changeEvent = {
			moveCursor: false,
			updateHistory: false,
			searchString: false,
			replaceString: false,
			isRevealed: false,
			isReplaceRevealed: false,
			isRegex: false,
			wholeWord: false,
			matchCase: false,
			preserveCase: false,
			searchScope: false,
			matchesPosition: false,
			matchesCount: false,
			currentMatch: false,
			loop: false,
			isSearching: false,
			filters: false
		};
		let somethingChanged = false;
		if (matchesCount === 0) matchesPosition = 0;
		if (matchesPosition > matchesCount) matchesPosition = matchesCount;
		if (this._matchesPosition !== matchesPosition) {
			this._matchesPosition = matchesPosition;
			changeEvent.matchesPosition = true;
			somethingChanged = true;
		}
		if (this._matchesCount !== matchesCount) {
			this._matchesCount = matchesCount;
			changeEvent.matchesCount = true;
			somethingChanged = true;
		}
		if (typeof currentMatch !== "undefined") {
			if (!Range$1.equalsRange(this._currentMatch, currentMatch)) {
				this._currentMatch = currentMatch;
				changeEvent.currentMatch = true;
				somethingChanged = true;
			}
		}
		if (somethingChanged) this._onFindReplaceStateChange.fire(changeEvent);
	}
	change(newState, moveCursor, updateHistory = true) {
		var _a$5;
		const changeEvent = {
			moveCursor,
			updateHistory,
			searchString: false,
			replaceString: false,
			isRevealed: false,
			isReplaceRevealed: false,
			isRegex: false,
			wholeWord: false,
			matchCase: false,
			preserveCase: false,
			searchScope: false,
			matchesPosition: false,
			matchesCount: false,
			currentMatch: false,
			loop: false,
			isSearching: false,
			filters: false
		};
		let somethingChanged = false;
		const oldEffectiveIsRegex = this.isRegex;
		const oldEffectiveWholeWords = this.wholeWord;
		const oldEffectiveMatchCase = this.matchCase;
		const oldEffectivePreserveCase = this.preserveCase;
		if (typeof newState.searchString !== "undefined") {
			if (this._searchString !== newState.searchString) {
				this._searchString = newState.searchString;
				changeEvent.searchString = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.replaceString !== "undefined") {
			if (this._replaceString !== newState.replaceString) {
				this._replaceString = newState.replaceString;
				changeEvent.replaceString = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.isRevealed !== "undefined") {
			if (this._isRevealed !== newState.isRevealed) {
				this._isRevealed = newState.isRevealed;
				changeEvent.isRevealed = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.isReplaceRevealed !== "undefined") {
			if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
				this._isReplaceRevealed = newState.isReplaceRevealed;
				changeEvent.isReplaceRevealed = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.isRegex !== "undefined") this._isRegex = newState.isRegex;
		if (typeof newState.wholeWord !== "undefined") this._wholeWord = newState.wholeWord;
		if (typeof newState.matchCase !== "undefined") this._matchCase = newState.matchCase;
		if (typeof newState.preserveCase !== "undefined") this._preserveCase = newState.preserveCase;
		if (typeof newState.searchScope !== "undefined") {
			if (!((_a$5 = newState.searchScope) === null || _a$5 === void 0 ? void 0 : _a$5.every((newSearchScope) => {
				var _a$6;
				return (_a$6 = this._searchScope) === null || _a$6 === void 0 ? void 0 : _a$6.some((existingSearchScope) => {
					return !Range$1.equalsRange(existingSearchScope, newSearchScope);
				});
			}))) {
				this._searchScope = newState.searchScope;
				changeEvent.searchScope = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.loop !== "undefined") {
			if (this._loop !== newState.loop) {
				this._loop = newState.loop;
				changeEvent.loop = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.isSearching !== "undefined") {
			if (this._isSearching !== newState.isSearching) {
				this._isSearching = newState.isSearching;
				changeEvent.isSearching = true;
				somethingChanged = true;
			}
		}
		if (typeof newState.filters !== "undefined") {
			if (this._filters) this._filters.update(newState.filters);
			else this._filters = newState.filters;
			changeEvent.filters = true;
			somethingChanged = true;
		}
		this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
		this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
		this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
		this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
		if (oldEffectiveIsRegex !== this.isRegex) {
			somethingChanged = true;
			changeEvent.isRegex = true;
		}
		if (oldEffectiveWholeWords !== this.wholeWord) {
			somethingChanged = true;
			changeEvent.wholeWord = true;
		}
		if (oldEffectiveMatchCase !== this.matchCase) {
			somethingChanged = true;
			changeEvent.matchCase = true;
		}
		if (oldEffectivePreserveCase !== this.preserveCase) {
			somethingChanged = true;
			changeEvent.preserveCase = true;
		}
		if (somethingChanged) this._onFindReplaceStateChange.fire(changeEvent);
	}
	canNavigateBack() {
		return this.canNavigateInLoop() || this.matchesPosition !== 1;
	}
	canNavigateForward() {
		return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
	}
	canNavigateInLoop() {
		return this._loop || this.matchesCount >= MATCHES_LIMIT;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/history/browser/historyWidgetKeybindingHint.js
function showHistoryKeybindingHint(keybindingService) {
	var _a$5, _b$1;
	return ((_a$5 = keybindingService.lookupKeybinding("history.showPrevious")) === null || _a$5 === void 0 ? void 0 : _a$5.getElectronAccelerator()) === "Up" && ((_b$1 = keybindingService.lookupKeybinding("history.showNext")) === null || _b$1 === void 0 ? void 0 : _b$1.getElectronAccelerator()) === "Down";
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js
var __awaiter$31 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget."));
var findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed."));
var findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize("findExpandedIcon", "Icon to indicate that the editor find widget is expanded."));
const findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize("findReplaceIcon", "Icon for 'Replace' in the editor find widget."));
const findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget."));
const findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget."));
const findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget."));
var NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
var NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in Selection");
var NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
var NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
var NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
const NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
const NLS_NO_RESULTS = localize("label.noResults", "No results");
var FIND_WIDGET_INITIAL_WIDTH = 419;
var FIND_INPUT_AREA_WIDTH = 221;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_INPUT_AREA_HEIGHT = 33;
var ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var FindWidgetViewZone = class {
	constructor(afterLineNumber) {
		this.afterLineNumber = afterLineNumber;
		this.heightInPx = FIND_INPUT_AREA_HEIGHT;
		this.suppressMouseDown = false;
		this.domNode = document.createElement("div");
		this.domNode.className = "dock-find-viewzone";
	}
};
function stopPropagationForMultiLineUpwards(event, value, textarea) {
	const isMultiline = !!value.match(/\n/);
	if (textarea && isMultiline && textarea.selectionStart > 0) {
		event.stopPropagation();
		return;
	}
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
	const isMultiline = !!value.match(/\n/);
	if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
		event.stopPropagation();
		return;
	}
}
var FindWidget = class FindWidget extends Widget {
	constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {
		super();
		this._cachedHeight = null;
		this._revealTimeouts = [];
		this._codeEditor = codeEditor;
		this._controller = controller;
		this._state = state;
		this._contextViewProvider = contextViewProvider;
		this._keybindingService = keybindingService;
		this._contextKeyService = contextKeyService;
		this._storageService = storageService;
		this._notificationService = notificationService;
		this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(ctrlEnterReplaceAllWarningPromptedKey, 0);
		this._isVisible = false;
		this._isReplaceVisible = false;
		this._ignoreChangeEvent = false;
		this._updateHistoryDelayer = new Delayer(500);
		this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
		this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
		this._buildDomNode();
		this._updateButtons();
		this._tryUpdateWidgetWidth();
		this._findInput.inputBox.layout();
		this._register(this._codeEditor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(83)) {
				if (this._codeEditor.getOption(83)) this._state.change({ isReplaceRevealed: false }, false);
				this._updateButtons();
			}
			if (e.hasChanged(133)) this._tryUpdateWidgetWidth();
			if (e.hasChanged(2)) this.updateAccessibilitySupport();
			if (e.hasChanged(37)) {
				const addExtraSpaceOnTop = this._codeEditor.getOption(37).addExtraSpaceOnTop;
				if (addExtraSpaceOnTop && !this._viewZone) {
					this._viewZone = new FindWidgetViewZone(0);
					this._showViewZone();
				}
				if (!addExtraSpaceOnTop && this._viewZone) this._removeViewZone();
			}
		}));
		this.updateAccessibilitySupport();
		this._register(this._codeEditor.onDidChangeCursorSelection(() => {
			if (this._isVisible) this._updateToggleSelectionFindButton();
		}));
		this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter$31(this, void 0, void 0, function* () {
			if (this._isVisible) {
				const globalBufferTerm = yield this._controller.getGlobalBufferTerm();
				if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
					this._state.change({ searchString: globalBufferTerm }, false);
					this._findInput.select();
				}
			}
		})));
		this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
		this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
		this._register(this._findFocusTracker.onDidFocus(() => {
			this._findInputFocused.set(true);
			this._updateSearchScope();
		}));
		this._register(this._findFocusTracker.onDidBlur(() => {
			this._findInputFocused.set(false);
		}));
		this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
		this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
		this._register(this._replaceFocusTracker.onDidFocus(() => {
			this._replaceInputFocused.set(true);
			this._updateSearchScope();
		}));
		this._register(this._replaceFocusTracker.onDidBlur(() => {
			this._replaceInputFocused.set(false);
		}));
		this._codeEditor.addOverlayWidget(this);
		if (this._codeEditor.getOption(37).addExtraSpaceOnTop) this._viewZone = new FindWidgetViewZone(0);
		this._applyTheme(themeService.getColorTheme());
		this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
		this._register(this._codeEditor.onDidChangeModel(() => {
			if (!this._isVisible) return;
			this._viewZoneId = void 0;
		}));
		this._register(this._codeEditor.onDidScrollChange((e) => {
			if (e.scrollTopChanged) {
				this._layoutViewZone();
				return;
			}
			setTimeout(() => {
				this._layoutViewZone();
			}, 0);
		}));
	}
	getId() {
		return FindWidget.ID;
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		if (this._isVisible) return { preference: 0 };
		return null;
	}
	_onStateChanged(e) {
		if (e.searchString) {
			try {
				this._ignoreChangeEvent = true;
				this._findInput.setValue(this._state.searchString);
			} finally {
				this._ignoreChangeEvent = false;
			}
			this._updateButtons();
		}
		if (e.replaceString) this._replaceInput.inputBox.value = this._state.replaceString;
		if (e.isRevealed) if (this._state.isRevealed) this._reveal();
		else this._hide(true);
		if (e.isReplaceRevealed) {
			if (this._state.isReplaceRevealed) {
				if (!this._codeEditor.getOption(83) && !this._isReplaceVisible) {
					this._isReplaceVisible = true;
					this._replaceInput.width = getTotalWidth(this._findInput.domNode);
					this._updateButtons();
					this._replaceInput.inputBox.layout();
				}
			} else if (this._isReplaceVisible) {
				this._isReplaceVisible = false;
				this._updateButtons();
			}
		}
		if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
			if (this._tryUpdateHeight()) this._showViewZone();
		}
		if (e.isRegex) this._findInput.setRegex(this._state.isRegex);
		if (e.wholeWord) this._findInput.setWholeWords(this._state.wholeWord);
		if (e.matchCase) this._findInput.setCaseSensitive(this._state.matchCase);
		if (e.preserveCase) this._replaceInput.setPreserveCase(this._state.preserveCase);
		if (e.searchScope) {
			if (this._state.searchScope) this._toggleSelectionFind.checked = true;
			else this._toggleSelectionFind.checked = false;
			this._updateToggleSelectionFindButton();
		}
		if (e.searchString || e.matchesCount || e.matchesPosition) {
			const showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
			this._domNode.classList.toggle("no-results", showRedOutline);
			this._updateMatchesCount();
			this._updateButtons();
		}
		if (e.searchString || e.currentMatch) this._layoutViewZone();
		if (e.updateHistory) this._delayedUpdateHistory();
		if (e.loop) this._updateButtons();
	}
	_delayedUpdateHistory() {
		this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
	}
	_updateHistory() {
		if (this._state.searchString) this._findInput.inputBox.addToHistory();
		if (this._state.replaceString) this._replaceInput.inputBox.addToHistory();
	}
	_updateMatchesCount() {
		this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
		if (this._state.matchesCount >= MATCHES_LIMIT) this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
		else this._matchesCount.title = "";
		if (this._matchesCount.firstChild) this._matchesCount.removeChild(this._matchesCount.firstChild);
		let label;
		if (this._state.matchesCount > 0) {
			let matchesCount = String(this._state.matchesCount);
			if (this._state.matchesCount >= MATCHES_LIMIT) matchesCount += "+";
			let matchesPosition = String(this._state.matchesPosition);
			if (matchesPosition === "0") matchesPosition = "?";
			label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
		} else label = NLS_NO_RESULTS;
		this._matchesCount.appendChild(document.createTextNode(label));
		alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
		MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
	}
	_getAriaLabel(label, currentMatch, searchString) {
		if (label === NLS_NO_RESULTS) return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
		if (currentMatch) {
			const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
			const model = this._codeEditor.getModel();
			if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) return `${model.getLineContent(currentMatch.startLineNumber)}, ${ariaLabel}`;
			return ariaLabel;
		}
		return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
	}
	/**
	* If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
	* If 'selection find' is OFF we enable the button only if there is a selection.
	*/
	_updateToggleSelectionFindButton() {
		const selection = this._codeEditor.getSelection();
		const isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
		const isChecked = this._toggleSelectionFind.checked;
		if (this._isVisible && (isChecked || isSelection)) this._toggleSelectionFind.enable();
		else this._toggleSelectionFind.disable();
	}
	_updateButtons() {
		this._findInput.setEnabled(this._isVisible);
		this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
		this._updateToggleSelectionFindButton();
		this._closeBtn.setEnabled(this._isVisible);
		const findInputIsNonEmpty = this._state.searchString.length > 0;
		const matchesCount = this._state.matchesCount ? true : false;
		this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
		this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
		this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
		this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
		this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
		this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
		const canReplace = !this._codeEditor.getOption(83);
		this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
	}
	_reveal() {
		this._revealTimeouts.forEach((e) => {
			clearTimeout(e);
		});
		this._revealTimeouts = [];
		if (!this._isVisible) {
			this._isVisible = true;
			const selection = this._codeEditor.getSelection();
			switch (this._codeEditor.getOption(37).autoFindInSelection) {
				case "always":
					this._toggleSelectionFind.checked = true;
					break;
				case "never":
					this._toggleSelectionFind.checked = false;
					break;
				case "multiline": {
					const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
					this._toggleSelectionFind.checked = isSelectionMultipleLine;
					break;
				}
				default: break;
			}
			this._tryUpdateWidgetWidth();
			this._updateButtons();
			this._revealTimeouts.push(setTimeout(() => {
				this._domNode.classList.add("visible");
				this._domNode.setAttribute("aria-hidden", "false");
			}, 0));
			this._revealTimeouts.push(setTimeout(() => {
				this._findInput.validate();
			}, 200));
			this._codeEditor.layoutOverlayWidget(this);
			let adjustEditorScrollTop = true;
			if (this._codeEditor.getOption(37).seedSearchStringFromSelection && selection) {
				const domNode = this._codeEditor.getDomNode();
				if (domNode) {
					const editorCoords = getDomNodePagePosition(domNode);
					const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
					const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
					const startTop = startCoords ? startCoords.top : 0;
					if (this._viewZone && startTop < this._viewZone.heightInPx) {
						if (selection.endLineNumber > selection.startLineNumber) adjustEditorScrollTop = false;
						const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
						if (startLeft > leftOfFindWidget) adjustEditorScrollTop = false;
						const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
						if (editorCoords.left + (endCoords ? endCoords.left : 0) > leftOfFindWidget) adjustEditorScrollTop = false;
					}
				}
			}
			this._showViewZone(adjustEditorScrollTop);
		}
	}
	_hide(focusTheEditor) {
		this._revealTimeouts.forEach((e) => {
			clearTimeout(e);
		});
		this._revealTimeouts = [];
		if (this._isVisible) {
			this._isVisible = false;
			this._updateButtons();
			this._domNode.classList.remove("visible");
			this._domNode.setAttribute("aria-hidden", "true");
			this._findInput.clearMessage();
			if (focusTheEditor) this._codeEditor.focus();
			this._codeEditor.layoutOverlayWidget(this);
			this._removeViewZone();
		}
	}
	_layoutViewZone(targetScrollTop) {
		if (!this._codeEditor.getOption(37).addExtraSpaceOnTop) {
			this._removeViewZone();
			return;
		}
		if (!this._isVisible) return;
		const viewZone = this._viewZone;
		if (this._viewZoneId !== void 0 || !viewZone) return;
		this._codeEditor.changeViewZones((accessor) => {
			viewZone.heightInPx = this._getHeight();
			this._viewZoneId = accessor.addZone(viewZone);
			this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
		});
	}
	_showViewZone(adjustScroll = true) {
		if (!this._isVisible) return;
		if (!this._codeEditor.getOption(37).addExtraSpaceOnTop) return;
		if (this._viewZone === void 0) this._viewZone = new FindWidgetViewZone(0);
		const viewZone = this._viewZone;
		this._codeEditor.changeViewZones((accessor) => {
			if (this._viewZoneId !== void 0) {
				const newHeight = this._getHeight();
				if (newHeight === viewZone.heightInPx) return;
				const scrollAdjustment = newHeight - viewZone.heightInPx;
				viewZone.heightInPx = newHeight;
				accessor.layoutZone(this._viewZoneId);
				if (adjustScroll) this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
				return;
			} else {
				let scrollAdjustment = this._getHeight();
				scrollAdjustment -= this._codeEditor.getOption(77).top;
				if (scrollAdjustment <= 0) return;
				viewZone.heightInPx = scrollAdjustment;
				this._viewZoneId = accessor.addZone(viewZone);
				if (adjustScroll) this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
			}
		});
	}
	_removeViewZone() {
		this._codeEditor.changeViewZones((accessor) => {
			if (this._viewZoneId !== void 0) {
				accessor.removeZone(this._viewZoneId);
				this._viewZoneId = void 0;
				if (this._viewZone) {
					this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
					this._viewZone = void 0;
				}
			}
		});
	}
	_applyTheme(theme) {
		const inputStyles = {
			inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
			inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground),
			inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),
			inputBackground: theme.getColor(inputBackground),
			inputForeground: theme.getColor(inputForeground),
			inputBorder: theme.getColor(inputBorder),
			inputValidationInfoBackground: theme.getColor(inputValidationInfoBackground),
			inputValidationInfoForeground: theme.getColor(inputValidationInfoForeground),
			inputValidationInfoBorder: theme.getColor(inputValidationInfoBorder),
			inputValidationWarningBackground: theme.getColor(inputValidationWarningBackground),
			inputValidationWarningForeground: theme.getColor(inputValidationWarningForeground),
			inputValidationWarningBorder: theme.getColor(inputValidationWarningBorder),
			inputValidationErrorBackground: theme.getColor(inputValidationErrorBackground),
			inputValidationErrorForeground: theme.getColor(inputValidationErrorForeground),
			inputValidationErrorBorder: theme.getColor(inputValidationErrorBorder)
		};
		this._findInput.style(inputStyles);
		this._replaceInput.style(inputStyles);
		this._toggleSelectionFind.style(inputStyles);
	}
	_tryUpdateWidgetWidth() {
		if (!this._isVisible) return;
		if (!isInDOM(this._domNode)) return;
		const layoutInfo = this._codeEditor.getLayoutInfo();
		if (layoutInfo.contentWidth <= 0) {
			this._domNode.classList.add("hiddenEditor");
			return;
		} else if (this._domNode.classList.contains("hiddenEditor")) this._domNode.classList.remove("hiddenEditor");
		const editorWidth = layoutInfo.width;
		const minimapWidth = layoutInfo.minimap.minimapWidth;
		let collapsedFindWidget = false;
		let reducedFindWidget = false;
		let narrowFindWidget = false;
		if (this._resized) {
			if (getTotalWidth(this._domNode) > FIND_WIDGET_INITIAL_WIDTH) {
				this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
				this._replaceInput.width = getTotalWidth(this._findInput.domNode);
				return;
			}
		}
		if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) reducedFindWidget = true;
		if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) narrowFindWidget = true;
		if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) collapsedFindWidget = true;
		this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
		this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
		this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
		if (!narrowFindWidget && !collapsedFindWidget) this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
		if (this._resized) {
			this._findInput.inputBox.layout();
			const findInputWidth = this._findInput.inputBox.element.clientWidth;
			if (findInputWidth > 0) this._replaceInput.width = findInputWidth;
		} else if (this._isReplaceVisible) this._replaceInput.width = getTotalWidth(this._findInput.domNode);
	}
	_getHeight() {
		let totalheight = 0;
		totalheight += 4;
		totalheight += this._findInput.inputBox.height + 2;
		if (this._isReplaceVisible) {
			totalheight += 4;
			totalheight += this._replaceInput.inputBox.height + 2;
		}
		totalheight += 4;
		return totalheight;
	}
	_tryUpdateHeight() {
		const totalHeight = this._getHeight();
		if (this._cachedHeight !== null && this._cachedHeight === totalHeight) return false;
		this._cachedHeight = totalHeight;
		this._domNode.style.height = `${totalHeight}px`;
		return true;
	}
	focusFindInput() {
		this._findInput.select();
		this._findInput.focus();
	}
	focusReplaceInput() {
		this._replaceInput.select();
		this._replaceInput.focus();
	}
	highlightFindOptions() {
		this._findInput.highlightFindOptions();
	}
	_updateSearchScope() {
		if (!this._codeEditor.hasModel()) return;
		if (this._toggleSelectionFind.checked) {
			const selections = this._codeEditor.getSelections();
			selections.map((selection) => {
				if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
				const currentMatch = this._state.currentMatch;
				if (selection.startLineNumber !== selection.endLineNumber) {
					if (!Range$1.equalsRange(selection, currentMatch)) return selection;
				}
				return null;
			}).filter((element) => !!element);
			if (selections.length) this._state.change({ searchScope: selections }, true);
		}
	}
	_onFindInputMouseDown(e) {
		if (e.middleButton) e.stopPropagation();
	}
	_onFindInputKeyDown(e) {
		if (e.equals(ctrlKeyMod | 3)) if (this._keybindingService.dispatchEvent(e, e.target)) {
			e.preventDefault();
			return;
		} else {
			this._findInput.inputBox.insertAtCursor("\n");
			e.preventDefault();
			return;
		}
		if (e.equals(2)) {
			if (this._isReplaceVisible) this._replaceInput.focus();
			else this._findInput.focusOnCaseSensitive();
			e.preventDefault();
			return;
		}
		if (e.equals(2066)) {
			this._codeEditor.focus();
			e.preventDefault();
			return;
		}
		if (e.equals(16)) return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
		if (e.equals(18)) return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
	}
	_onReplaceInputKeyDown(e) {
		if (e.equals(ctrlKeyMod | 3)) if (this._keybindingService.dispatchEvent(e, e.target)) {
			e.preventDefault();
			return;
		} else {
			if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
				this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
				this._ctrlEnterReplaceAllWarningPrompted = true;
				this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0, 0);
			}
			this._replaceInput.inputBox.insertAtCursor("\n");
			e.preventDefault();
			return;
		}
		if (e.equals(2)) {
			this._findInput.focusOnCaseSensitive();
			e.preventDefault();
			return;
		}
		if (e.equals(1026)) {
			this._findInput.focus();
			e.preventDefault();
			return;
		}
		if (e.equals(2066)) {
			this._codeEditor.focus();
			e.preventDefault();
			return;
		}
		if (e.equals(16)) return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
		if (e.equals(18)) return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
	}
	getVerticalSashLeft(_sash) {
		return 0;
	}
	_keybindingLabelFor(actionId) {
		const kb = this._keybindingService.lookupKeybinding(actionId);
		if (!kb) return "";
		return ` (${kb.getLabel()})`;
	}
	_buildDomNode() {
		const flexibleHeight = true;
		const flexibleWidth = true;
		this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
			width: FIND_INPUT_AREA_WIDTH,
			label: NLS_FIND_INPUT_LABEL,
			placeholder: NLS_FIND_INPUT_PLACEHOLDER,
			appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
			appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
			appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
			validation: (value) => {
				if (value.length === 0 || !this._findInput.getRegex()) return null;
				try {
					new RegExp(value, "gu");
					return null;
				} catch (e) {
					return { content: e.message };
				}
			},
			flexibleHeight,
			flexibleWidth,
			flexibleMaxHeight: 118,
			showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)
		}, this._contextKeyService, true));
		this._findInput.setRegex(!!this._state.isRegex);
		this._findInput.setCaseSensitive(!!this._state.matchCase);
		this._findInput.setWholeWords(!!this._state.wholeWord);
		this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
		this._register(this._findInput.inputBox.onDidChange(() => {
			if (this._ignoreChangeEvent) return;
			this._state.change({ searchString: this._findInput.getValue() }, true);
		}));
		this._register(this._findInput.onDidOptionChange(() => {
			this._state.change({
				isRegex: this._findInput.getRegex(),
				wholeWord: this._findInput.getWholeWords(),
				matchCase: this._findInput.getCaseSensitive()
			}, true);
		}));
		this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
			if (e.equals(1026)) {
				if (this._isReplaceVisible) {
					this._replaceInput.focus();
					e.preventDefault();
				}
			}
		}));
		this._register(this._findInput.onRegexKeyDown((e) => {
			if (e.equals(2)) {
				if (this._isReplaceVisible) {
					this._replaceInput.focusOnPreserve();
					e.preventDefault();
				}
			}
		}));
		this._register(this._findInput.inputBox.onDidHeightChange((e) => {
			if (this._tryUpdateHeight()) this._showViewZone();
		}));
		if (isLinux) this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
		this._matchesCount = document.createElement("div");
		this._matchesCount.className = "matchesCount";
		this._updateMatchesCount();
		this._prevBtn = this._register(new SimpleButton({
			label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
			icon: findPreviousMatchIcon,
			onTrigger: () => {
				this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().then(void 0, onUnexpectedError);
			}
		}));
		this._nextBtn = this._register(new SimpleButton({
			label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
			icon: findNextMatchIcon,
			onTrigger: () => {
				this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().then(void 0, onUnexpectedError);
			}
		}));
		const findPart = document.createElement("div");
		findPart.className = "find-part";
		findPart.appendChild(this._findInput.domNode);
		const actionsContainer = document.createElement("div");
		actionsContainer.className = "find-actions";
		findPart.appendChild(actionsContainer);
		actionsContainer.appendChild(this._matchesCount);
		actionsContainer.appendChild(this._prevBtn.domNode);
		actionsContainer.appendChild(this._nextBtn.domNode);
		this._toggleSelectionFind = this._register(new Toggle({
			icon: findSelectionIcon,
			title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
			isChecked: false
		}));
		this._register(this._toggleSelectionFind.onChange(() => {
			if (this._toggleSelectionFind.checked) {
				if (this._codeEditor.hasModel()) {
					const selections = this._codeEditor.getSelections();
					selections.map((selection) => {
						if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
						if (!selection.isEmpty()) return selection;
						return null;
					}).filter((element) => !!element);
					if (selections.length) this._state.change({ searchScope: selections }, true);
				}
			} else this._state.change({ searchScope: null }, true);
		}));
		actionsContainer.appendChild(this._toggleSelectionFind.domNode);
		this._closeBtn = this._register(new SimpleButton({
			label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
			icon: widgetClose,
			onTrigger: () => {
				this._state.change({
					isRevealed: false,
					searchScope: null
				}, false);
			},
			onKeyDown: (e) => {
				if (e.equals(2)) {
					if (this._isReplaceVisible) {
						if (this._replaceBtn.isEnabled()) this._replaceBtn.focus();
						else this._codeEditor.focus();
						e.preventDefault();
					}
				}
			}
		}));
		actionsContainer.appendChild(this._closeBtn.domNode);
		this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
			label: NLS_REPLACE_INPUT_LABEL,
			placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
			appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
			history: [],
			flexibleHeight,
			flexibleWidth,
			flexibleMaxHeight: 118,
			showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)
		}, this._contextKeyService, true));
		this._replaceInput.setPreserveCase(!!this._state.preserveCase);
		this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
		this._register(this._replaceInput.inputBox.onDidChange(() => {
			this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
		}));
		this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
			if (this._isReplaceVisible && this._tryUpdateHeight()) this._showViewZone();
		}));
		this._register(this._replaceInput.onDidOptionChange(() => {
			this._state.change({ preserveCase: this._replaceInput.getPreserveCase() }, true);
		}));
		this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
			if (e.equals(2)) {
				if (this._prevBtn.isEnabled()) this._prevBtn.focus();
				else if (this._nextBtn.isEnabled()) this._nextBtn.focus();
				else if (this._toggleSelectionFind.enabled) this._toggleSelectionFind.focus();
				else if (this._closeBtn.isEnabled()) this._closeBtn.focus();
				e.preventDefault();
			}
		}));
		this._replaceBtn = this._register(new SimpleButton({
			label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
			icon: findReplaceIcon,
			onTrigger: () => {
				this._controller.replace();
			},
			onKeyDown: (e) => {
				if (e.equals(1026)) {
					this._closeBtn.focus();
					e.preventDefault();
				}
			}
		}));
		this._replaceAllBtn = this._register(new SimpleButton({
			label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
			icon: findReplaceAllIcon,
			onTrigger: () => {
				this._controller.replaceAll();
			}
		}));
		const replacePart = document.createElement("div");
		replacePart.className = "replace-part";
		replacePart.appendChild(this._replaceInput.domNode);
		const replaceActionsContainer = document.createElement("div");
		replaceActionsContainer.className = "replace-actions";
		replacePart.appendChild(replaceActionsContainer);
		replaceActionsContainer.appendChild(this._replaceBtn.domNode);
		replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
		this._toggleReplaceBtn = this._register(new SimpleButton({
			label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
			className: "codicon toggle left",
			onTrigger: () => {
				this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
				if (this._isReplaceVisible) {
					this._replaceInput.width = getTotalWidth(this._findInput.domNode);
					this._replaceInput.inputBox.layout();
				}
				this._showViewZone();
			}
		}));
		this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
		this._domNode = document.createElement("div");
		this._domNode.className = "editor-widget find-widget";
		this._domNode.setAttribute("aria-hidden", "true");
		this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
		this._domNode.appendChild(this._toggleReplaceBtn.domNode);
		this._domNode.appendChild(findPart);
		this._domNode.appendChild(replacePart);
		this._resizeSash = new Sash(this._domNode, this, {
			orientation: 0,
			size: 2
		});
		this._resized = false;
		let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
		this._register(this._resizeSash.onDidStart(() => {
			originalWidth = getTotalWidth(this._domNode);
		}));
		this._register(this._resizeSash.onDidChange((evt) => {
			this._resized = true;
			const width = originalWidth + evt.startX - evt.currentX;
			if (width < FIND_WIDGET_INITIAL_WIDTH) return;
			if (width > (parseFloat(getComputedStyle(this._domNode).maxWidth) || 0)) return;
			this._domNode.style.width = `${width}px`;
			if (this._isReplaceVisible) this._replaceInput.width = getTotalWidth(this._findInput.domNode);
			this._findInput.inputBox.layout();
			this._tryUpdateHeight();
		}));
		this._register(this._resizeSash.onDidReset(() => {
			const currentWidth = getTotalWidth(this._domNode);
			if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) return;
			let width = FIND_WIDGET_INITIAL_WIDTH;
			if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
				const layoutInfo = this._codeEditor.getLayoutInfo();
				width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
				this._resized = true;
			}
			this._domNode.style.width = `${width}px`;
			if (this._isReplaceVisible) this._replaceInput.width = getTotalWidth(this._findInput.domNode);
			this._findInput.inputBox.layout();
		}));
	}
	updateAccessibilitySupport() {
		const value = this._codeEditor.getOption(2);
		this._findInput.setFocusInputOnOptionClick(value !== 2);
	}
};
FindWidget.ID = "editor.contrib.findWidget";
var SimpleButton = class extends Widget {
	constructor(opts) {
		super();
		this._opts = opts;
		let className = "button";
		if (this._opts.className) className = className + " " + this._opts.className;
		if (this._opts.icon) className = className + " " + ThemeIcon.asClassName(this._opts.icon);
		this._domNode = document.createElement("div");
		this._domNode.title = this._opts.label;
		this._domNode.tabIndex = 0;
		this._domNode.className = className;
		this._domNode.setAttribute("role", "button");
		this._domNode.setAttribute("aria-label", this._opts.label);
		this.onclick(this._domNode, (e) => {
			this._opts.onTrigger();
			e.preventDefault();
		});
		this.onkeydown(this._domNode, (e) => {
			var _a$5, _b$1;
			if (e.equals(10) || e.equals(3)) {
				this._opts.onTrigger();
				e.preventDefault();
				return;
			}
			(_b$1 = (_a$5 = this._opts).onKeyDown) === null || _b$1 === void 0 || _b$1.call(_a$5, e);
		});
	}
	get domNode() {
		return this._domNode;
	}
	isEnabled() {
		return this._domNode.tabIndex >= 0;
	}
	focus() {
		this._domNode.focus();
	}
	setEnabled(enabled) {
		this._domNode.classList.toggle("disabled", !enabled);
		this._domNode.setAttribute("aria-disabled", String(!enabled));
		this._domNode.tabIndex = enabled ? 0 : -1;
	}
	setExpanded(expanded) {
		this._domNode.setAttribute("aria-expanded", String(!!expanded));
		if (expanded) {
			this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
			this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
		} else {
			this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
			this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
		}
	}
};
registerThemingParticipant((theme, collector) => {
	const addBackgroundColorRule = (selector, color) => {
		if (color) collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
	};
	addBackgroundColorRule(".findMatch", theme.getColor(editorFindMatchHighlight));
	addBackgroundColorRule(".currentFindMatch", theme.getColor(editorFindMatch));
	addBackgroundColorRule(".findScope", theme.getColor(editorFindRangeHighlight));
	addBackgroundColorRule(".find-widget", theme.getColor(editorWidgetBackground));
	const widgetShadowColor = theme.getColor(widgetShadow);
	if (widgetShadowColor) collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
	const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
	if (findMatchHighlightBorder) collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
	const findMatchBorder = theme.getColor(editorFindMatchBorder);
	if (findMatchBorder) collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
	const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
	if (findRangeHighlightBorder) collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
	const hcBorder = theme.getColor(contrastBorder);
	if (hcBorder) collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
	const foreground$1 = theme.getColor(editorWidgetForeground);
	if (foreground$1) collector.addRule(`.monaco-editor .find-widget { color: ${foreground$1}; }`);
	const error = theme.getColor(errorForeground);
	if (error) collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
	const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);
	if (resizeBorderBackground) collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
	else {
		const border = theme.getColor(editorWidgetBorder);
		if (border) collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
	}
	const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
	if (toolbarHoverBackgroundColor) collector.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${toolbarHoverBackgroundColor} !important;
		}
	`);
	const focusOutline = theme.getColor(focusBorder);
	if (focusOutline) collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
var __decorate$48 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$48 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$30 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor$1, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
	if (!editor$1.hasModel()) return null;
	const selection = editor$1.getSelection();
	if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
		if (selection.isEmpty()) {
			const wordAtPosition = editor$1.getConfiguredWordAtPosition(selection.getStartPosition());
			if (wordAtPosition && false === seedSearchStringFromNonEmptySelection) return wordAtPosition.word;
		} else if (editor$1.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) return editor$1.getModel().getValueInRange(selection);
	}
	return null;
}
var CommonFindController = class CommonFindController$1 extends Disposable {
	constructor(editor$1, contextKeyService, storageService, clipboardService) {
		super();
		this._editor = editor$1;
		this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
		this._contextKeyService = contextKeyService;
		this._storageService = storageService;
		this._clipboardService = clipboardService;
		this._updateHistoryDelayer = new Delayer(500);
		this._state = this._register(new FindReplaceState());
		this.loadQueryState();
		this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
		this._model = null;
		this._register(this._editor.onDidChangeModel(() => {
			const shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
			this.disposeModel();
			this._state.change({
				searchScope: null,
				matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
				wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
				isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
				preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
			}, false);
			if (shouldRestartFind) this._start({
				forceRevealReplace: false,
				seedSearchStringFromSelection: "none",
				seedSearchStringFromNonEmptySelection: false,
				seedSearchStringFromGlobalClipboard: false,
				shouldFocus: 0,
				shouldAnimate: false,
				updateSearchScope: false,
				loop: this._editor.getOption(37).loop
			});
		}));
	}
	get editor() {
		return this._editor;
	}
	static get(editor$1) {
		return editor$1.getContribution(CommonFindController$1.ID);
	}
	dispose() {
		this.disposeModel();
		super.dispose();
	}
	disposeModel() {
		if (this._model) {
			this._model.dispose();
			this._model = null;
		}
	}
	_onStateChanged(e) {
		this.saveQueryState(e);
		if (e.isRevealed) if (this._state.isRevealed) this._findWidgetVisible.set(true);
		else {
			this._findWidgetVisible.reset();
			this.disposeModel();
		}
		if (e.searchString) this.setGlobalBufferTerm(this._state.searchString);
	}
	saveQueryState(e) {
		if (e.isRegex) this._storageService.store("editor.isRegex", this._state.actualIsRegex, 1, 0);
		if (e.wholeWord) this._storageService.store("editor.wholeWord", this._state.actualWholeWord, 1, 0);
		if (e.matchCase) this._storageService.store("editor.matchCase", this._state.actualMatchCase, 1, 0);
		if (e.preserveCase) this._storageService.store("editor.preserveCase", this._state.actualPreserveCase, 1, 0);
	}
	loadQueryState() {
		this._state.change({
			matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
			wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
			isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
			preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
		}, false);
	}
	isFindInputFocused() {
		return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
	}
	getState() {
		return this._state;
	}
	closeFindWidget() {
		this._state.change({
			isRevealed: false,
			searchScope: null
		}, false);
		this._editor.focus();
	}
	toggleCaseSensitive() {
		this._state.change({ matchCase: !this._state.matchCase }, false);
		if (!this._state.isRevealed) this.highlightFindOptions();
	}
	toggleWholeWords() {
		this._state.change({ wholeWord: !this._state.wholeWord }, false);
		if (!this._state.isRevealed) this.highlightFindOptions();
	}
	toggleRegex() {
		this._state.change({ isRegex: !this._state.isRegex }, false);
		if (!this._state.isRevealed) this.highlightFindOptions();
	}
	togglePreserveCase() {
		this._state.change({ preserveCase: !this._state.preserveCase }, false);
		if (!this._state.isRevealed) this.highlightFindOptions();
	}
	toggleSearchScope() {
		if (this._state.searchScope) this._state.change({ searchScope: null }, true);
		else if (this._editor.hasModel()) {
			const selections = this._editor.getSelections();
			selections.map((selection) => {
				if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
				if (!selection.isEmpty()) return selection;
				return null;
			}).filter((element) => !!element);
			if (selections.length) this._state.change({ searchScope: selections }, true);
		}
	}
	setSearchString(searchString) {
		if (this._state.isRegex) searchString = escapeRegExpCharacters(searchString);
		this._state.change({ searchString }, false);
	}
	highlightFindOptions(ignoreWhenVisible = false) {}
	_start(opts, newState) {
		return __awaiter$30(this, void 0, void 0, function* () {
			this.disposeModel();
			if (!this._editor.hasModel()) return;
			const stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });
			if (opts.seedSearchStringFromSelection === "single") {
				const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
				if (selectionSearchString) if (this._state.isRegex) stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
				else stateChanges.searchString = selectionSearchString;
			} else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
				const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
				if (selectionSearchString) stateChanges.searchString = selectionSearchString;
			}
			if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
				const selectionSearchString = yield this.getGlobalBufferTerm();
				if (!this._editor.hasModel()) return;
				if (selectionSearchString) stateChanges.searchString = selectionSearchString;
			}
			if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) stateChanges.isReplaceRevealed = true;
			else if (!this._findWidgetVisible.get()) stateChanges.isReplaceRevealed = false;
			if (opts.updateSearchScope) {
				const currentSelections = this._editor.getSelections();
				if (currentSelections.some((selection) => !selection.isEmpty())) stateChanges.searchScope = currentSelections;
			}
			stateChanges.loop = opts.loop;
			this._state.change(stateChanges, false);
			if (!this._model) this._model = new FindModelBoundToEditorModel(this._editor, this._state);
		});
	}
	start(opts, newState) {
		return this._start(opts, newState);
	}
	moveToNextMatch() {
		if (this._model) {
			this._model.moveToNextMatch();
			return true;
		}
		return false;
	}
	moveToPrevMatch() {
		if (this._model) {
			this._model.moveToPrevMatch();
			return true;
		}
		return false;
	}
	replace() {
		if (this._model) {
			this._model.replace();
			return true;
		}
		return false;
	}
	replaceAll() {
		if (this._model) {
			this._model.replaceAll();
			return true;
		}
		return false;
	}
	selectAllMatches() {
		if (this._model) {
			this._model.selectAllMatches();
			this._editor.focus();
			return true;
		}
		return false;
	}
	getGlobalBufferTerm() {
		return __awaiter$30(this, void 0, void 0, function* () {
			if (this._editor.getOption(37).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) return this._clipboardService.readFindText();
			return "";
		});
	}
	setGlobalBufferTerm(text) {
		if (this._editor.getOption(37).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) this._clipboardService.writeFindText(text);
	}
};
CommonFindController.ID = "editor.contrib.findController";
CommonFindController = __decorate$48([
	__param$48(1, IContextKeyService),
	__param$48(2, IStorageService),
	__param$48(3, IClipboardService)
], CommonFindController);
var FindController = class FindController$1 extends CommonFindController {
	constructor(editor$1, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {
		super(editor$1, _contextKeyService, _storageService, clipboardService);
		this._contextViewService = _contextViewService;
		this._keybindingService = _keybindingService;
		this._themeService = _themeService;
		this._notificationService = _notificationService;
		this._widget = null;
		this._findOptionsWidget = null;
	}
	_start(opts, newState) {
		const _super = Object.create(null, { _start: { get: () => super._start } });
		return __awaiter$30(this, void 0, void 0, function* () {
			if (!this._widget) this._createFindWidget();
			const selection = this._editor.getSelection();
			let updateSearchScope = false;
			switch (this._editor.getOption(37).autoFindInSelection) {
				case "always":
					updateSearchScope = true;
					break;
				case "never":
					updateSearchScope = false;
					break;
				case "multiline":
					updateSearchScope = !!selection && selection.startLineNumber !== selection.endLineNumber;
					break;
				default: break;
			}
			opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
			yield _super._start.call(this, opts, newState);
			if (this._widget) {
				if (opts.shouldFocus === 2) this._widget.focusReplaceInput();
				else if (opts.shouldFocus === 1) this._widget.focusFindInput();
			}
		});
	}
	highlightFindOptions(ignoreWhenVisible = false) {
		if (!this._widget) this._createFindWidget();
		if (this._state.isRevealed && !ignoreWhenVisible) this._widget.highlightFindOptions();
		else this._findOptionsWidget.highlightFindOptions();
	}
	_createFindWidget() {
		this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
		this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService, this._themeService));
	}
};
FindController = __decorate$48([
	__param$48(1, IContextViewService),
	__param$48(2, IContextKeyService),
	__param$48(3, IKeybindingService),
	__param$48(4, IThemeService),
	__param$48(5, INotificationService),
	__param$48(6, IStorageService),
	__param$48(7, IClipboardService)
], FindController);
const StartFindAction = registerMultiEditorAction(new MultiEditorAction({
	id: FIND_IDS.StartFindAction,
	label: localize("startFindAction", "Find"),
	alias: "Find",
	precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
	kbOpts: {
		kbExpr: null,
		primary: 2084,
		weight: 100
	},
	menuOpts: {
		menuId: MenuId.MenubarEditMenu,
		group: "3_find",
		title: localize({
			key: "miFind",
			comment: ["&& denotes a mnemonic"]
		}, "&&Find"),
		order: 1
	}
}));
StartFindAction.addImplementation(0, (accessor, editor$1, args) => {
	const controller = CommonFindController.get(editor$1);
	if (!controller) return false;
	return controller.start({
		forceRevealReplace: false,
		seedSearchStringFromSelection: editor$1.getOption(37).seedSearchStringFromSelection !== "never" ? "single" : "none",
		seedSearchStringFromNonEmptySelection: editor$1.getOption(37).seedSearchStringFromSelection === "selection",
		seedSearchStringFromGlobalClipboard: editor$1.getOption(37).globalFindClipboard,
		shouldFocus: 1,
		shouldAnimate: true,
		updateSearchScope: false,
		loop: editor$1.getOption(37).loop
	});
});
var findArgDescription = {
	description: "Open a new In-Editor Find Widget.",
	args: [{
		name: "Open a new In-Editor Find Widget args",
		schema: { properties: {
			searchString: { type: "string" },
			replaceString: { type: "string" },
			regex: { type: "boolean" },
			regexOverride: {
				type: "number",
				description: localize("actions.find.isRegexOverride", "Overrides \"Use Regular Expression\" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False")
			},
			wholeWord: { type: "boolean" },
			wholeWordOverride: {
				type: "number",
				description: localize("actions.find.wholeWordOverride", "Overrides \"Match Whole Word\" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False")
			},
			matchCase: { type: "boolean" },
			matchCaseOverride: {
				type: "number",
				description: localize("actions.find.matchCaseOverride", "Overrides \"Math Case\" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False")
			},
			preserveCase: { type: "boolean" },
			preserveCaseOverride: {
				type: "number",
				description: localize("actions.find.preserveCaseOverride", "Overrides \"Preserve Case\" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False")
			},
			findInSelection: { type: "boolean" }
		} }
	}]
};
var StartFindWithArgsAction = class extends EditorAction {
	constructor() {
		super({
			id: FIND_IDS.StartFindWithArgs,
			label: localize("startFindWithArgsAction", "Find With Arguments"),
			alias: "Find With Arguments",
			precondition: void 0,
			kbOpts: {
				kbExpr: null,
				primary: 0,
				weight: 100
			},
			description: findArgDescription
		});
	}
	run(accessor, editor$1, args) {
		return __awaiter$30(this, void 0, void 0, function* () {
			const controller = CommonFindController.get(editor$1);
			if (controller) {
				const newState = args ? {
					searchString: args.searchString,
					replaceString: args.replaceString,
					isReplaceRevealed: args.replaceString !== void 0,
					isRegex: args.isRegex,
					wholeWord: args.matchWholeWord,
					matchCase: args.isCaseSensitive,
					preserveCase: args.preserveCase
				} : {};
				yield controller.start({
					forceRevealReplace: false,
					seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor$1.getOption(37).seedSearchStringFromSelection !== "never" ? "single" : "none",
					seedSearchStringFromNonEmptySelection: editor$1.getOption(37).seedSearchStringFromSelection === "selection",
					seedSearchStringFromGlobalClipboard: true,
					shouldFocus: 1,
					shouldAnimate: true,
					updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,
					loop: editor$1.getOption(37).loop
				}, newState);
				controller.setGlobalBufferTerm(controller.getState().searchString);
			}
		});
	}
};
var StartFindWithSelectionAction = class extends EditorAction {
	constructor() {
		super({
			id: FIND_IDS.StartFindWithSelection,
			label: localize("startFindWithSelectionAction", "Find With Selection"),
			alias: "Find With Selection",
			precondition: void 0,
			kbOpts: {
				kbExpr: null,
				primary: 0,
				mac: { primary: 2083 },
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		return __awaiter$30(this, void 0, void 0, function* () {
			const controller = CommonFindController.get(editor$1);
			if (controller) {
				yield controller.start({
					forceRevealReplace: false,
					seedSearchStringFromSelection: "multiple",
					seedSearchStringFromNonEmptySelection: false,
					seedSearchStringFromGlobalClipboard: false,
					shouldFocus: 0,
					shouldAnimate: true,
					updateSearchScope: false,
					loop: editor$1.getOption(37).loop
				});
				controller.setGlobalBufferTerm(controller.getState().searchString);
			}
		});
	}
};
var MatchFindAction = class extends EditorAction {
	run(accessor, editor$1) {
		return __awaiter$30(this, void 0, void 0, function* () {
			const controller = CommonFindController.get(editor$1);
			if (controller && !this._run(controller)) {
				yield controller.start({
					forceRevealReplace: false,
					seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor$1.getOption(37).seedSearchStringFromSelection !== "never" ? "single" : "none",
					seedSearchStringFromNonEmptySelection: editor$1.getOption(37).seedSearchStringFromSelection === "selection",
					seedSearchStringFromGlobalClipboard: true,
					shouldFocus: 0,
					shouldAnimate: true,
					updateSearchScope: false,
					loop: editor$1.getOption(37).loop
				});
				this._run(controller);
			}
		});
	}
};
var NextMatchFindAction = class extends MatchFindAction {
	constructor() {
		super({
			id: FIND_IDS.NextMatchFindAction,
			label: localize("findNextMatchAction", "Find Next"),
			alias: "Find Next",
			precondition: void 0,
			kbOpts: [{
				kbExpr: EditorContextKeys.focus,
				primary: 61,
				mac: {
					primary: 2085,
					secondary: [61]
				},
				weight: 100
			}, {
				kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
				primary: 3,
				weight: 100
			}]
		});
	}
	_run(controller) {
		if (controller.moveToNextMatch()) {
			controller.editor.pushUndoStop();
			return true;
		}
		return false;
	}
};
var PreviousMatchFindAction = class extends MatchFindAction {
	constructor() {
		super({
			id: FIND_IDS.PreviousMatchFindAction,
			label: localize("findPreviousMatchAction", "Find Previous"),
			alias: "Find Previous",
			precondition: void 0,
			kbOpts: [{
				kbExpr: EditorContextKeys.focus,
				primary: 1085,
				mac: {
					primary: 3109,
					secondary: [1085]
				},
				weight: 100
			}, {
				kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
				primary: 1027,
				weight: 100
			}]
		});
	}
	_run(controller) {
		return controller.moveToPrevMatch();
	}
};
var SelectionMatchFindAction = class extends EditorAction {
	run(accessor, editor$1) {
		return __awaiter$30(this, void 0, void 0, function* () {
			const controller = CommonFindController.get(editor$1);
			if (!controller) return;
			const seedSearchStringFromNonEmptySelection = editor$1.getOption(37).seedSearchStringFromSelection === "selection";
			let selectionSearchString = null;
			if (editor$1.getOption(37).seedSearchStringFromSelection !== "never") selectionSearchString = getSelectionSearchString(editor$1, "single", seedSearchStringFromNonEmptySelection);
			if (selectionSearchString) controller.setSearchString(selectionSearchString);
			if (!this._run(controller)) {
				yield controller.start({
					forceRevealReplace: false,
					seedSearchStringFromSelection: editor$1.getOption(37).seedSearchStringFromSelection !== "never" ? "single" : "none",
					seedSearchStringFromNonEmptySelection,
					seedSearchStringFromGlobalClipboard: false,
					shouldFocus: 0,
					shouldAnimate: true,
					updateSearchScope: false,
					loop: editor$1.getOption(37).loop
				});
				this._run(controller);
			}
		});
	}
};
var NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
	constructor() {
		super({
			id: FIND_IDS.NextSelectionMatchFindAction,
			label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
			alias: "Find Next Selection",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 2109,
				weight: 100
			}
		});
	}
	_run(controller) {
		return controller.moveToNextMatch();
	}
};
var PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
	constructor() {
		super({
			id: FIND_IDS.PreviousSelectionMatchFindAction,
			label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
			alias: "Find Previous Selection",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 3133,
				weight: 100
			}
		});
	}
	_run(controller) {
		return controller.moveToPrevMatch();
	}
};
const StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
	id: FIND_IDS.StartFindReplaceAction,
	label: localize("startReplace", "Replace"),
	alias: "Replace",
	precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
	kbOpts: {
		kbExpr: null,
		primary: 2086,
		mac: { primary: 2596 },
		weight: 100
	},
	menuOpts: {
		menuId: MenuId.MenubarEditMenu,
		group: "3_find",
		title: localize({
			key: "miReplace",
			comment: ["&& denotes a mnemonic"]
		}, "&&Replace"),
		order: 2
	}
}));
StartFindReplaceAction.addImplementation(0, (accessor, editor$1, args) => {
	if (!editor$1.hasModel() || editor$1.getOption(83)) return false;
	const controller = CommonFindController.get(editor$1);
	if (!controller) return false;
	const currentSelection = editor$1.getSelection();
	const findInputFocused = controller.isFindInputFocused();
	const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor$1.getOption(37).seedSearchStringFromSelection !== "never" && !findInputFocused;
	const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
	return controller.start({
		forceRevealReplace: true,
		seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
		seedSearchStringFromNonEmptySelection: editor$1.getOption(37).seedSearchStringFromSelection === "selection",
		seedSearchStringFromGlobalClipboard: editor$1.getOption(37).seedSearchStringFromSelection !== "never",
		shouldFocus,
		shouldAnimate: true,
		updateSearchScope: false,
		loop: editor$1.getOption(37).loop
	});
});
registerEditorContribution(CommonFindController.ID, FindController);
registerEditorAction(StartFindWithArgsAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
	id: FIND_IDS.CloseFindWidgetCommand,
	precondition: CONTEXT_FIND_WIDGET_VISIBLE,
	handler: (x) => x.closeFindWidget(),
	kbOpts: {
		weight: 105,
		kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
		primary: 9,
		secondary: [1033]
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ToggleCaseSensitiveCommand,
	precondition: void 0,
	handler: (x) => x.toggleCaseSensitive(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: ToggleCaseSensitiveKeybinding.primary,
		mac: ToggleCaseSensitiveKeybinding.mac,
		win: ToggleCaseSensitiveKeybinding.win,
		linux: ToggleCaseSensitiveKeybinding.linux
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ToggleWholeWordCommand,
	precondition: void 0,
	handler: (x) => x.toggleWholeWords(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: ToggleWholeWordKeybinding.primary,
		mac: ToggleWholeWordKeybinding.mac,
		win: ToggleWholeWordKeybinding.win,
		linux: ToggleWholeWordKeybinding.linux
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ToggleRegexCommand,
	precondition: void 0,
	handler: (x) => x.toggleRegex(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: ToggleRegexKeybinding.primary,
		mac: ToggleRegexKeybinding.mac,
		win: ToggleRegexKeybinding.win,
		linux: ToggleRegexKeybinding.linux
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ToggleSearchScopeCommand,
	precondition: void 0,
	handler: (x) => x.toggleSearchScope(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: ToggleSearchScopeKeybinding.primary,
		mac: ToggleSearchScopeKeybinding.mac,
		win: ToggleSearchScopeKeybinding.win,
		linux: ToggleSearchScopeKeybinding.linux
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.TogglePreserveCaseCommand,
	precondition: void 0,
	handler: (x) => x.togglePreserveCase(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: TogglePreserveCaseKeybinding.primary,
		mac: TogglePreserveCaseKeybinding.mac,
		win: TogglePreserveCaseKeybinding.win,
		linux: TogglePreserveCaseKeybinding.linux
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ReplaceOneAction,
	precondition: CONTEXT_FIND_WIDGET_VISIBLE,
	handler: (x) => x.replace(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: 3094
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ReplaceOneAction,
	precondition: CONTEXT_FIND_WIDGET_VISIBLE,
	handler: (x) => x.replace(),
	kbOpts: {
		weight: 105,
		kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
		primary: 3
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ReplaceAllAction,
	precondition: CONTEXT_FIND_WIDGET_VISIBLE,
	handler: (x) => x.replaceAll(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: 2563
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.ReplaceAllAction,
	precondition: CONTEXT_FIND_WIDGET_VISIBLE,
	handler: (x) => x.replaceAll(),
	kbOpts: {
		weight: 105,
		kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
		primary: void 0,
		mac: { primary: 2051 }
	}
}));
registerEditorCommand(new FindCommand({
	id: FIND_IDS.SelectAllMatchesAction,
	precondition: CONTEXT_FIND_WIDGET_VISIBLE,
	handler: (x) => x.selectAllMatches(),
	kbOpts: {
		weight: 105,
		kbExpr: EditorContextKeys.focus,
		primary: 515
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js
const MAX_FOLDING_REGIONS = 65535;
const MAX_LINE_NUMBER = 16777215;
var MASK_INDENT = 4278190080;
var BitField = class {
	constructor(size$1) {
		const numWords = Math.ceil(size$1 / 32);
		this._states = new Uint32Array(numWords);
	}
	get(index) {
		const arrayIndex = index / 32 | 0;
		const bit = index % 32;
		return (this._states[arrayIndex] & 1 << bit) !== 0;
	}
	set(index, newState) {
		const arrayIndex = index / 32 | 0;
		const bit = index % 32;
		const value = this._states[arrayIndex];
		if (newState) this._states[arrayIndex] = value | 1 << bit;
		else this._states[arrayIndex] = value & ~(1 << bit);
	}
};
var FoldingRegions = class FoldingRegions {
	constructor(startIndexes, endIndexes, types) {
		this.sourceAbbr = {
			[0]: " ",
			[1]: "u",
			[2]: "r"
		};
		if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) throw new Error("invalid startIndexes or endIndexes size");
		this._startIndexes = startIndexes;
		this._endIndexes = endIndexes;
		this._collapseStates = new BitField(startIndexes.length);
		this._userDefinedStates = new BitField(startIndexes.length);
		this._recoveredStates = new BitField(startIndexes.length);
		this._types = types;
		this._parentsComputed = false;
	}
	ensureParentIndices() {
		if (!this._parentsComputed) {
			this._parentsComputed = true;
			const parentIndexes = [];
			const isInsideLast = (startLineNumber, endLineNumber) => {
				const index = parentIndexes[parentIndexes.length - 1];
				return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;
			};
			for (let i = 0, len = this._startIndexes.length; i < len; i++) {
				const startLineNumber = this._startIndexes[i];
				const endLineNumber = this._endIndexes[i];
				if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
				while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) parentIndexes.pop();
				const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
				parentIndexes.push(i);
				this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
				this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
			}
		}
	}
	get length() {
		return this._startIndexes.length;
	}
	getStartLineNumber(index) {
		return this._startIndexes[index] & MAX_LINE_NUMBER;
	}
	getEndLineNumber(index) {
		return this._endIndexes[index] & MAX_LINE_NUMBER;
	}
	getType(index) {
		return this._types ? this._types[index] : void 0;
	}
	hasTypes() {
		return !!this._types;
	}
	isCollapsed(index) {
		return this._collapseStates.get(index);
	}
	setCollapsed(index, newState) {
		this._collapseStates.set(index, newState);
	}
	isUserDefined(index) {
		return this._userDefinedStates.get(index);
	}
	setUserDefined(index, newState) {
		return this._userDefinedStates.set(index, newState);
	}
	isRecovered(index) {
		return this._recoveredStates.get(index);
	}
	setRecovered(index, newState) {
		return this._recoveredStates.set(index, newState);
	}
	getSource(index) {
		if (this.isUserDefined(index)) return 1;
		else if (this.isRecovered(index)) return 2;
		return 0;
	}
	setSource(index, source) {
		if (source === 1) {
			this.setUserDefined(index, true);
			this.setRecovered(index, false);
		} else if (source === 2) {
			this.setUserDefined(index, false);
			this.setRecovered(index, true);
		} else {
			this.setUserDefined(index, false);
			this.setRecovered(index, false);
		}
	}
	setCollapsedAllOfType(type, newState) {
		let hasChanged = false;
		if (this._types) {
			for (let i = 0; i < this._types.length; i++) if (this._types[i] === type) {
				this.setCollapsed(i, newState);
				hasChanged = true;
			}
		}
		return hasChanged;
	}
	toRegion(index) {
		return new FoldingRegion(this, index);
	}
	getParentIndex(index) {
		this.ensureParentIndices();
		const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
		if (parent === MAX_FOLDING_REGIONS) return -1;
		return parent;
	}
	contains(index, line) {
		return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
	}
	findIndex(line) {
		let low = 0, high = this._startIndexes.length;
		if (high === 0) return -1;
		while (low < high) {
			const mid = Math.floor((low + high) / 2);
			if (line < this.getStartLineNumber(mid)) high = mid;
			else low = mid + 1;
		}
		return low - 1;
	}
	findRange(line) {
		let index = this.findIndex(line);
		if (index >= 0) {
			if (this.getEndLineNumber(index) >= line) return index;
			index = this.getParentIndex(index);
			while (index !== -1) {
				if (this.contains(index, line)) return index;
				index = this.getParentIndex(index);
			}
		}
		return -1;
	}
	toString() {
		const res = [];
		for (let i = 0; i < this.length; i++) res[i] = `[${this.sourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? "+" : "-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;
		return res.join(", ");
	}
	toFoldRange(index) {
		return {
			startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,
			endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,
			type: this._types ? this._types[index] : void 0,
			isCollapsed: this.isCollapsed(index),
			source: this.getSource(index)
		};
	}
	static fromFoldRanges(ranges) {
		const rangesLength = ranges.length;
		const startIndexes = new Uint32Array(rangesLength);
		const endIndexes = new Uint32Array(rangesLength);
		let types = [];
		let gotTypes = false;
		for (let i = 0; i < rangesLength; i++) {
			const range = ranges[i];
			startIndexes[i] = range.startLineNumber;
			endIndexes[i] = range.endLineNumber;
			types.push(range.type);
			if (range.type) gotTypes = true;
		}
		if (!gotTypes) types = void 0;
		const regions = new FoldingRegions(startIndexes, endIndexes, types);
		for (let i = 0; i < rangesLength; i++) {
			if (ranges[i].isCollapsed) regions.setCollapsed(i, true);
			regions.setSource(i, ranges[i].source);
		}
		return regions;
	}
	/**
	* Two inputs, each a FoldingRegions or a FoldRange[], are merged.
	* Each input must be pre-sorted on startLineNumber.
	* The first list is assumed to always include all regions currently defined by range providers.
	* The second list only contains the previously collapsed and all manual ranges.
	* If the line position matches, the range of the new range is taken, and the range is no longer manual
	* When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
	* overlapping entries in the first list are discarded.
	* Invalid entries are discarded. An entry is invalid if:
	* 		the start and end line numbers aren't a valid range of line numbers,
	* 		it is out of sequence or has the same start line as a preceding entry,
	* 		it overlaps a preceding entry and is not fully contained by that entry.
	*/
	static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {
		maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;
		const getIndexedFunction = (r, limit) => {
			return Array.isArray(r) ? ((i) => {
				return i < limit ? r[i] : void 0;
			}) : ((i) => {
				return i < limit ? r.toFoldRange(i) : void 0;
			});
		};
		const getA = getIndexedFunction(rangesA, rangesA.length);
		const getB = getIndexedFunction(rangesB, rangesB.length);
		let indexA = 0;
		let indexB = 0;
		let nextA = getA(0);
		let nextB = getB(0);
		const stackedRanges = [];
		let topStackedRange;
		let prevLineNumber = 0;
		const resultRanges = [];
		while (nextA || nextB) {
			let useRange = void 0;
			if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {
				if (nextA && nextA.startLineNumber === nextB.startLineNumber) {
					if (nextB.source === 1) useRange = nextB;
					else {
						useRange = nextA;
						useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;
						useRange.source = 0;
					}
					nextA = getA(++indexA);
				} else {
					useRange = nextB;
					if (nextB.isCollapsed && nextB.source === 0) useRange.source = 2;
				}
				nextB = getB(++indexB);
			} else {
				let scanIndex = indexB;
				let prescanB = nextB;
				while (true) {
					if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {
						useRange = nextA;
						break;
					}
					if (prescanB.source === 1 && prescanB.endLineNumber > nextA.endLineNumber) break;
					prescanB = getB(++scanIndex);
				}
				nextA = getA(++indexA);
			}
			if (useRange) {
				while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) topStackedRange = stackedRanges.pop();
				if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {
					resultRanges.push(useRange);
					prevLineNumber = useRange.startLineNumber;
					if (topStackedRange) stackedRanges.push(topStackedRange);
					topStackedRange = useRange;
				}
			}
		}
		return resultRanges;
	}
};
var FoldingRegion = class {
	constructor(ranges, index) {
		this.ranges = ranges;
		this.index = index;
	}
	get startLineNumber() {
		return this.ranges.getStartLineNumber(this.index);
	}
	get endLineNumber() {
		return this.ranges.getEndLineNumber(this.index);
	}
	get regionIndex() {
		return this.index;
	}
	get parentIndex() {
		return this.ranges.getParentIndex(this.index);
	}
	get isCollapsed() {
		return this.ranges.isCollapsed(this.index);
	}
	containedBy(range) {
		return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
	}
	containsLine(lineNumber) {
		return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js
var FoldingModel = class {
	constructor(textModel, decorationProvider) {
		this._updateEventEmitter = new Emitter$1();
		this.onDidChange = this._updateEventEmitter.event;
		this._textModel = textModel;
		this._decorationProvider = decorationProvider;
		this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
		this._editorDecorationIds = [];
	}
	get regions() {
		return this._regions;
	}
	get textModel() {
		return this._textModel;
	}
	toggleCollapseState(toggledRegions) {
		if (!toggledRegions.length) return;
		toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
		const processed = {};
		this._decorationProvider.changeDecorations((accessor) => {
			let k = 0;
			let dirtyRegionEndLine = -1;
			let lastHiddenLine = -1;
			const updateDecorationsUntil = (index) => {
				while (k < index) {
					const endLineNumber = this._regions.getEndLineNumber(k);
					const isCollapsed = this._regions.isCollapsed(k);
					if (endLineNumber <= dirtyRegionEndLine) {
						const isManual = this.regions.getSource(k) !== 0;
						accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));
					}
					if (isCollapsed && endLineNumber > lastHiddenLine) lastHiddenLine = endLineNumber;
					k++;
				}
			};
			for (const region of toggledRegions) {
				const index = region.regionIndex;
				const editorDecorationId = this._editorDecorationIds[index];
				if (editorDecorationId && !processed[editorDecorationId]) {
					processed[editorDecorationId] = true;
					updateDecorationsUntil(index);
					const newCollapseState = !this._regions.isCollapsed(index);
					this._regions.setCollapsed(index, newCollapseState);
					dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));
				}
			}
			updateDecorationsUntil(this._regions.length);
		});
		this._updateEventEmitter.fire({
			model: this,
			collapseStateChanged: toggledRegions
		});
	}
	removeManualRanges(ranges) {
		const newFoldingRanges = new Array();
		const intersects = (foldRange) => {
			for (const range of ranges) if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) return true;
			return false;
		};
		for (let i = 0; i < this._regions.length; i++) {
			const foldRange = this._regions.toFoldRange(i);
			if (foldRange.source === 0 || !intersects(foldRange)) newFoldingRanges.push(foldRange);
		}
		this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));
	}
	update(newRegions, blockedLineNumers = []) {
		const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);
		const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());
		this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
	}
	updatePost(newRegions) {
		const newEditorDecorations = [];
		let lastHiddenLine = -1;
		for (let index = 0, limit = newRegions.length; index < limit; index++) {
			const startLineNumber = newRegions.getStartLineNumber(index);
			const endLineNumber = newRegions.getEndLineNumber(index);
			const isCollapsed = newRegions.isCollapsed(index);
			const isManual = newRegions.getSource(index) !== 0;
			const decorationRange = {
				startLineNumber,
				startColumn: this._textModel.getLineMaxColumn(startLineNumber),
				endLineNumber,
				endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1
			};
			newEditorDecorations.push({
				range: decorationRange,
				options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual)
			});
			if (isCollapsed && endLineNumber > lastHiddenLine) lastHiddenLine = endLineNumber;
		}
		this._decorationProvider.changeDecorations((accessor) => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));
		this._regions = newRegions;
		this._updateEventEmitter.fire({ model: this });
	}
	_currentFoldedOrManualRanges(blockedLineNumers = []) {
		const isBlocked = (startLineNumber, endLineNumber) => {
			for (const blockedLineNumber of blockedLineNumers) if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) return true;
			return false;
		};
		const foldedRanges = [];
		for (let i = 0, limit = this._regions.length; i < limit; i++) {
			let isCollapsed = this.regions.isCollapsed(i);
			const source = this.regions.getSource(i);
			if (isCollapsed || source !== 0) {
				const foldRange = this._regions.toFoldRange(i);
				const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
				if (decRange) {
					if (isCollapsed && (isBlocked(decRange.startLineNumber, decRange.endLineNumber) || decRange.endLineNumber - decRange.startLineNumber !== foldRange.endLineNumber - foldRange.startLineNumber)) isCollapsed = false;
					foldedRanges.push({
						startLineNumber: decRange.startLineNumber,
						endLineNumber: decRange.endLineNumber,
						type: foldRange.type,
						isCollapsed,
						source
					});
				}
			}
		}
		return foldedRanges;
	}
	/**
	* Collapse state memento, for persistence only
	*/
	getMemento() {
		const foldedOrManualRanges = this._currentFoldedOrManualRanges();
		const result = [];
		for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {
			const range = foldedOrManualRanges[i];
			const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
			result.push({
				startLineNumber: range.startLineNumber,
				endLineNumber: range.endLineNumber,
				isCollapsed: range.isCollapsed,
				source: range.source,
				checksum
			});
		}
		return result.length > 0 ? result : void 0;
	}
	/**
	* Apply persisted state, for persistence only
	*/
	applyMemento(state) {
		var _a$5, _b$1;
		if (!Array.isArray(state)) return;
		const rangesToRestore = [];
		const maxLineNumber = this._textModel.getLineCount();
		for (const range of state) {
			if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) continue;
			const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
			if (!range.checksum || checksum === range.checksum) rangesToRestore.push({
				startLineNumber: range.startLineNumber,
				endLineNumber: range.endLineNumber,
				type: void 0,
				isCollapsed: (_a$5 = range.isCollapsed) !== null && _a$5 !== void 0 ? _a$5 : true,
				source: (_b$1 = range.source) !== null && _b$1 !== void 0 ? _b$1 : 0
			});
		}
		const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);
		this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
	}
	_getLinesChecksum(lineNumber1, lineNumber2) {
		return hash(this._textModel.getLineContent(lineNumber1) + this._textModel.getLineContent(lineNumber2)) % 1e6;
	}
	dispose() {
		this._decorationProvider.removeDecorations(this._editorDecorationIds);
	}
	getAllRegionsAtLine(lineNumber, filter) {
		const result = [];
		if (this._regions) {
			let index = this._regions.findRange(lineNumber);
			let level = 1;
			while (index >= 0) {
				const current = this._regions.toRegion(index);
				if (!filter || filter(current, level)) result.push(current);
				level++;
				index = current.parentIndex;
			}
		}
		return result;
	}
	getRegionAtLine(lineNumber) {
		if (this._regions) {
			const index = this._regions.findRange(lineNumber);
			if (index >= 0) return this._regions.toRegion(index);
		}
		return null;
	}
	getRegionsInside(region, filter) {
		const result = [];
		const index = region ? region.regionIndex + 1 : 0;
		const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
		if (filter && filter.length === 2) {
			const levelStack = [];
			for (let i = index, len = this._regions.length; i < len; i++) {
				const current = this._regions.toRegion(i);
				if (this._regions.getStartLineNumber(i) < endLineNumber) {
					while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) levelStack.pop();
					levelStack.push(current);
					if (filter(current, levelStack.length)) result.push(current);
				} else break;
			}
		} else for (let i = index, len = this._regions.length; i < len; i++) {
			const current = this._regions.toRegion(i);
			if (this._regions.getStartLineNumber(i) < endLineNumber) {
				if (!filter || filter(current)) result.push(current);
			} else break;
		}
		return result;
	}
};
/**
* Collapse or expand the regions at the given locations
* @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.
* @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.
*/
function toggleCollapseState(foldingModel, levels, lineNumbers) {
	const toToggle = [];
	for (const lineNumber of lineNumbers) {
		const region = foldingModel.getRegionAtLine(lineNumber);
		if (region) {
			const doCollapse = !region.isCollapsed;
			toToggle.push(region);
			if (levels > 1) {
				const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
				toToggle.push(...regionsInside);
			}
		}
	}
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Collapse or expand the regions at the given locations including all children.
* @param doCollapse Whether to collapse or expand
* @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.
* @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.
*/
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
	const toToggle = [];
	if (lineNumbers && lineNumbers.length > 0) for (const lineNumber of lineNumbers) {
		const region = foldingModel.getRegionAtLine(lineNumber);
		if (region) {
			if (region.isCollapsed !== doCollapse) toToggle.push(region);
			if (levels > 1) {
				const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
				toToggle.push(...regionsInside);
			}
		}
	}
	else {
		const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
		toToggle.push(...regionsInside);
	}
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Collapse or expand the regions at the given locations including all parents.
* @param doCollapse Whether to collapse or expand
* @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.
* @param lineNumbers the location of the regions to collapse or expand.
*/
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
	const toToggle = [];
	for (const lineNumber of lineNumbers) {
		const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
		toToggle.push(...regions);
	}
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.
* @param doCollapse Whether to collapse or expand
* @param lineNumbers the location of the regions to collapse or expand.
*/
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
	const toToggle = [];
	for (const lineNumber of lineNumbers) {
		const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
		if (regions.length > 0) toToggle.push(regions[0]);
	}
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.
* @param foldLevel level. Level == 1 is the top level
* @param doCollapse Whether to collapse or expand
*/
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
	const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line));
	const toToggle = foldingModel.getRegionsInside(null, filter);
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.
* @param doCollapse Whether to collapse or expand
* @param blockedLineNumbers the location of regions to not collapse or expand
*/
function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {
	const filteredRegions = [];
	for (const lineNumber of blockedLineNumbers) {
		const regions = foldingModel.getAllRegionsAtLine(lineNumber, void 0);
		if (regions.length > 0) filteredRegions.push(regions[0]);
	}
	const filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;
	const toToggle = foldingModel.getRegionsInside(null, filter);
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Folds all regions for which the lines start with a given regex
* @param foldingModel the folding model
*/
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
	const editorModel = foldingModel.textModel;
	const regions = foldingModel.regions;
	const toToggle = [];
	for (let i = regions.length - 1; i >= 0; i--) if (doCollapse !== regions.isCollapsed(i)) {
		const startLineNumber = regions.getStartLineNumber(i);
		if (regExp.test(editorModel.getLineContent(startLineNumber))) toToggle.push(regions.toRegion(i));
	}
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Folds all regions of the given type
* @param foldingModel the folding model
*/
function setCollapseStateForType(foldingModel, type, doCollapse) {
	const regions = foldingModel.regions;
	const toToggle = [];
	for (let i = regions.length - 1; i >= 0; i--) if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) toToggle.push(regions.toRegion(i));
	foldingModel.toggleCollapseState(toToggle);
}
/**
* Get line to go to for parent fold of current line
* @param lineNumber the current line number
* @param foldingModel the folding model
*
* @return Parent fold start line
*/
function getParentFoldLine(lineNumber, foldingModel) {
	let startLineNumber = null;
	const foldingRegion = foldingModel.getRegionAtLine(lineNumber);
	if (foldingRegion !== null) {
		startLineNumber = foldingRegion.startLineNumber;
		if (lineNumber === startLineNumber) {
			const parentFoldingIdx = foldingRegion.parentIndex;
			if (parentFoldingIdx !== -1) startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);
			else startLineNumber = null;
		}
	}
	return startLineNumber;
}
/**
* Get line to go to for previous fold at the same level of current line
* @param lineNumber the current line number
* @param foldingModel the folding model
*
* @return Previous fold start line
*/
function getPreviousFoldLine(lineNumber, foldingModel) {
	let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
	if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) if (lineNumber !== foldingRegion.startLineNumber) return foldingRegion.startLineNumber;
	else {
		const expectedParentIndex = foldingRegion.parentIndex;
		let minLineNumber = 0;
		if (expectedParentIndex !== -1) minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);
		while (foldingRegion !== null) if (foldingRegion.regionIndex > 0) {
			foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
			if (foldingRegion.startLineNumber <= minLineNumber) return null;
			else if (foldingRegion.parentIndex === expectedParentIndex) return foldingRegion.startLineNumber;
		} else return null;
	}
	else if (foldingModel.regions.length > 0) {
		foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);
		while (foldingRegion !== null) {
			if (foldingRegion.startLineNumber < lineNumber) return foldingRegion.startLineNumber;
			if (foldingRegion.regionIndex > 0) foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
			else foldingRegion = null;
		}
	}
	return null;
}
/**
* Get line to go to next fold at the same level of current line
* @param lineNumber the current line number
* @param foldingModel the folding model
*
* @return Next fold start line
*/
function getNextFoldLine(lineNumber, foldingModel) {
	let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
	if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
		const expectedParentIndex = foldingRegion.parentIndex;
		let maxLineNumber = 0;
		if (expectedParentIndex !== -1) maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);
		else if (foldingModel.regions.length === 0) return null;
		else maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);
		while (foldingRegion !== null) if (foldingRegion.regionIndex < foldingModel.regions.length) {
			foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
			if (foldingRegion.startLineNumber >= maxLineNumber) return null;
			else if (foldingRegion.parentIndex === expectedParentIndex) return foldingRegion.startLineNumber;
		} else return null;
	} else if (foldingModel.regions.length > 0) {
		foldingRegion = foldingModel.regions.toRegion(0);
		while (foldingRegion !== null) {
			if (foldingRegion.startLineNumber > lineNumber) return foldingRegion.startLineNumber;
			if (foldingRegion.regionIndex < foldingModel.regions.length) foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
			else foldingRegion = null;
		}
	}
	return null;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/hiddenRangeModel.js
var HiddenRangeModel = class {
	constructor(model) {
		this._updateEventEmitter = new Emitter$1();
		this._hasLineChanges = false;
		this._foldingModel = model;
		this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
		this._hiddenRanges = [];
		if (model.regions.length) this.updateHiddenRanges();
	}
	get onDidChange() {
		return this._updateEventEmitter.event;
	}
	get hiddenRanges() {
		return this._hiddenRanges;
	}
	notifyChangeModelContent(e) {
		if (this._hiddenRanges.length && !this._hasLineChanges) this._hasLineChanges = e.changes.some((change) => {
			return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;
		});
	}
	updateHiddenRanges() {
		let updateHiddenAreas = false;
		const newHiddenAreas = [];
		let i = 0;
		let k = 0;
		let lastCollapsedStart = Number.MAX_VALUE;
		let lastCollapsedEnd = -1;
		const ranges = this._foldingModel.regions;
		for (; i < ranges.length; i++) {
			if (!ranges.isCollapsed(i)) continue;
			const startLineNumber = ranges.getStartLineNumber(i) + 1;
			const endLineNumber = ranges.getEndLineNumber(i);
			if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) continue;
			if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
				newHiddenAreas.push(this._hiddenRanges[k]);
				k++;
			} else {
				updateHiddenAreas = true;
				newHiddenAreas.push(new Range$1(startLineNumber, 1, endLineNumber, 1));
			}
			lastCollapsedStart = startLineNumber;
			lastCollapsedEnd = endLineNumber;
		}
		if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) this.applyHiddenRanges(newHiddenAreas);
	}
	applyHiddenRanges(newHiddenAreas) {
		this._hiddenRanges = newHiddenAreas;
		this._hasLineChanges = false;
		this._updateEventEmitter.fire(newHiddenAreas);
	}
	hasRanges() {
		return this._hiddenRanges.length > 0;
	}
	isHidden(line) {
		return findRange(this._hiddenRanges, line) !== null;
	}
	adjustSelections(selections) {
		let hasChanges = false;
		const editorModel = this._foldingModel.textModel;
		let lastRange = null;
		const adjustLine = (line) => {
			if (!lastRange || !isInside(line, lastRange)) lastRange = findRange(this._hiddenRanges, line);
			if (lastRange) return lastRange.startLineNumber - 1;
			return null;
		};
		for (let i = 0, len = selections.length; i < len; i++) {
			let selection = selections[i];
			const adjustedStartLine = adjustLine(selection.startLineNumber);
			if (adjustedStartLine) {
				selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
				hasChanges = true;
			}
			const adjustedEndLine = adjustLine(selection.endLineNumber);
			if (adjustedEndLine) {
				selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
				hasChanges = true;
			}
			selections[i] = selection;
		}
		return hasChanges;
	}
	dispose() {
		if (this.hiddenRanges.length > 0) {
			this._hiddenRanges = [];
			this._updateEventEmitter.fire(this._hiddenRanges);
		}
		if (this._foldingModelListener) {
			this._foldingModelListener.dispose();
			this._foldingModelListener = null;
		}
	}
};
function isInside(line, range) {
	return line >= range.startLineNumber && line <= range.endLineNumber;
}
function findRange(ranges, line) {
	const i = findFirstInSorted(ranges, (r) => line < r.startLineNumber) - 1;
	if (i >= 0 && ranges[i].endLineNumber >= line) return ranges[i];
	return null;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js
var MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5e3;
const ID_INDENT_PROVIDER = "indent";
var IndentRangeProvider = class {
	constructor(editorModel, languageConfigurationService, maxFoldingRegions) {
		this.editorModel = editorModel;
		this.languageConfigurationService = languageConfigurationService;
		this.maxFoldingRegions = maxFoldingRegions;
		this.id = ID_INDENT_PROVIDER;
	}
	dispose() {}
	compute(cancelationToken, notifyTooManyRegions) {
		const foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;
		const offSide = foldingRules && !!foldingRules.offSide;
		const markers = foldingRules && foldingRules.markers;
		return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.maxFoldingRegions, notifyTooManyRegions));
	}
};
var RangesCollector$1 = class {
	constructor(foldingRangesLimit, _notifyTooManyRegions) {
		this._notifyTooManyRegions = _notifyTooManyRegions;
		this._startIndexes = [];
		this._endIndexes = [];
		this._indentOccurrences = [];
		this._length = 0;
		this._foldingRangesLimit = foldingRangesLimit;
	}
	insertFirst(startLineNumber, endLineNumber, indent) {
		if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) return;
		const index = this._length;
		this._startIndexes[index] = startLineNumber;
		this._endIndexes[index] = endLineNumber;
		this._length++;
		if (indent < 1e3) this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
	}
	toIndentRanges(model) {
		var _a$5;
		if (this._length <= this._foldingRangesLimit) {
			const startIndexes = new Uint32Array(this._length);
			const endIndexes = new Uint32Array(this._length);
			for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
				startIndexes[k] = this._startIndexes[i];
				endIndexes[k] = this._endIndexes[i];
			}
			return new FoldingRegions(startIndexes, endIndexes);
		} else {
			(_a$5 = this._notifyTooManyRegions) === null || _a$5 === void 0 || _a$5.call(this, this._foldingRangesLimit);
			let entries = 0;
			let maxIndent = this._indentOccurrences.length;
			for (let i = 0; i < this._indentOccurrences.length; i++) {
				const n = this._indentOccurrences[i];
				if (n) {
					if (n + entries > this._foldingRangesLimit) {
						maxIndent = i;
						break;
					}
					entries += n;
				}
			}
			const tabSize = model.getOptions().tabSize;
			const startIndexes = new Uint32Array(this._foldingRangesLimit);
			const endIndexes = new Uint32Array(this._foldingRangesLimit);
			for (let i = this._length - 1, k = 0; i >= 0; i--) {
				const startIndex = this._startIndexes[i];
				const indent = computeIndentLevel(model.getLineContent(startIndex), tabSize);
				if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {
					startIndexes[k] = startIndex;
					endIndexes[k] = this._endIndexes[i];
					k++;
				}
			}
			return new FoldingRegions(startIndexes, endIndexes);
		}
	}
};
function computeRanges(model, offSide, markers, foldingRangesLimit, notifyTooManyRegions) {
	const tabSize = model.getOptions().tabSize;
	foldingRangesLimit = foldingRangesLimit !== null && foldingRangesLimit !== void 0 ? foldingRangesLimit : MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT;
	const result = new RangesCollector$1(foldingRangesLimit, notifyTooManyRegions);
	let pattern = void 0;
	if (markers) pattern = /* @__PURE__ */ new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
	const previousRegions = [];
	const line = model.getLineCount() + 1;
	previousRegions.push({
		indent: -1,
		endAbove: line,
		line
	});
	for (let line$1 = model.getLineCount(); line$1 > 0; line$1--) {
		const lineContent = model.getLineContent(line$1);
		const indent = computeIndentLevel(lineContent, tabSize);
		let previous = previousRegions[previousRegions.length - 1];
		if (indent === -1) {
			if (offSide) previous.endAbove = line$1;
			continue;
		}
		let m;
		if (pattern && (m = lineContent.match(pattern))) if (m[1]) {
			let i = previousRegions.length - 1;
			while (i > 0 && previousRegions[i].indent !== -2) i--;
			if (i > 0) {
				previousRegions.length = i + 1;
				previous = previousRegions[i];
				result.insertFirst(line$1, previous.line, indent);
				previous.line = line$1;
				previous.indent = indent;
				previous.endAbove = line$1;
				continue;
			}
		} else {
			previousRegions.push({
				indent: -2,
				endAbove: line$1,
				line: line$1
			});
			continue;
		}
		if (previous.indent > indent) {
			do {
				previousRegions.pop();
				previous = previousRegions[previousRegions.length - 1];
			} while (previous.indent > indent);
			const endLineNumber = previous.endAbove - 1;
			if (endLineNumber - line$1 >= 1) result.insertFirst(line$1, endLineNumber, indent);
		}
		if (previous.indent === indent) previous.endAbove = line$1;
		else previousRegions.push({
			indent,
			endAbove: line$1,
			line: line$1
		});
	}
	return result.toIndentRanges(model);
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingDecorations.js
const foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown, localize("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin."));
const foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight, localize("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin."));
const foldingManualCollapsedIcon = registerIcon("folding-manual-collapsed", foldingCollapsedIcon, localize("foldingManualCollapedIcon", "Icon for manually collapsed ranges in the editor glyph margin."));
const foldingManualExpandedIcon = registerIcon("folding-manual-expanded", foldingExpandedIcon, localize("foldingManualExpandedIcon", "Icon for manually expanded ranges in the editor glyph margin."));
var FoldingDecorationProvider = class FoldingDecorationProvider {
	constructor(editor$1) {
		this.editor = editor$1;
		this.showFoldingControls = "mouseover";
		this.showFoldingHighlights = true;
	}
	getDecorationOption(isCollapsed, isHidden, isManual) {
		if (isHidden || this.showFoldingControls === "never") return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
		if (isCollapsed) return isManual ? this.showFoldingHighlights ? FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
		else if (this.showFoldingControls === "mouseover") return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
		else return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
	}
	changeDecorations(callback) {
		return this.editor.changeDecorations(callback);
	}
	removeDecorations(decorationIds) {
		this.editor.removeDecorations(decorationIds);
	}
};
FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-collapsed-visual-decoration",
	stickiness: 0,
	afterContentClassName: "inline-folded",
	isWholeLine: true,
	firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-collapsed-highlighted-visual-decoration",
	stickiness: 0,
	afterContentClassName: "inline-folded",
	className: "folded-background",
	isWholeLine: true,
	firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-manually-collapsed-visual-decoration",
	stickiness: 0,
	afterContentClassName: "inline-folded",
	isWholeLine: true,
	firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-manually-collapsed-highlighted-visual-decoration",
	stickiness: 0,
	afterContentClassName: "inline-folded",
	className: "folded-background",
	isWholeLine: true,
	firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-expanded-auto-hide-visual-decoration",
	stickiness: 1,
	isWholeLine: true,
	firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-expanded-visual-decoration",
	stickiness: 1,
	isWholeLine: true,
	firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-manually-expanded-visual-decoration",
	stickiness: 0,
	isWholeLine: true,
	firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingManualExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
	description: "folding-manually-expanded-visual-decoration",
	stickiness: 0,
	isWholeLine: true,
	firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualExpandedIcon)
});
FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
	description: "folding-hidden-range-decoration",
	stickiness: 1
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js
var foldingContext = {};
const ID_SYNTAX_PROVIDER = "syntax";
var SyntaxRangeProvider = class {
	constructor(editorModel, providers, handleFoldingRangesChange, limit) {
		this.editorModel = editorModel;
		this.providers = providers;
		this.limit = limit;
		this.id = ID_SYNTAX_PROVIDER;
		for (const provider of providers) if (typeof provider.onDidChange === "function") {
			if (!this.disposables) this.disposables = new DisposableStore();
			this.disposables.add(provider.onDidChange(handleFoldingRangesChange));
		}
	}
	compute(cancellationToken, notifyTooManyRegions) {
		return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
			if (ranges) return sanitizeRanges(ranges, this.limit, notifyTooManyRegions);
			return null;
		});
	}
	dispose() {
		var _a$5;
		(_a$5 = this.disposables) === null || _a$5 === void 0 || _a$5.dispose();
	}
};
function collectSyntaxRanges(providers, model, cancellationToken) {
	let rangeData = null;
	const promises = providers.map((provider, i) => {
		return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
			if (cancellationToken.isCancellationRequested) return;
			if (Array.isArray(ranges)) {
				if (!Array.isArray(rangeData)) rangeData = [];
				const nLines = model.getLineCount();
				for (const r of ranges) if (r.start > 0 && r.end > r.start && r.end <= nLines) rangeData.push({
					start: r.start,
					end: r.end,
					rank: i,
					kind: r.kind
				});
			}
		}, onUnexpectedExternalError);
	});
	return Promise.all(promises).then((_) => {
		return rangeData;
	});
}
var RangesCollector = class {
	constructor(foldingRangesLimit, _notifyTooManyRegions) {
		this._notifyTooManyRegions = _notifyTooManyRegions;
		this._startIndexes = [];
		this._endIndexes = [];
		this._nestingLevels = [];
		this._nestingLevelCounts = [];
		this._types = [];
		this._length = 0;
		this._foldingRangesLimit = foldingRangesLimit;
	}
	add(startLineNumber, endLineNumber, type, nestingLevel) {
		if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) return;
		const index = this._length;
		this._startIndexes[index] = startLineNumber;
		this._endIndexes[index] = endLineNumber;
		this._nestingLevels[index] = nestingLevel;
		this._types[index] = type;
		this._length++;
		if (nestingLevel < 30) this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
	}
	toIndentRanges() {
		var _a$5;
		if (this._length <= this._foldingRangesLimit) {
			const startIndexes = new Uint32Array(this._length);
			const endIndexes = new Uint32Array(this._length);
			for (let i = 0; i < this._length; i++) {
				startIndexes[i] = this._startIndexes[i];
				endIndexes[i] = this._endIndexes[i];
			}
			return new FoldingRegions(startIndexes, endIndexes, this._types);
		} else {
			(_a$5 = this._notifyTooManyRegions) === null || _a$5 === void 0 || _a$5.call(this, this._foldingRangesLimit);
			let entries = 0;
			let maxLevel = this._nestingLevelCounts.length;
			for (let i = 0; i < this._nestingLevelCounts.length; i++) {
				const n = this._nestingLevelCounts[i];
				if (n) {
					if (n + entries > this._foldingRangesLimit) {
						maxLevel = i;
						break;
					}
					entries += n;
				}
			}
			const startIndexes = new Uint32Array(this._foldingRangesLimit);
			const endIndexes = new Uint32Array(this._foldingRangesLimit);
			const types = [];
			for (let i = 0, k = 0; i < this._length; i++) {
				const level = this._nestingLevels[i];
				if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {
					startIndexes[k] = this._startIndexes[i];
					endIndexes[k] = this._endIndexes[i];
					types[k] = this._types[i];
					k++;
				}
			}
			return new FoldingRegions(startIndexes, endIndexes, types);
		}
	}
};
function sanitizeRanges(rangeData, limit, notifyTooManyRegions) {
	const sorted = rangeData.sort((d1, d2) => {
		let diff = d1.start - d2.start;
		if (diff === 0) diff = d1.rank - d2.rank;
		return diff;
	});
	const collector = new RangesCollector(limit, notifyTooManyRegions);
	let top = void 0;
	const previous = [];
	for (const entry of sorted) if (!top) {
		top = entry;
		collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
	} else if (entry.start > top.start) if (entry.end <= top.end) {
		previous.push(top);
		top = entry;
		collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
	} else {
		if (entry.start > top.end) {
			do
				top = previous.pop();
			while (top && entry.start > top.end);
			if (top) previous.push(top);
			top = entry;
		}
		collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
	}
	return collector.toIndentRanges();
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
var __decorate$47 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$47 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
var FoldingController = class FoldingController$1 extends Disposable {
	constructor(editor$1, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {
		super();
		this.contextKeyService = contextKeyService;
		this.languageConfigurationService = languageConfigurationService;
		this.languageFeaturesService = languageFeaturesService;
		this._tooManyRegionsNotified = false;
		this.localToDispose = this._register(new DisposableStore());
		this.editor = editor$1;
		const options = this.editor.getOptions();
		this._isEnabled = options.get(39);
		this._useFoldingProviders = options.get(40) !== "indentation";
		this._unfoldOnClickAfterEndOfLine = options.get(44);
		this._restoringViewState = false;
		this._currentModelHasFoldedImports = false;
		this._foldingImportsByDefault = options.get(42);
		this._maxFoldingRegions = options.get(43);
		this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, "Folding", { min: 200 });
		this.foldingModel = null;
		this.hiddenRangeModel = null;
		this.rangeProvider = null;
		this.foldingRegionPromise = null;
		this.foldingModelPromise = null;
		this.updateScheduler = null;
		this.cursorChangedScheduler = null;
		this.mouseDownInfo = null;
		this.foldingDecorationProvider = new FoldingDecorationProvider(editor$1);
		this.foldingDecorationProvider.showFoldingControls = options.get(101);
		this.foldingDecorationProvider.showFoldingHighlights = options.get(41);
		this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
		this.foldingEnabled.set(this._isEnabled);
		this._notifyTooManyRegions = (maxFoldingRegions) => {
			if (!this._tooManyRegionsNotified) {
				notificationService.notify({
					severity: severity_default.Warning,
					sticky: true,
					message: localize("maximum fold ranges", "The number of foldable regions is limited to a maximum of {0}. Increase configuration option ['Folding Maximum Regions'](command:workbench.action.openSettings?[\"editor.foldingMaximumRegions\"]) to enable more.", maxFoldingRegions)
				});
				this._tooManyRegionsNotified = true;
			}
		};
		this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
		this._register(this.editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(39)) {
				this._isEnabled = this.editor.getOptions().get(39);
				this.foldingEnabled.set(this._isEnabled);
				this.onModelChanged();
			}
			if (e.hasChanged(43)) {
				this._maxFoldingRegions = this.editor.getOptions().get(43);
				this._tooManyRegionsNotified = false;
				this.onModelChanged();
			}
			if (e.hasChanged(101) || e.hasChanged(41)) {
				const options$1 = this.editor.getOptions();
				this.foldingDecorationProvider.showFoldingControls = options$1.get(101);
				this.foldingDecorationProvider.showFoldingHighlights = options$1.get(41);
				this.triggerFoldingModelChanged();
			}
			if (e.hasChanged(40)) {
				this._useFoldingProviders = this.editor.getOptions().get(40) !== "indentation";
				this.onFoldingStrategyChanged();
			}
			if (e.hasChanged(44)) this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(44);
			if (e.hasChanged(42)) this._foldingImportsByDefault = this.editor.getOptions().get(42);
		}));
		this.onModelChanged();
	}
	static get(editor$1) {
		return editor$1.getContribution(FoldingController$1.ID);
	}
	/**
	* Store view state.
	*/
	saveViewState() {
		const model = this.editor.getModel();
		if (!model || !this._isEnabled || model.isTooLargeForTokenization()) return {};
		if (this.foldingModel) {
			const collapsedRegions = this.foldingModel.getMemento();
			const provider = this.rangeProvider ? this.rangeProvider.id : void 0;
			return {
				collapsedRegions,
				lineCount: model.getLineCount(),
				provider,
				foldedImports: this._currentModelHasFoldedImports
			};
		}
	}
	/**
	* Restore view state.
	*/
	restoreViewState(state) {
		const model = this.editor.getModel();
		if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) return;
		if (!state || state.lineCount !== model.getLineCount()) return;
		this._currentModelHasFoldedImports = !!state.foldedImports;
		if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {
			this._restoringViewState = true;
			try {
				this.foldingModel.applyMemento(state.collapsedRegions);
			} finally {
				this._restoringViewState = false;
			}
		}
	}
	onModelChanged() {
		this.localToDispose.clear();
		const model = this.editor.getModel();
		if (!this._isEnabled || !model || model.isTooLargeForTokenization()) return;
		this._currentModelHasFoldedImports = false;
		this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
		this.localToDispose.add(this.foldingModel);
		this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
		this.localToDispose.add(this.hiddenRangeModel);
		this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
		this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));
		this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
		this.localToDispose.add(this.cursorChangedScheduler);
		this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));
		this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
		this.localToDispose.add(this.editor.onDidChangeModelContent((e) => this.onDidChangeModelContent(e)));
		this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
		this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
		this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
		this.localToDispose.add({ dispose: () => {
			if (this.foldingRegionPromise) {
				this.foldingRegionPromise.cancel();
				this.foldingRegionPromise = null;
			}
			if (this.updateScheduler) this.updateScheduler.cancel();
			this.updateScheduler = null;
			this.foldingModel = null;
			this.foldingModelPromise = null;
			this.hiddenRangeModel = null;
			this.cursorChangedScheduler = null;
			if (this.rangeProvider) this.rangeProvider.dispose();
			this.rangeProvider = null;
		} });
		this.triggerFoldingModelChanged();
	}
	onFoldingStrategyChanged() {
		if (this.rangeProvider) this.rangeProvider.dispose();
		this.rangeProvider = null;
		this.triggerFoldingModelChanged();
	}
	getRangeProvider(editorModel) {
		if (this.rangeProvider) return this.rangeProvider;
		this.rangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._maxFoldingRegions);
		if (this._useFoldingProviders && this.foldingModel) {
			const foldingProviders = this.languageFeaturesService.foldingRangeProvider.ordered(this.foldingModel.textModel);
			if (foldingProviders.length > 0) this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);
		}
		return this.rangeProvider;
	}
	getFoldingModel() {
		return this.foldingModelPromise;
	}
	onDidChangeModelContent(e) {
		var _a$5;
		(_a$5 = this.hiddenRangeModel) === null || _a$5 === void 0 || _a$5.notifyChangeModelContent(e);
		this.triggerFoldingModelChanged();
	}
	triggerFoldingModelChanged() {
		if (this.updateScheduler) {
			if (this.foldingRegionPromise) {
				this.foldingRegionPromise.cancel();
				this.foldingRegionPromise = null;
			}
			this.foldingModelPromise = this.updateScheduler.trigger(() => {
				const foldingModel = this.foldingModel;
				if (!foldingModel) return null;
				const sw = new StopWatch(true);
				const provider = this.getRangeProvider(foldingModel.textModel);
				const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => provider.compute(token, this._notifyTooManyRegions));
				return foldingRegionPromise.then((foldingRanges) => {
					if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
						let scrollState;
						if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
							const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);
							if (hasChanges) {
								scrollState = StableEditorScrollState.capture(this.editor);
								this._currentModelHasFoldedImports = hasChanges;
							}
						}
						const selections = this.editor.getSelections();
						const selectionLineNumbers = selections ? selections.map((s) => s.startLineNumber) : [];
						foldingModel.update(foldingRanges, selectionLineNumbers);
						scrollState === null || scrollState === void 0 || scrollState.restore(this.editor);
						const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());
						if (this.updateScheduler) this.updateScheduler.defaultDelay = newValue;
					}
					return foldingModel;
				});
			}).then(void 0, (err) => {
				onUnexpectedError(err);
				return null;
			});
		}
	}
	onHiddenRangesChanges(hiddenRanges) {
		if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {
			const selections = this.editor.getSelections();
			if (selections) {
				if (this.hiddenRangeModel.adjustSelections(selections)) this.editor.setSelections(selections);
			}
		}
		this.editor.setHiddenAreas(hiddenRanges);
	}
	onCursorPositionChanged() {
		if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) this.cursorChangedScheduler.schedule();
	}
	revealCursor() {
		const foldingModel = this.getFoldingModel();
		if (!foldingModel) return;
		foldingModel.then((foldingModel$1) => {
			if (foldingModel$1) {
				const selections = this.editor.getSelections();
				if (selections && selections.length > 0) {
					const toToggle = [];
					for (const selection of selections) {
						const lineNumber = selection.selectionStartLineNumber;
						if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) toToggle.push(...foldingModel$1.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
					}
					if (toToggle.length) {
						foldingModel$1.toggleCollapseState(toToggle);
						this.reveal(selections[0].getPosition());
					}
				}
			}
		}).then(void 0, onUnexpectedError);
	}
	onEditorMouseDown(e) {
		this.mouseDownInfo = null;
		if (!this.hiddenRangeModel || !e.target || !e.target.range) return;
		if (!e.event.leftButton && !e.event.middleButton) return;
		const range = e.target.range;
		let iconClicked = false;
		switch (e.target.type) {
			case 4: {
				const data = e.target.detail;
				const offsetLeftInGutter = e.target.element.offsetLeft;
				if (data.offsetX - offsetLeftInGutter < 5) return;
				iconClicked = true;
				break;
			}
			case 7:
				if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
					if (!e.target.detail.isAfterLines) break;
				}
				return;
			case 6:
				if (this.hiddenRangeModel.hasRanges()) {
					const model = this.editor.getModel();
					if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) break;
				}
				return;
			default: return;
		}
		this.mouseDownInfo = {
			lineNumber: range.startLineNumber,
			iconClicked
		};
	}
	onEditorMouseUp(e) {
		const foldingModel = this.foldingModel;
		if (!foldingModel || !this.mouseDownInfo || !e.target) return;
		const lineNumber = this.mouseDownInfo.lineNumber;
		const iconClicked = this.mouseDownInfo.iconClicked;
		const range = e.target.range;
		if (!range || range.startLineNumber !== lineNumber) return;
		if (iconClicked) {
			if (e.target.type !== 4) return;
		} else {
			const model = this.editor.getModel();
			if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) return;
		}
		const region = foldingModel.getRegionAtLine(lineNumber);
		if (region && region.startLineNumber === lineNumber) {
			const isCollapsed = region.isCollapsed;
			if (iconClicked || isCollapsed) {
				const surrounding = e.event.altKey;
				let toToggle = [];
				if (surrounding) {
					const filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);
					const toMaybeToggle = foldingModel.getRegionsInside(null, filter);
					for (const r of toMaybeToggle) if (r.isCollapsed) toToggle.push(r);
					if (toToggle.length === 0) toToggle = toMaybeToggle;
				} else {
					const recursive = e.event.middleButton || e.event.shiftKey;
					if (recursive) {
						for (const r of foldingModel.getRegionsInside(region)) if (r.isCollapsed === isCollapsed) toToggle.push(r);
					}
					if (isCollapsed || !recursive || toToggle.length === 0) toToggle.push(region);
				}
				foldingModel.toggleCollapseState(toToggle);
				this.reveal({
					lineNumber,
					column: 1
				});
			}
		}
	}
	reveal(position) {
		this.editor.revealPositionInCenterIfOutsideViewport(position, 0);
	}
};
FoldingController.ID = "editor.contrib.folding";
FoldingController = __decorate$47([
	__param$47(1, IContextKeyService),
	__param$47(2, ILanguageConfigurationService),
	__param$47(3, INotificationService),
	__param$47(4, ILanguageFeatureDebounceService),
	__param$47(5, ILanguageFeaturesService)
], FoldingController);
var FoldingAction = class extends EditorAction {
	runEditorCommand(accessor, editor$1, args) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		const foldingController = FoldingController.get(editor$1);
		if (!foldingController) return;
		const foldingModelPromise = foldingController.getFoldingModel();
		if (foldingModelPromise) {
			this.reportTelemetry(accessor, editor$1);
			return foldingModelPromise.then((foldingModel) => {
				if (foldingModel) {
					this.invoke(foldingController, foldingModel, editor$1, args, languageConfigurationService);
					const selection = editor$1.getSelection();
					if (selection) foldingController.reveal(selection.getStartPosition());
				}
			});
		}
	}
	getSelectedLines(editor$1) {
		const selections = editor$1.getSelections();
		return selections ? selections.map((s) => s.startLineNumber) : [];
	}
	getLineNumbers(args, editor$1) {
		if (args && args.selectionLines) return args.selectionLines.map((l) => l + 1);
		return this.getSelectedLines(editor$1);
	}
	run(_accessor, _editor) {}
};
function foldingArgumentsConstraint(args) {
	if (!isUndefined(args)) {
		if (!isObject(args)) return false;
		const foldingArgs = args;
		if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) return false;
		if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) return false;
		if (!isUndefined(foldingArgs.selectionLines) && (!isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) return false;
	}
	return true;
}
var UnfoldAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.unfold",
			label: localize("unfoldAction.label", "Unfold"),
			alias: "Unfold",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3161,
				mac: { primary: 2649 },
				weight: 100
			},
			description: {
				description: "Unfold the content in the editor",
				args: [{
					name: "Unfold editor argument",
					description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
					constraint: foldingArgumentsConstraint,
					schema: {
						"type": "object",
						"properties": {
							"levels": {
								"type": "number",
								"default": 1
							},
							"direction": {
								"type": "string",
								"enum": ["up", "down"],
								"default": "down"
							},
							"selectionLines": {
								"type": "array",
								"items": { "type": "number" }
							}
						}
					}
				}]
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1, args) {
		const levels = args && args.levels || 1;
		const lineNumbers = this.getLineNumbers(args, editor$1);
		if (args && args.direction === "up") setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
		else setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
	}
};
var UnFoldRecursivelyAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.unfoldRecursively",
			label: localize("unFoldRecursivelyAction.label", "Unfold Recursively"),
			alias: "Unfold Recursively",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2137),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1, _args) {
		setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor$1));
	}
};
var FoldAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.fold",
			label: localize("foldAction.label", "Fold"),
			alias: "Fold",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3159,
				mac: { primary: 2647 },
				weight: 100
			},
			description: {
				description: "Fold the content in the editor",
				args: [{
					name: "Fold editor argument",
					description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
					constraint: foldingArgumentsConstraint,
					schema: {
						"type": "object",
						"properties": {
							"levels": { "type": "number" },
							"direction": {
								"type": "string",
								"enum": ["up", "down"]
							},
							"selectionLines": {
								"type": "array",
								"items": { "type": "number" }
							}
						}
					}
				}]
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1, args) {
		const lineNumbers = this.getLineNumbers(args, editor$1);
		const levels = args && args.levels;
		const direction = args && args.direction;
		if (typeof levels !== "number" && typeof direction !== "string") setCollapseStateUp(foldingModel, true, lineNumbers);
		else if (direction === "up") setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
		else setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
	}
};
var ToggleFoldAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.toggleFold",
			label: localize("toggleFoldAction.label", "Toggle Fold"),
			alias: "Toggle Fold",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2090),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		toggleCollapseState(foldingModel, 1, this.getSelectedLines(editor$1));
	}
};
var FoldRecursivelyAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.foldRecursively",
			label: localize("foldRecursivelyAction.label", "Fold Recursively"),
			alias: "Fold Recursively",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2135),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		const selectedLines = this.getSelectedLines(editor$1);
		setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
	}
};
var FoldAllBlockCommentsAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.foldAllBlockComments",
			label: localize("foldAllBlockComments.label", "Fold All Block Comments"),
			alias: "Fold All Block Comments",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2133),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1, args, languageConfigurationService) {
		if (foldingModel.regions.hasTypes()) setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
		else {
			const editorModel = editor$1.getModel();
			if (!editorModel) return;
			const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;
			if (comments && comments.blockCommentStartToken) setCollapseStateForMatchingLines(foldingModel, /* @__PURE__ */ new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken)), true);
		}
	}
};
var FoldAllRegionsAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.foldAllMarkerRegions",
			label: localize("foldAllMarkerRegions.label", "Fold All Regions"),
			alias: "Fold All Regions",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2077),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1, args, languageConfigurationService) {
		if (foldingModel.regions.hasTypes()) setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
		else {
			const editorModel = editor$1.getModel();
			if (!editorModel) return;
			const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
			if (foldingRules && foldingRules.markers && foldingRules.markers.start) setCollapseStateForMatchingLines(foldingModel, new RegExp(foldingRules.markers.start), true);
		}
	}
};
var UnfoldAllRegionsAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.unfoldAllMarkerRegions",
			label: localize("unfoldAllMarkerRegions.label", "Unfold All Regions"),
			alias: "Unfold All Regions",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2078),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1, args, languageConfigurationService) {
		if (foldingModel.regions.hasTypes()) setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
		else {
			const editorModel = editor$1.getModel();
			if (!editorModel) return;
			const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
			if (foldingRules && foldingRules.markers && foldingRules.markers.start) setCollapseStateForMatchingLines(foldingModel, new RegExp(foldingRules.markers.start), false);
		}
	}
};
var FoldAllRegionsExceptAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.foldAllExcept",
			label: localize("foldAllExcept.label", "Fold All Regions Except Selected"),
			alias: "Fold All Regions Except Selected",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2131),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		setCollapseStateForRest(foldingModel, true, this.getSelectedLines(editor$1));
	}
};
var UnfoldAllRegionsExceptAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.unfoldAllExcept",
			label: localize("unfoldAllExcept.label", "Unfold All Regions Except Selected"),
			alias: "Unfold All Regions Except Selected",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2129),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		setCollapseStateForRest(foldingModel, false, this.getSelectedLines(editor$1));
	}
};
var FoldAllAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.foldAll",
			label: localize("foldAllAction.label", "Fold All"),
			alias: "Fold All",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2069),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, _editor) {
		setCollapseStateLevelsDown(foldingModel, true);
	}
};
var UnfoldAllAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.unfoldAll",
			label: localize("unfoldAllAction.label", "Unfold All"),
			alias: "Unfold All",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2088),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, _editor) {
		setCollapseStateLevelsDown(foldingModel, false);
	}
};
var FoldLevelAction = class FoldLevelAction extends FoldingAction {
	getFoldingLevel() {
		return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
	}
	invoke(_foldingController, foldingModel, editor$1) {
		setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor$1));
	}
};
FoldLevelAction.ID_PREFIX = "editor.foldLevel";
FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;
/** Action to go to the parent fold of current line */
var GotoParentFoldAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.gotoParentFold",
			label: localize("gotoParentFold.label", "Go to Parent Fold"),
			alias: "Go to Parent Fold",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		const selectedLines = this.getSelectedLines(editor$1);
		if (selectedLines.length > 0) {
			const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);
			if (startLineNumber !== null) editor$1.setSelection({
				startLineNumber,
				startColumn: 1,
				endLineNumber: startLineNumber,
				endColumn: 1
			});
		}
	}
};
/** Action to go to the previous fold of current line */
var GotoPreviousFoldAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.gotoPreviousFold",
			label: localize("gotoPreviousFold.label", "Go to Previous Folding Range"),
			alias: "Go to Previous Folding Range",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		const selectedLines = this.getSelectedLines(editor$1);
		if (selectedLines.length > 0) {
			const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);
			if (startLineNumber !== null) editor$1.setSelection({
				startLineNumber,
				startColumn: 1,
				endLineNumber: startLineNumber,
				endColumn: 1
			});
		}
	}
};
/** Action to go to the next fold of current line */
var GotoNextFoldAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.gotoNextFold",
			label: localize("gotoNextFold.label", "Go to Next Folding Range"),
			alias: "Go to Next Folding Range",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		const selectedLines = this.getSelectedLines(editor$1);
		if (selectedLines.length > 0) {
			const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);
			if (startLineNumber !== null) editor$1.setSelection({
				startLineNumber,
				startColumn: 1,
				endLineNumber: startLineNumber,
				endColumn: 1
			});
		}
	}
};
var FoldRangeFromSelectionAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.createFoldingRangeFromSelection",
			label: localize("createManualFoldRange.label", "Create Manual Folding Range from Selection"),
			alias: "Create Folding Range from Selection",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2130),
				weight: 100
			}
		});
	}
	invoke(_foldingController, foldingModel, editor$1) {
		var _a$5;
		const collapseRanges = [];
		const selections = editor$1.getSelections();
		if (selections) {
			for (const selection of selections) {
				let endLineNumber = selection.endLineNumber;
				if (selection.endColumn === 1) --endLineNumber;
				if (endLineNumber > selection.startLineNumber) {
					collapseRanges.push({
						startLineNumber: selection.startLineNumber,
						endLineNumber,
						type: void 0,
						isCollapsed: true,
						source: 1
					});
					editor$1.setSelection({
						startLineNumber: selection.startLineNumber,
						startColumn: 1,
						endLineNumber: selection.startLineNumber,
						endColumn: 1
					});
				}
			}
			if (collapseRanges.length > 0) {
				collapseRanges.sort((a, b) => {
					return a.startLineNumber - b.startLineNumber;
				});
				const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, (_a$5 = editor$1.getModel()) === null || _a$5 === void 0 ? void 0 : _a$5.getLineCount());
				foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));
			}
		}
	}
};
var RemoveFoldRangeFromSelectionAction = class extends FoldingAction {
	constructor() {
		super({
			id: "editor.removeManualFoldingRanges",
			label: localize("removeManualFoldingRanges.label", "Remove Manual Folding Ranges"),
			alias: "Remove Manual Folding Ranges",
			precondition: CONTEXT_FOLDING_ENABLED,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2132),
				weight: 100
			}
		});
	}
	invoke(foldingController, foldingModel, editor$1) {
		const selections = editor$1.getSelections();
		if (selections) {
			const ranges = [];
			for (const selection of selections) {
				const { startLineNumber, endLineNumber } = selection;
				ranges.push(endLineNumber >= startLineNumber ? {
					startLineNumber,
					endLineNumber
				} : {
					endLineNumber,
					startLineNumber
				});
			}
			foldingModel.removeManualRanges(ranges);
			foldingController.triggerFoldingModelChanged();
		}
	}
};
registerEditorContribution(FoldingController.ID, FoldingController);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
registerEditorAction(FoldAllRegionsExceptAction);
registerEditorAction(UnfoldAllRegionsExceptAction);
registerEditorAction(ToggleFoldAction);
registerEditorAction(GotoParentFoldAction);
registerEditorAction(GotoPreviousFoldAction);
registerEditorAction(GotoNextFoldAction);
registerEditorAction(FoldRangeFromSelectionAction);
registerEditorAction(RemoveFoldRangeFromSelectionAction);
for (let i = 1; i <= 7; i++) registerInstantiatedEditorAction(new FoldLevelAction({
	id: FoldLevelAction.ID(i),
	label: localize("foldLevelAction.label", "Fold Level {0}", i),
	alias: `Fold Level ${i}`,
	precondition: CONTEXT_FOLDING_ENABLED,
	kbOpts: {
		kbExpr: EditorContextKeys.editorTextFocus,
		primary: KeyChord(2089, 2048 | 21 + i),
		weight: 100
	}
}));
const foldBackgroundBackground = registerColor("editor.foldBackground", {
	light: transparent(editorSelectionBackground, .3),
	dark: transparent(editorSelectionBackground, .3),
	hcDark: null,
	hcLight: null
}, localize("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
const editorFoldForeground = registerColor("editorGutter.foldingControlForeground", {
	dark: iconForeground,
	light: iconForeground,
	hcDark: iconForeground,
	hcLight: iconForeground
}, localize("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
registerThemingParticipant((theme, collector) => {
	const foldBackground = theme.getColor(foldBackgroundBackground);
	if (foldBackground) collector.addRule(`.monaco-editor .folded-background { background-color: ${foldBackground}; }`);
	const editorFoldColor = theme.getColor(editorFoldForeground);
	if (editorFoldColor) collector.addRule(`
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingExpandedIcon)},
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingCollapsedIcon)},
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingManualExpandedIcon)},
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingManualCollapsedIcon)} {
			color: ${editorFoldColor} !important;
		}
		`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/browser/fontZoom.js
var EditorFontZoomIn = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.fontZoomIn",
			label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
			alias: "Editor Font Zoom In",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
	}
};
var EditorFontZoomOut = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.fontZoomOut",
			label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
			alias: "Editor Font Zoom Out",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
	}
};
var EditorFontZoomReset = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.fontZoomReset",
			label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
			alias: "Editor Font Zoom Reset",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		EditorZoom.setZoomLevel(0);
	}
};
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/formatActions.js
var __decorate$46 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$46 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$29 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var FormatOnType = class FormatOnType$1 {
	constructor(_editor, _languageFeaturesService, _workerService) {
		this._editor = _editor;
		this._languageFeaturesService = _languageFeaturesService;
		this._workerService = _workerService;
		this._disposables = new DisposableStore();
		this._sessionDisposables = new DisposableStore();
		this._disposables.add(_languageFeaturesService.onTypeFormattingEditProvider.onDidChange(this._update, this));
		this._disposables.add(_editor.onDidChangeModel(() => this._update()));
		this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
		this._disposables.add(_editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(51)) this._update();
		}));
	}
	dispose() {
		this._disposables.dispose();
		this._sessionDisposables.dispose();
	}
	_update() {
		this._sessionDisposables.clear();
		if (!this._editor.getOption(51)) return;
		if (!this._editor.hasModel()) return;
		const model = this._editor.getModel();
		const [support] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
		if (!support || !support.autoFormatTriggerCharacters) return;
		const triggerChars = new CharacterSet();
		for (const ch of support.autoFormatTriggerCharacters) triggerChars.add(ch.charCodeAt(0));
		this._sessionDisposables.add(this._editor.onDidType((text) => {
			const lastCharCode = text.charCodeAt(text.length - 1);
			if (triggerChars.has(lastCharCode)) this._trigger(String.fromCharCode(lastCharCode));
		}));
	}
	_trigger(ch) {
		if (!this._editor.hasModel()) return;
		if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) return;
		const model = this._editor.getModel();
		const position = this._editor.getPosition();
		const cts = new CancellationTokenSource$1();
		const unbind = this._editor.onDidChangeModelContent((e) => {
			if (e.isFlush) {
				cts.cancel();
				unbind.dispose();
				return;
			}
			for (let i = 0, len = e.changes.length; i < len; i++) if (e.changes[i].range.endLineNumber <= position.lineNumber) {
				cts.cancel();
				unbind.dispose();
				return;
			}
		});
		getOnTypeFormattingEdits(this._workerService, this._languageFeaturesService, model, position, ch, model.getFormattingOptions(), cts.token).then((edits) => {
			if (cts.token.isCancellationRequested) return;
			if (isNonEmptyArray(edits)) {
				FormattingEdit.execute(this._editor, edits, true);
				alertFormattingEdits(edits);
			}
		}).finally(() => {
			unbind.dispose();
		});
	}
};
FormatOnType.ID = "editor.contrib.autoFormat";
FormatOnType = __decorate$46([__param$46(1, ILanguageFeaturesService), __param$46(2, IEditorWorkerService)], FormatOnType);
var FormatOnPaste = class FormatOnPaste$1 {
	constructor(editor$1, _languageFeaturesService, _instantiationService) {
		this.editor = editor$1;
		this._languageFeaturesService = _languageFeaturesService;
		this._instantiationService = _instantiationService;
		this._callOnDispose = new DisposableStore();
		this._callOnModel = new DisposableStore();
		this._callOnDispose.add(editor$1.onDidChangeConfiguration(() => this._update()));
		this._callOnDispose.add(editor$1.onDidChangeModel(() => this._update()));
		this._callOnDispose.add(editor$1.onDidChangeModelLanguage(() => this._update()));
		this._callOnDispose.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._update, this));
	}
	dispose() {
		this._callOnDispose.dispose();
		this._callOnModel.dispose();
	}
	_update() {
		this._callOnModel.clear();
		if (!this.editor.getOption(50)) return;
		if (!this.editor.hasModel()) return;
		if (!this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel())) return;
		this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
	}
	_trigger(range) {
		if (!this.editor.hasModel()) return;
		if (this.editor.getSelections().length > 1) return;
		this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
	}
};
FormatOnPaste.ID = "editor.contrib.formatOnPaste";
FormatOnPaste = __decorate$46([__param$46(1, ILanguageFeaturesService), __param$46(2, IInstantiationService)], FormatOnPaste);
var FormatDocumentAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.formatDocument",
			label: localize("formatDocument.label", "Format Document"),
			alias: "Format Document",
			precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1572,
				linux: { primary: 3111 },
				weight: 100
			},
			contextMenuOpts: {
				group: "1_modification",
				order: 1.3
			}
		});
	}
	run(accessor, editor$1) {
		return __awaiter$29(this, void 0, void 0, function* () {
			if (editor$1.hasModel()) {
				const instaService = accessor.get(IInstantiationService);
				yield accessor.get(IEditorProgressService).showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor$1, 1, Progress.None, CancellationToken.None), 250);
			}
		});
	}
};
var FormatSelectionAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.formatSelection",
			label: localize("formatSelection.label", "Format Selection"),
			alias: "Format Selection",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2084),
				weight: 100
			},
			contextMenuOpts: {
				when: EditorContextKeys.hasNonEmptySelection,
				group: "1_modification",
				order: 1.31
			}
		});
	}
	run(accessor, editor$1) {
		return __awaiter$29(this, void 0, void 0, function* () {
			if (!editor$1.hasModel()) return;
			const instaService = accessor.get(IInstantiationService);
			const model = editor$1.getModel();
			const ranges = editor$1.getSelections().map((range) => {
				return range.isEmpty() ? new Range$1(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
			});
			yield accessor.get(IEditorProgressService).showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor$1, ranges, 1, Progress.None, CancellationToken.None), 250);
		});
	}
};
registerEditorContribution(FormatOnType.ID, FormatOnType);
registerEditorContribution(FormatOnPaste.ID, FormatOnPaste);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter$29(void 0, void 0, void 0, function* () {
	const editor$1 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
	if (!editor$1 || !editor$1.hasModel()) return;
	const commandService = accessor.get(ICommandService);
	if (editor$1.getSelection().isEmpty()) yield commandService.executeCommand("editor.action.formatDocument");
	else yield commandService.executeCommand("editor.action.formatSelection");
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js
var __decorate$45 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$45 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$28 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var TreeElement = class {
	remove() {
		var _a$5;
		(_a$5 = this.parent) === null || _a$5 === void 0 || _a$5.children.delete(this.id);
	}
	static findId(candidate, container) {
		let candidateId;
		if (typeof candidate === "string") candidateId = `${container.id}/${candidate}`;
		else {
			candidateId = `${container.id}/${candidate.name}`;
			if (container.children.get(candidateId) !== void 0) candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
		}
		let id = candidateId;
		for (let i = 0; container.children.get(id) !== void 0; i++) id = `${candidateId}_${i}`;
		return id;
	}
	static empty(element) {
		return element.children.size === 0;
	}
};
var OutlineElement = class extends TreeElement {
	constructor(id, parent, symbol) {
		super();
		this.id = id;
		this.parent = parent;
		this.symbol = symbol;
		this.children = /* @__PURE__ */ new Map();
	}
};
var OutlineGroup = class extends TreeElement {
	constructor(id, parent, label, order) {
		super();
		this.id = id;
		this.parent = parent;
		this.label = label;
		this.order = order;
		this.children = /* @__PURE__ */ new Map();
	}
};
var OutlineModel = class OutlineModel extends TreeElement {
	constructor(uri) {
		super();
		this.uri = uri;
		this.id = "root";
		this.parent = void 0;
		this._groups = /* @__PURE__ */ new Map();
		this.children = /* @__PURE__ */ new Map();
		this.id = "root";
		this.parent = void 0;
	}
	static create(registry, textModel, token) {
		const cts = new CancellationTokenSource$1(token);
		const result = new OutlineModel(textModel.uri);
		const provider = registry.ordered(textModel);
		const promises = provider.map((provider$1, index) => {
			var _a$5;
			const id = TreeElement.findId(`provider_${index}`, result);
			const group = new OutlineGroup(id, result, (_a$5 = provider$1.displayName) !== null && _a$5 !== void 0 ? _a$5 : "Unknown Outline Provider", index);
			return Promise.resolve(provider$1.provideDocumentSymbols(textModel, cts.token)).then((result$1) => {
				for (const info of result$1 || []) OutlineModel._makeOutlineElement(info, group);
				return group;
			}, (err) => {
				onUnexpectedExternalError(err);
				return group;
			}).then((group$1) => {
				if (!TreeElement.empty(group$1)) result._groups.set(id, group$1);
				else group$1.remove();
			});
		});
		const listener = registry.onDidChange(() => {
			if (!equals(registry.ordered(textModel), provider)) cts.cancel();
		});
		return Promise.all(promises).then(() => {
			if (cts.token.isCancellationRequested && !token.isCancellationRequested) return OutlineModel.create(registry, textModel, token);
			else return result._compact();
		}).finally(() => {
			listener.dispose();
		});
	}
	static _makeOutlineElement(info, container) {
		const res = new OutlineElement(TreeElement.findId(info, container), container, info);
		if (info.children) for (const childInfo of info.children) OutlineModel._makeOutlineElement(childInfo, res);
		container.children.set(res.id, res);
	}
	_compact() {
		let count = 0;
		for (const [key, group] of this._groups) if (group.children.size === 0) this._groups.delete(key);
		else count += 1;
		if (count !== 1) this.children = this._groups;
		else {
			const group = Iterable.first(this._groups.values());
			for (const [, child] of group.children) {
				child.parent = this;
				this.children.set(child.id, child);
			}
		}
		return this;
	}
	getTopLevelSymbols() {
		const roots = [];
		for (const child of this.children.values()) if (child instanceof OutlineElement) roots.push(child.symbol);
		else roots.push(...Iterable.map(child.children.values(), (child$1) => child$1.symbol));
		return roots.sort((a, b) => Range$1.compareRangesUsingStarts(a.range, b.range));
	}
	asListOfDocumentSymbols() {
		const roots = this.getTopLevelSymbols();
		const bucket = [];
		OutlineModel._flattenDocumentSymbols(bucket, roots, "");
		return bucket.sort((a, b) => Position$1.compare(Range$1.getStartPosition(a.range), Range$1.getStartPosition(b.range)) || Position$1.compare(Range$1.getEndPosition(b.range), Range$1.getEndPosition(a.range)));
	}
	static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
		for (const entry of entries) {
			bucket.push({
				kind: entry.kind,
				tags: entry.tags,
				name: entry.name,
				detail: entry.detail,
				containerName: entry.containerName || overrideContainerLabel,
				range: entry.range,
				selectionRange: entry.selectionRange,
				children: void 0
			});
			if (entry.children) OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
		}
	}
};
const IOutlineModelService = createDecorator("IOutlineModelService");
var OutlineModelService = class OutlineModelService$1 {
	constructor(_languageFeaturesService, debounces, modelService) {
		this._languageFeaturesService = _languageFeaturesService;
		this._disposables = new DisposableStore();
		this._cache = new LRUCache(10, .7);
		this._debounceInformation = debounces.for(_languageFeaturesService.documentSymbolProvider, "DocumentSymbols", { min: 350 });
		this._disposables.add(modelService.onModelRemoved((textModel) => {
			this._cache.delete(textModel.id);
		}));
	}
	dispose() {
		this._disposables.dispose();
	}
	getOrCreate(textModel, token) {
		return __awaiter$28(this, void 0, void 0, function* () {
			const registry = this._languageFeaturesService.documentSymbolProvider;
			const provider = registry.ordered(textModel);
			let data = this._cache.get(textModel.id);
			if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {
				const source = new CancellationTokenSource$1();
				data = {
					versionId: textModel.getVersionId(),
					provider,
					promiseCnt: 0,
					source,
					promise: OutlineModel.create(registry, textModel, source.token),
					model: void 0
				};
				this._cache.set(textModel.id, data);
				const now = Date.now();
				data.promise.then((outlineModel) => {
					data.model = outlineModel;
					this._debounceInformation.update(textModel, Date.now() - now);
				}).catch((_err) => {
					this._cache.delete(textModel.id);
				});
			}
			if (data.model) return data.model;
			data.promiseCnt += 1;
			const listener = token.onCancellationRequested(() => {
				if (--data.promiseCnt === 0) {
					data.source.cancel();
					this._cache.delete(textModel.id);
				}
			});
			try {
				return yield data.promise;
			} finally {
				listener.dispose();
			}
		});
	}
};
OutlineModelService = __decorate$45([
	__param$45(0, ILanguageFeaturesService),
	__param$45(1, ILanguageFeatureDebounceService),
	__param$45(2, IModelService)
], OutlineModelService);
registerSingleton(IOutlineModelService, OutlineModelService, true);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/documentSymbols.js
var __awaiter$27 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
	return __awaiter$27(this, void 0, void 0, function* () {
		const [resource] = args;
		assertType(URI.isUri(resource));
		const outlineService = accessor.get(IOutlineModelService);
		const reference = yield accessor.get(ITextModelService).createModelReference(resource);
		try {
			return (yield outlineService.getOrCreate(reference.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
		} finally {
			reference.dispose();
		}
	});
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/consts.js
const inlineSuggestCommitId = "editor.action.inlineSuggest.commit";

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/utils.js
function createDisposableRef(object, disposable) {
	return {
		object,
		dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()
	};
}
function applyEdits(text, edits) {
	const transformer = new PositionOffsetTransformer(text);
	const offsetEdits = edits.map((e) => {
		const range = Range$1.lift(e.range);
		return {
			startOffset: transformer.getOffset(range.getStartPosition()),
			endOffset: transformer.getOffset(range.getEndPosition()),
			text: e.text
		};
	});
	offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
	for (const edit of offsetEdits) text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);
	return text;
}
var PositionOffsetTransformer = class {
	constructor(text) {
		this.lineStartOffsetByLineIdx = [];
		this.lineStartOffsetByLineIdx.push(0);
		for (let i = 0; i < text.length; i++) if (text.charAt(i) === "\n") this.lineStartOffsetByLineIdx.push(i + 1);
	}
	getOffset(position) {
		return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
	}
};
var array = [];
function getReadonlyEmptyArray() {
	return array;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.js
var GhostText = class {
	constructor(lineNumber, parts, additionalReservedLineCount = 0) {
		this.lineNumber = lineNumber;
		this.parts = parts;
		this.additionalReservedLineCount = additionalReservedLineCount;
	}
	renderForScreenReader(lineText) {
		if (this.parts.length === 0) return "";
		const lastPart = this.parts[this.parts.length - 1];
		return applyEdits(lineText.substr(0, lastPart.column - 1), this.parts.map((p) => ({
			range: {
				startLineNumber: 1,
				endLineNumber: 1,
				startColumn: p.column,
				endColumn: p.column
			},
			text: p.lines.join("\n")
		}))).substring(this.parts[0].column - 1);
	}
	isEmpty() {
		return this.parts.every((p) => p.lines.length === 0);
	}
};
var GhostTextPart = class {
	constructor(column, lines, preview) {
		this.column = column;
		this.lines = lines;
		this.preview = preview;
	}
};
var GhostTextReplacement = class {
	constructor(lineNumber, columnStart, length, newLines, additionalReservedLineCount = 0) {
		this.lineNumber = lineNumber;
		this.columnStart = columnStart;
		this.length = length;
		this.newLines = newLines;
		this.additionalReservedLineCount = additionalReservedLineCount;
		this.parts = [new GhostTextPart(this.columnStart + this.length, this.newLines, false)];
	}
	renderForScreenReader(_lineText) {
		return this.newLines.join("\n");
	}
};
var BaseGhostTextWidgetModel = class extends Disposable {
	constructor(editor$1) {
		super();
		this.editor = editor$1;
		this._expanded = void 0;
		this.onDidChangeEmitter = new Emitter$1();
		this.onDidChange = this.onDidChangeEmitter.event;
		this._register(editor$1.onDidChangeConfiguration((e) => {
			if (e.hasChanged(108) && this._expanded === void 0) this.onDidChangeEmitter.fire();
		}));
	}
	setExpanded(expanded) {
		this._expanded = true;
		this.onDidChangeEmitter.fire();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionToGhostText.js
function minimizeInlineCompletion(model, inlineCompletion) {
	if (!inlineCompletion) return inlineCompletion;
	const valueToReplace = model.getValueInRange(inlineCompletion.range);
	const commonPrefixLen = commonPrefixLength(valueToReplace, inlineCompletion.insertText);
	const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLen;
	const start = model.getPositionAt(startOffset);
	const remainingValueToReplace = valueToReplace.substr(commonPrefixLen);
	const commonSuffixLen = commonSuffixLength(remainingValueToReplace, inlineCompletion.insertText);
	const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLen));
	return {
		range: Range$1.fromPositions(start, end),
		insertText: inlineCompletion.insertText.substr(commonPrefixLen, inlineCompletion.insertText.length - commonPrefixLen - commonSuffixLen),
		snippetInfo: inlineCompletion.snippetInfo,
		filterText: inlineCompletion.filterText,
		additionalTextEdits: inlineCompletion.additionalTextEdits
	};
}
function normalizedInlineCompletionsEquals(a, b) {
	if (a === b) return true;
	if (!a || !b) return false;
	return a.range.equalsRange(b.range) && a.insertText === b.insertText && a.command === b.command;
}
/**
* @param previewSuffixLength Sets where to split `inlineCompletion.text`.
* 	If the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.
*/
function inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {
	if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) return;
	const sourceLine = textModel.getLineContent(inlineCompletion.range.startLineNumber);
	const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;
	if (inlineCompletion.range.startColumn - 1 <= sourceIndentationLength) {
		const suggestionAddedIndentationLength = getLeadingWhitespace(inlineCompletion.insertText).length;
		const replacedIndentation = sourceLine.substring(inlineCompletion.range.startColumn - 1, sourceIndentationLength);
		inlineCompletion = {
			range: Range$1.fromPositions(inlineCompletion.range.getStartPosition().delta(0, replacedIndentation.length), inlineCompletion.range.getEndPosition()),
			insertText: inlineCompletion.insertText.startsWith(replacedIndentation) ? inlineCompletion.insertText.substring(replacedIndentation.length) : inlineCompletion.insertText.substring(suggestionAddedIndentationLength),
			command: inlineCompletion.command,
			snippetInfo: void 0,
			filterText: inlineCompletion.filterText,
			additionalTextEdits: inlineCompletion.additionalTextEdits
		};
	}
	const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);
	const changes = cachingDiff(valueToBeReplaced, inlineCompletion.insertText);
	if (!changes) return;
	const lineNumber = inlineCompletion.range.startLineNumber;
	const parts = new Array();
	if (mode === "prefix") {
		const filteredChanges = changes.filter((c) => c.originalLength === 0);
		if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) return;
	}
	const previewStartInCompletionText = inlineCompletion.insertText.length - previewSuffixLength;
	for (const c of changes) {
		const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;
		if (mode === "subwordSmart" && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) return;
		if (c.originalLength > 0) return;
		if (c.modifiedLength === 0) continue;
		const modifiedEnd = c.modifiedStart + c.modifiedLength;
		const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));
		const nonPreviewText = inlineCompletion.insertText.substring(c.modifiedStart, nonPreviewTextEnd);
		const italicText = inlineCompletion.insertText.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));
		if (nonPreviewText.length > 0) {
			const lines = splitLines(nonPreviewText);
			parts.push(new GhostTextPart(insertColumn, lines, false));
		}
		if (italicText.length > 0) {
			const lines = splitLines(italicText);
			parts.push(new GhostTextPart(insertColumn, lines, true));
		}
	}
	return new GhostText(lineNumber, parts, 0);
}
var lastRequest = void 0;
function cachingDiff(originalValue, newValue) {
	if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;
	else {
		let changes = smartDiff(originalValue, newValue, true);
		if (changes) {
			const deletedChars = deletedCharacters(changes);
			if (deletedChars > 0) {
				const newChanges = smartDiff(originalValue, newValue, false);
				if (newChanges && deletedCharacters(newChanges) < deletedChars) changes = newChanges;
			}
		}
		lastRequest = {
			originalValue,
			newValue,
			changes
		};
		return changes;
	}
}
function deletedCharacters(changes) {
	let sum$1 = 0;
	for (const c of changes) sum$1 += Math.max(c.originalLength - c.modifiedLength, 0);
	return sum$1;
}
/**
* When matching `if ()` with `if (f() = 1) { g(); }`,
* align it like this:        `if (       )`
* Not like this:			  `if (  )`
* Also not like this:		  `if (             )`.
*
* The parenthesis are preprocessed to ensure that they match correctly.
*/
function smartDiff(originalValue, newValue, smartBracketMatching) {
	if (originalValue.length > 5e3 || newValue.length > 5e3) return;
	function getMaxCharCode(val) {
		let maxCharCode$1 = 0;
		for (let i = 0, len = val.length; i < len; i++) {
			const charCode = val.charCodeAt(i);
			if (charCode > maxCharCode$1) maxCharCode$1 = charCode;
		}
		return maxCharCode$1;
	}
	const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));
	function getUniqueCharCode(id) {
		if (id < 0) throw new Error("unexpected");
		return maxCharCode + id + 1;
	}
	function getElements(source) {
		let level = 0;
		let group = 0;
		const characters = new Int32Array(source.length);
		for (let i = 0, len = source.length; i < len; i++) if (smartBracketMatching && source[i] === "(") {
			characters[i] = getUniqueCharCode(2 * (group * 100 + level));
			level++;
		} else if (smartBracketMatching && source[i] === ")") {
			level = Math.max(level - 1, 0);
			characters[i] = getUniqueCharCode(2 * (group * 100 + level) + 1);
			if (level === 0) group++;
		} else characters[i] = source.charCodeAt(i);
		return characters;
	}
	const elements1 = getElements(originalValue);
	const elements2 = getElements(newValue);
	return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js
function fixBracketsInLine(tokens, languageConfigurationService) {
	const bracketTokens = new LanguageAgnosticBracketTokens(new DenseKeyProvider(), (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));
	const node = parseDocument(new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens), [], void 0, true);
	let str = "";
	const line = tokens.getLineContent();
	function processNode(node$1, offset) {
		if (node$1.kind === 2) {
			processNode(node$1.openingBracket, offset);
			offset = lengthAdd(offset, node$1.openingBracket.length);
			if (node$1.child) {
				processNode(node$1.child, offset);
				offset = lengthAdd(offset, node$1.child.length);
			}
			if (node$1.closingBracket) {
				processNode(node$1.closingBracket, offset);
				offset = lengthAdd(offset, node$1.closingBracket.length);
			} else {
				const closingTokenText = bracketTokens.getSingleLanguageBracketTokens(node$1.openingBracket.languageId).findClosingTokenText(node$1.openingBracket.bracketIds);
				str += closingTokenText;
			}
		} else if (node$1.kind === 3) {} else if (node$1.kind === 0 || node$1.kind === 1) str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node$1.length)));
		else if (node$1.kind === 4) for (const child of node$1.children) {
			processNode(child, offset);
			offset = lengthAdd(offset, child.length);
		}
	}
	processNode(node, lengthZero);
	return str;
}
var StaticTokenizerSource = class {
	constructor(lines) {
		this.lines = lines;
		this.tokenization = { getLineTokens: (lineNumber) => {
			return this.lines[lineNumber - 1];
		} };
	}
	getLineCount() {
		return this.lines.length;
	}
	getLineLength(lineNumber) {
		return this.lines[lineNumber - 1].getLineContent().length;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js
var __decorate$44 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$44 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$26 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var InlineCompletionsModel = class InlineCompletionsModel$1 extends Disposable {
	constructor(editor$1, cache, commandService, languageConfigurationService, languageFeaturesService, debounceService, configurationService) {
		super();
		this.editor = editor$1;
		this.cache = cache;
		this.commandService = commandService;
		this.languageConfigurationService = languageConfigurationService;
		this.languageFeaturesService = languageFeaturesService;
		this.debounceService = debounceService;
		this.onDidChangeEmitter = new Emitter$1();
		this.onDidChange = this.onDidChangeEmitter.event;
		this.completionSession = this._register(new MutableDisposable());
		this.active = false;
		this.disposed = false;
		this.debounceValue = this.debounceService.for(this.languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", {
			min: 50,
			max: 50
		});
		this._register(commandService.onDidExecuteCommand((e) => {
			if (new Set([
				CoreEditingCommands.Tab.id,
				CoreEditingCommands.DeleteLeft.id,
				CoreEditingCommands.DeleteRight.id,
				inlineSuggestCommitId,
				"acceptSelectedSuggestion"
			]).has(e.commandId) && editor$1.hasTextFocus()) this.handleUserInput();
		}));
		this._register(this.editor.onDidType((e) => {
			this.handleUserInput();
		}));
		this._register(this.editor.onDidChangeCursorPosition((e) => {
			if (e.reason === 3 || this.session && !this.session.isValid) this.hide();
		}));
		this._register(toDisposable(() => {
			this.disposed = true;
		}));
		this._register(this.editor.onDidBlurEditorWidget(() => {
			if (configurationService.getValue("editor.inlineSuggest.hideOnBlur")) return;
			this.hide();
		}));
	}
	handleUserInput() {
		if (this.session && !this.session.isValid) this.hide();
		setTimeout(() => {
			if (this.disposed) return;
			this.startSessionIfTriggered();
		}, 0);
	}
	get session() {
		return this.completionSession.value;
	}
	get ghostText() {
		var _a$5;
		return (_a$5 = this.session) === null || _a$5 === void 0 ? void 0 : _a$5.ghostText;
	}
	get minReservedLineCount() {
		return this.session ? this.session.minReservedLineCount : 0;
	}
	setExpanded(expanded) {
		var _a$5;
		(_a$5 = this.session) === null || _a$5 === void 0 || _a$5.setExpanded(expanded);
	}
	setActive(active) {
		var _a$5;
		this.active = active;
		if (active) (_a$5 = this.session) === null || _a$5 === void 0 || _a$5.scheduleAutomaticUpdate();
	}
	startSessionIfTriggered() {
		if (!this.editor.getOption(57).enabled) return;
		if (this.session && this.session.isValid) return;
		this.trigger(InlineCompletionTriggerKind.Automatic);
	}
	trigger(triggerKind) {
		if (this.completionSession.value) {
			if (triggerKind === InlineCompletionTriggerKind.Explicit) this.completionSession.value.ensureUpdateWithExplicitContext();
			return;
		}
		this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind, this.languageConfigurationService, this.languageFeaturesService.inlineCompletionsProvider, this.debounceValue);
		this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {
			this.onDidChangeEmitter.fire();
		}));
	}
	hide() {
		this.completionSession.clear();
		this.onDidChangeEmitter.fire();
	}
	commitCurrentSuggestion() {
		var _a$5;
		(_a$5 = this.session) === null || _a$5 === void 0 || _a$5.commitCurrentCompletion();
	}
	showNext() {
		var _a$5;
		(_a$5 = this.session) === null || _a$5 === void 0 || _a$5.showNextInlineCompletion();
	}
	showPrevious() {
		var _a$5;
		(_a$5 = this.session) === null || _a$5 === void 0 || _a$5.showPreviousInlineCompletion();
	}
	hasMultipleInlineCompletions() {
		var _a$5;
		return __awaiter$26(this, void 0, void 0, function* () {
			const result = yield (_a$5 = this.session) === null || _a$5 === void 0 ? void 0 : _a$5.hasMultipleInlineCompletions();
			return result !== void 0 ? result : false;
		});
	}
};
InlineCompletionsModel = __decorate$44([
	__param$44(2, ICommandService),
	__param$44(3, ILanguageConfigurationService),
	__param$44(4, ILanguageFeaturesService),
	__param$44(5, ILanguageFeatureDebounceService),
	__param$44(6, IConfigurationService)
], InlineCompletionsModel);
var InlineCompletionsSession = class extends BaseGhostTextWidgetModel {
	constructor(editor$1, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind, languageConfigurationService, registry, debounce) {
		super(editor$1);
		this.triggerPosition = triggerPosition;
		this.shouldUpdate = shouldUpdate;
		this.commandService = commandService;
		this.cache = cache;
		this.initialTriggerKind = initialTriggerKind;
		this.languageConfigurationService = languageConfigurationService;
		this.registry = registry;
		this.debounce = debounce;
		this.minReservedLineCount = 0;
		this.updateOperation = this._register(new MutableDisposable());
		this.updateSoon = this._register(new RunOnceScheduler(() => {
			const triggerKind = this.initialTriggerKind;
			this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;
			return this.update(triggerKind);
		}, 50));
		this.filteredCompletions = [];
		this.currentlySelectedCompletionId = void 0;
		let lastCompletionItem = void 0;
		this._register(this.onDidChange(() => {
			var _a$5;
			const currentCompletion = this.currentCompletion;
			if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {
				lastCompletionItem = currentCompletion.sourceInlineCompletion;
				const provider = currentCompletion.sourceProvider;
				(_a$5 = provider.handleItemDidShow) === null || _a$5 === void 0 || _a$5.call(provider, currentCompletion.sourceInlineCompletions, lastCompletionItem);
			}
		}));
		this._register(toDisposable(() => {
			this.cache.clear();
		}));
		this._register(this.editor.onDidChangeCursorPosition((e) => {
			var _a$5;
			if (e.reason === 3) return;
			(_a$5 = this.cache.value) === null || _a$5 === void 0 || _a$5.updateRanges();
			if (this.cache.value) {
				this.updateFilteredInlineCompletions();
				this.onDidChangeEmitter.fire();
			}
		}));
		this._register(this.editor.onDidChangeModelContent((e) => {
			var _a$5;
			(_a$5 = this.cache.value) === null || _a$5 === void 0 || _a$5.updateRanges();
			this.updateFilteredInlineCompletions();
			this.scheduleAutomaticUpdate();
		}));
		this._register(this.registry.onDidChange(() => {
			this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));
		}));
		this.scheduleAutomaticUpdate();
	}
	updateFilteredInlineCompletions() {
		if (!this.cache.value) {
			this.filteredCompletions = [];
			return;
		}
		const model = this.editor.getModel();
		const cursorPosition = model.validatePosition(this.editor.getPosition());
		this.filteredCompletions = this.cache.value.completions.filter((c) => {
			const originalValue = model.getValueInRange(c.synchronizedRange).toLowerCase();
			const filterText = c.inlineCompletion.filterText.toLowerCase();
			const indent = model.getLineIndentColumn(c.synchronizedRange.startLineNumber);
			const cursorPosIndex = Math.max(0, cursorPosition.column - c.synchronizedRange.startColumn);
			let filterTextBefore = filterText.substring(0, cursorPosIndex);
			let filterTextAfter = filterText.substring(cursorPosIndex);
			let originalValueBefore = originalValue.substring(0, cursorPosIndex);
			let originalValueAfter = originalValue.substring(cursorPosIndex);
			if (c.synchronizedRange.startColumn <= indent) {
				originalValueBefore = originalValueBefore.trimStart();
				if (originalValueBefore.length === 0) originalValueAfter = originalValueAfter.trimStart();
				filterTextBefore = filterTextBefore.trimStart();
				if (filterTextBefore.length === 0) filterTextAfter = filterTextAfter.trimStart();
			}
			return filterTextBefore.startsWith(originalValueBefore) && matchesSubString(originalValueAfter, filterTextAfter);
		});
	}
	fixAndGetIndexOfCurrentSelection() {
		if (!this.currentlySelectedCompletionId || !this.cache.value) return 0;
		if (this.cache.value.completions.length === 0) return 0;
		const idx = this.filteredCompletions.findIndex((v) => v.semanticId === this.currentlySelectedCompletionId);
		if (idx === -1) {
			this.currentlySelectedCompletionId = void 0;
			return 0;
		}
		return idx;
	}
	get currentCachedCompletion() {
		if (!this.cache.value) return;
		return this.filteredCompletions[this.fixAndGetIndexOfCurrentSelection()];
	}
	showNextInlineCompletion() {
		return __awaiter$26(this, void 0, void 0, function* () {
			yield this.ensureUpdateWithExplicitContext();
			const completions = this.filteredCompletions || [];
			if (completions.length > 0) this.currentlySelectedCompletionId = completions[(this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length].semanticId;
			else this.currentlySelectedCompletionId = void 0;
			this.onDidChangeEmitter.fire();
		});
	}
	showPreviousInlineCompletion() {
		return __awaiter$26(this, void 0, void 0, function* () {
			yield this.ensureUpdateWithExplicitContext();
			const completions = this.filteredCompletions || [];
			if (completions.length > 0) this.currentlySelectedCompletionId = completions[(this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length].semanticId;
			else this.currentlySelectedCompletionId = void 0;
			this.onDidChangeEmitter.fire();
		});
	}
	ensureUpdateWithExplicitContext() {
		var _a$5;
		return __awaiter$26(this, void 0, void 0, function* () {
			if (this.updateOperation.value) if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) yield this.updateOperation.value.promise;
			else yield this.update(InlineCompletionTriggerKind.Explicit);
			else if (((_a$5 = this.cache.value) === null || _a$5 === void 0 ? void 0 : _a$5.triggerKind) !== InlineCompletionTriggerKind.Explicit) yield this.update(InlineCompletionTriggerKind.Explicit);
		});
	}
	hasMultipleInlineCompletions() {
		var _a$5;
		return __awaiter$26(this, void 0, void 0, function* () {
			yield this.ensureUpdateWithExplicitContext();
			return (((_a$5 = this.cache.value) === null || _a$5 === void 0 ? void 0 : _a$5.completions.length) || 0) > 1;
		});
	}
	get ghostText() {
		const currentCompletion = this.currentCompletion;
		if (!currentCompletion) return;
		const cursorPosition = this.editor.getPosition();
		if (currentCompletion.range.getEndPosition().isBefore(cursorPosition)) return;
		const mode = this.editor.getOptions().get(57).mode;
		const ghostText = inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, cursorPosition);
		if (ghostText) {
			if (ghostText.isEmpty()) return;
			return ghostText;
		}
		return new GhostTextReplacement(currentCompletion.range.startLineNumber, currentCompletion.range.startColumn, currentCompletion.range.endColumn - currentCompletion.range.startColumn, currentCompletion.insertText.split("\n"), 0);
	}
	get currentCompletion() {
		const completion = this.currentCachedCompletion;
		if (!completion) return;
		return completion.toLiveInlineCompletion();
	}
	get isValid() {
		return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;
	}
	scheduleAutomaticUpdate() {
		this.updateOperation.clear();
		this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));
	}
	update(triggerKind) {
		return __awaiter$26(this, void 0, void 0, function* () {
			if (!this.shouldUpdate()) return;
			const position = this.editor.getPosition();
			const startTime = /* @__PURE__ */ new Date();
			const promise = createCancelablePromise((token) => __awaiter$26(this, void 0, void 0, function* () {
				let result;
				try {
					result = yield provideInlineCompletions(this.registry, position, this.editor.getModel(), {
						triggerKind,
						selectedSuggestionInfo: void 0
					}, token, this.languageConfigurationService);
					const endTime = /* @__PURE__ */ new Date();
					this.debounce.update(this.editor.getModel(), endTime.getTime() - startTime.getTime());
				} catch (e) {
					onUnexpectedError(e);
					return;
				}
				if (token.isCancellationRequested) return;
				this.cache.setValue(this.editor, result, triggerKind);
				this.updateFilteredInlineCompletions();
				this.onDidChangeEmitter.fire();
			}));
			const operation = new UpdateOperation(promise, triggerKind);
			this.updateOperation.value = operation;
			yield promise;
			if (this.updateOperation.value === operation) this.updateOperation.clear();
		});
	}
	takeOwnership(disposable) {
		this._register(disposable);
	}
	commitCurrentCompletion() {
		if (!this.ghostText) return;
		const completion = this.currentCompletion;
		if (completion) this.commit(completion);
	}
	commit(completion) {
		var _a$5;
		const cache = this.cache.clearAndLeak();
		if (completion.snippetInfo) {
			this.editor.executeEdits("inlineSuggestion.accept", [EditOperation.replaceMove(completion.range, ""), ...completion.additionalTextEdits]);
			this.editor.setPosition(completion.snippetInfo.range.getStartPosition());
			(_a$5 = SnippetController2.get(this.editor)) === null || _a$5 === void 0 || _a$5.insert(completion.snippetInfo.snippet);
		} else this.editor.executeEdits("inlineSuggestion.accept", [EditOperation.replaceMove(completion.range, completion.insertText), ...completion.additionalTextEdits]);
		if (completion.command) this.commandService.executeCommand(completion.command.id, ...completion.command.arguments || []).finally(() => {
			cache === null || cache === void 0 || cache.dispose();
		}).then(void 0, onUnexpectedExternalError);
		else cache === null || cache === void 0 || cache.dispose();
		this.onDidChangeEmitter.fire();
	}
	get commands() {
		var _a$5;
		return [...new Set(((_a$5 = this.cache.value) === null || _a$5 === void 0 ? void 0 : _a$5.completions.map((c) => c.inlineCompletion.sourceInlineCompletions)) || [])].flatMap((l) => l.commands || []);
	}
};
var UpdateOperation = class {
	constructor(promise, triggerKind) {
		this.promise = promise;
		this.triggerKind = triggerKind;
	}
	dispose() {
		this.promise.cancel();
	}
};
/**
* The cache keeps itself in sync with the editor.
* It also owns the completions result and disposes it when the cache is diposed.
*/
var SynchronizedInlineCompletionsCache = class extends Disposable {
	constructor(completionsSource, editor$1, onChange, triggerKind) {
		super();
		this.editor = editor$1;
		this.onChange = onChange;
		this.triggerKind = triggerKind;
		this.isDisposing = false;
		const decorationIds = editor$1.changeDecorations((changeAccessor) => {
			return changeAccessor.deltaDecorations([], completionsSource.items.map((i) => ({
				range: i.range,
				options: { description: "inline-completion-tracking-range" }
			})));
		});
		this._register(toDisposable(() => {
			this.isDisposing = true;
			editor$1.removeDecorations(decorationIds);
		}));
		this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));
		this._register(editor$1.onDidChangeModelContent(() => {
			this.updateRanges();
		}));
		this._register(completionsSource);
	}
	updateRanges() {
		if (this.isDisposing) return;
		let hasChanged = false;
		const model = this.editor.getModel();
		for (const c of this.completions) {
			const newRange = model.getDecorationRange(c.decorationId);
			if (!newRange) {
				onUnexpectedError(/* @__PURE__ */ new Error("Decoration has no range"));
				continue;
			}
			if (!c.synchronizedRange.equalsRange(newRange)) {
				hasChanged = true;
				c.synchronizedRange = newRange;
			}
		}
		if (hasChanged) this.onChange();
	}
};
var CachedInlineCompletion = class {
	constructor(inlineCompletion, decorationId) {
		this.inlineCompletion = inlineCompletion;
		this.decorationId = decorationId;
		this.semanticId = JSON.stringify({
			text: this.inlineCompletion.insertText,
			abbreviation: this.inlineCompletion.filterText,
			startLine: this.inlineCompletion.range.startLineNumber,
			startColumn: this.inlineCompletion.range.startColumn,
			command: this.inlineCompletion.command
		});
		this.synchronizedRange = inlineCompletion.range;
	}
	toLiveInlineCompletion() {
		return {
			insertText: this.inlineCompletion.insertText,
			range: this.synchronizedRange,
			command: this.inlineCompletion.command,
			sourceProvider: this.inlineCompletion.sourceProvider,
			sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,
			sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion,
			snippetInfo: this.inlineCompletion.snippetInfo,
			filterText: this.inlineCompletion.filterText,
			additionalTextEdits: this.inlineCompletion.additionalTextEdits
		};
	}
};
function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {
	return __awaiter$26(this, void 0, void 0, function* () {
		const defaultReplaceRange = getDefaultRange(position, model);
		const providers = registry.all(model);
		const results = yield Promise.all(providers.map((provider) => __awaiter$26(this, void 0, void 0, function* () {
			const completions = yield Promise.resolve(provider.provideInlineCompletions(model, position, context, token)).catch(onUnexpectedExternalError);
			return {
				completions,
				provider,
				dispose: () => {
					if (completions) provider.freeInlineCompletions(completions);
				}
			};
		})));
		const itemsByHash = /* @__PURE__ */ new Map();
		for (const result of results) {
			const completions = result.completions;
			if (!completions) continue;
			for (const item of completions.items) {
				let range = item.range ? Range$1.lift(item.range) : defaultReplaceRange;
				if (range.startLineNumber !== range.endLineNumber) continue;
				let insertText;
				let snippetInfo;
				if (typeof item.insertText === "string") {
					insertText = item.insertText;
					if (languageConfigurationService && item.completeBracketPairs) {
						insertText = closeBrackets(insertText, range.getStartPosition(), model, languageConfigurationService);
						const diff = insertText.length - item.insertText.length;
						if (diff !== 0) range = new Range$1(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
					}
					snippetInfo = void 0;
				} else if ("snippet" in item.insertText) {
					insertText = new SnippetParser().parse(item.insertText.snippet).toString();
					snippetInfo = {
						snippet: item.insertText.snippet,
						range
					};
				} else assertNever(item.insertText);
				const trackedItem = {
					insertText,
					snippetInfo,
					range,
					command: item.command,
					sourceProvider: result.provider,
					sourceInlineCompletions: completions,
					sourceInlineCompletion: item,
					filterText: item.filterText || insertText,
					additionalTextEdits: item.additionalTextEdits || getReadonlyEmptyArray()
				};
				itemsByHash.set(JSON.stringify({
					insertText,
					range: item.range
				}), trackedItem);
			}
		}
		return {
			items: [...itemsByHash.values()],
			dispose: () => {
				for (const result of results) result.dispose();
			}
		};
	});
}
function getDefaultRange(position, model) {
	const word = model.getWordAtPosition(position);
	const maxColumn = model.getLineMaxColumn(position.lineNumber);
	return word ? new Range$1(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range$1.fromPositions(position, position.with(void 0, maxColumn));
}
function closeBrackets(text, position, model, languageConfigurationService) {
	const newLine = model.getLineContent(position.lineNumber).substring(0, position.column - 1) + text;
	const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);
	const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);
	if (!slicedTokens) return text;
	return fixBracketsInLine(slicedTokens, languageConfigurationService);
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestMemory.js
var __decorate$43 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$43 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var Memory = class {
	constructor(name) {
		this.name = name;
	}
	select(model, pos, items) {
		if (items.length === 0) return 0;
		const topScore = items[0].score[0];
		for (let i = 0; i < items.length; i++) {
			const { score, completion: suggestion } = items[i];
			if (score[0] !== topScore) break;
			if (suggestion.preselect) return i;
		}
		return 0;
	}
};
var NoMemory = class extends Memory {
	constructor() {
		super("first");
	}
	memorize(model, pos, item) {}
	toJSON() {}
	fromJSON() {}
};
var LRUMemory = class extends Memory {
	constructor() {
		super("recentlyUsed");
		this._cache = new LRUCache(300, .66);
		this._seq = 0;
	}
	memorize(model, pos, item) {
		const key = `${model.getLanguageId()}/${item.textLabel}`;
		this._cache.set(key, {
			touch: this._seq++,
			type: item.completion.kind,
			insertText: item.completion.insertText
		});
	}
	select(model, pos, items) {
		if (items.length === 0) return 0;
		const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
		if (/\s$/.test(lineSuffix)) return super.select(model, pos, items);
		const topScore = items[0].score[0];
		let indexPreselect = -1;
		let indexRecency = -1;
		let seq = -1;
		for (let i = 0; i < items.length; i++) {
			if (items[i].score[0] !== topScore) break;
			const key = `${model.getLanguageId()}/${items[i].textLabel}`;
			const item = this._cache.peek(key);
			if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {
				seq = item.touch;
				indexRecency = i;
			}
			if (items[i].completion.preselect && indexPreselect === -1) return indexPreselect = i;
		}
		if (indexRecency !== -1) return indexRecency;
		else if (indexPreselect !== -1) return indexPreselect;
		else return 0;
	}
	toJSON() {
		return this._cache.toJSON();
	}
	fromJSON(data) {
		this._cache.clear();
		const seq = 0;
		for (const [key, value] of data) {
			value.touch = seq;
			value.type = typeof value.type === "number" ? value.type : CompletionItemKinds.fromString(value.type);
			this._cache.set(key, value);
		}
		this._seq = this._cache.size;
	}
};
var PrefixMemory = class extends Memory {
	constructor() {
		super("recentlyUsedByPrefix");
		this._trie = TernarySearchTree.forStrings();
		this._seq = 0;
	}
	memorize(model, pos, item) {
		const { word } = model.getWordUntilPosition(pos);
		const key = `${model.getLanguageId()}/${word}`;
		this._trie.set(key, {
			type: item.completion.kind,
			insertText: item.completion.insertText,
			touch: this._seq++
		});
	}
	select(model, pos, items) {
		const { word } = model.getWordUntilPosition(pos);
		if (!word) return super.select(model, pos, items);
		const key = `${model.getLanguageId()}/${word}`;
		let item = this._trie.get(key);
		if (!item) item = this._trie.findSubstr(key);
		if (item) for (let i = 0; i < items.length; i++) {
			const { kind, insertText } = items[i].completion;
			if (kind === item.type && insertText === item.insertText) return i;
		}
		return super.select(model, pos, items);
	}
	toJSON() {
		const entries = [];
		this._trie.forEach((value, key) => entries.push([key, value]));
		entries.sort((a, b) => -(a[1].touch - b[1].touch)).forEach((value, i) => value[1].touch = i);
		return entries.slice(0, 200);
	}
	fromJSON(data) {
		this._trie.clear();
		if (data.length > 0) {
			this._seq = data[0][1].touch + 1;
			for (const [key, value] of data) {
				value.type = typeof value.type === "number" ? value.type : CompletionItemKinds.fromString(value.type);
				this._trie.set(key, value);
			}
		}
	}
};
var SuggestMemoryService = class SuggestMemoryService$1 {
	constructor(_storageService, _configService) {
		this._storageService = _storageService;
		this._configService = _configService;
		this._disposables = new DisposableStore();
		this._persistSoon = new RunOnceScheduler(() => this._saveState(), 500);
		this._disposables.add(_storageService.onWillSaveState((e) => {
			if (e.reason === WillSaveStateReason.SHUTDOWN) this._saveState();
		}));
	}
	dispose() {
		this._disposables.dispose();
		this._persistSoon.dispose();
	}
	memorize(model, pos, item) {
		this._withStrategy(model, pos).memorize(model, pos, item);
		this._persistSoon.schedule();
	}
	select(model, pos, items) {
		return this._withStrategy(model, pos).select(model, pos, items);
	}
	_withStrategy(model, pos) {
		var _a$5;
		const mode = this._configService.getValue("editor.suggestSelection", {
			overrideIdentifier: model.getLanguageIdAtPosition(pos.lineNumber, pos.column),
			resource: model.uri
		});
		if (((_a$5 = this._strategy) === null || _a$5 === void 0 ? void 0 : _a$5.name) !== mode) {
			this._saveState();
			this._strategy = new ((SuggestMemoryService$1._strategyCtors.get(mode)) || NoMemory)();
			try {
				const scope = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1;
				const raw = this._storageService.get(`${SuggestMemoryService$1._storagePrefix}/${mode}`, scope);
				if (raw) this._strategy.fromJSON(JSON.parse(raw));
			} catch (e) {}
		}
		return this._strategy;
	}
	_saveState() {
		if (this._strategy) {
			const scope = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1;
			const raw = JSON.stringify(this._strategy);
			this._storageService.store(`${SuggestMemoryService$1._storagePrefix}/${this._strategy.name}`, raw, scope, 1);
		}
	}
};
SuggestMemoryService._strategyCtors = new Map([
	["recentlyUsedByPrefix", PrefixMemory],
	["recentlyUsed", LRUMemory],
	["first", NoMemory]
]);
SuggestMemoryService._storagePrefix = "suggest/memories";
SuggestMemoryService = __decorate$43([__param$43(0, IStorageService), __param$43(1, IConfigurationService)], SuggestMemoryService);
const ISuggestMemoryService = createDecorator("ISuggestMemories");
registerSingleton(ISuggestMemoryService, SuggestMemoryService, true);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordContextKey.js
var __decorate$42 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$42 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var WordContextKey = class WordContextKey$1 {
	constructor(_editor, contextKeyService) {
		this._editor = _editor;
		this._enabled = false;
		this._ckAtEnd = WordContextKey$1.AtEnd.bindTo(contextKeyService);
		this._configListener = this._editor.onDidChangeConfiguration((e) => e.hasChanged(113) && this._update());
		this._update();
	}
	dispose() {
		var _a$5;
		this._configListener.dispose();
		(_a$5 = this._selectionListener) === null || _a$5 === void 0 || _a$5.dispose();
		this._ckAtEnd.reset();
	}
	_update() {
		const enabled = this._editor.getOption(113) === "on";
		if (this._enabled === enabled) return;
		this._enabled = enabled;
		if (this._enabled) {
			const checkForWordEnd = () => {
				if (!this._editor.hasModel()) {
					this._ckAtEnd.set(false);
					return;
				}
				const model = this._editor.getModel();
				const selection = this._editor.getSelection();
				const word = model.getWordAtPosition(selection.getStartPosition());
				if (!word) {
					this._ckAtEnd.set(false);
					return;
				}
				this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column);
			};
			this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);
			checkForWordEnd();
		} else if (this._selectionListener) {
			this._ckAtEnd.reset();
			this._selectionListener.dispose();
			this._selectionListener = void 0;
		}
	}
};
WordContextKey.AtEnd = new RawContextKey("atEndOfWord", false);
WordContextKey = __decorate$42([__param$42(1, IContextKeyService)], WordContextKey);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestAlternatives.js
var __decorate$41 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$41 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var SuggestAlternatives = class SuggestAlternatives$1 {
	constructor(_editor, contextKeyService) {
		this._editor = _editor;
		this._index = 0;
		this._ckOtherSuggestions = SuggestAlternatives$1.OtherSuggestions.bindTo(contextKeyService);
	}
	dispose() {
		this.reset();
	}
	reset() {
		var _a$5;
		this._ckOtherSuggestions.reset();
		(_a$5 = this._listener) === null || _a$5 === void 0 || _a$5.dispose();
		this._model = void 0;
		this._acceptNext = void 0;
		this._ignore = false;
	}
	set({ model, index }, acceptNext) {
		if (model.items.length === 0) {
			this.reset();
			return;
		}
		if (SuggestAlternatives$1._moveIndex(true, model, index) === index) {
			this.reset();
			return;
		}
		this._acceptNext = acceptNext;
		this._model = model;
		this._index = index;
		this._listener = this._editor.onDidChangeCursorPosition(() => {
			if (!this._ignore) this.reset();
		});
		this._ckOtherSuggestions.set(true);
	}
	static _moveIndex(fwd, model, index) {
		let newIndex = index;
		while (true) {
			newIndex = (newIndex + model.items.length + (fwd ? 1 : -1)) % model.items.length;
			if (newIndex === index) break;
			if (!model.items[newIndex].completion.additionalTextEdits) break;
		}
		return newIndex;
	}
	next() {
		this._move(true);
	}
	prev() {
		this._move(false);
	}
	_move(fwd) {
		if (!this._model) return;
		try {
			this._ignore = true;
			this._index = SuggestAlternatives$1._moveIndex(fwd, this._model, this._index);
			this._acceptNext({
				index: this._index,
				item: this._model.items[this._index],
				model: this._model
			});
		} finally {
			this._ignore = false;
		}
	}
};
SuggestAlternatives.OtherSuggestions = new RawContextKey("hasOtherSuggestions", false);
SuggestAlternatives = __decorate$41([__param$41(1, IContextKeyService)], SuggestAlternatives);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestCommitCharacters.js
var CommitCharacterController = class {
	constructor(editor$1, widget, accept) {
		this._disposables = new DisposableStore();
		this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));
		this._disposables.add(widget.onDidFocus(this._onItem, this));
		this._disposables.add(widget.onDidHide(this.reset, this));
		this._disposables.add(editor$1.onWillType((text) => {
			if (this._active && !widget.isFrozen()) {
				const ch = text.charCodeAt(text.length - 1);
				if (this._active.acceptCharacters.has(ch) && editor$1.getOption(0)) accept(this._active.item);
			}
		}));
	}
	_onItem(selected) {
		if (!selected || !isNonEmptyArray(selected.item.completion.commitCharacters)) {
			this.reset();
			return;
		}
		if (this._active && this._active.item.item === selected.item) return;
		const acceptCharacters = new CharacterSet();
		for (const ch of selected.item.completion.commitCharacters) if (ch.length > 0) acceptCharacters.add(ch.charCodeAt(0));
		this._active = {
			acceptCharacters,
			item: selected
		};
	}
	reset() {
		this._active = void 0;
	}
	dispose() {
		this._disposables.dispose();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/bracketSelections.js
var __awaiter$25 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var BracketSelectionRangeProvider = class BracketSelectionRangeProvider {
	provideSelectionRanges(model, positions) {
		return __awaiter$25(this, void 0, void 0, function* () {
			const result = [];
			for (const position of positions) {
				const bucket = [];
				result.push(bucket);
				const ranges = /* @__PURE__ */ new Map();
				yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
				yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
			}
			return result;
		});
	}
	static _bracketsRightYield(resolve, round, model, pos, ranges) {
		const counts = /* @__PURE__ */ new Map();
		const t1 = Date.now();
		while (true) {
			if (round >= BracketSelectionRangeProvider._maxRounds) {
				resolve();
				break;
			}
			if (!pos) {
				resolve();
				break;
			}
			const bracket = model.bracketPairs.findNextBracket(pos);
			if (!bracket) {
				resolve();
				break;
			}
			if (Date.now() - t1 > BracketSelectionRangeProvider._maxDuration) {
				setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));
				break;
			}
			if (bracket.bracketInfo.isOpeningBracket) {
				const key = bracket.bracketInfo.bracketText;
				const val = counts.has(key) ? counts.get(key) : 0;
				counts.set(key, val + 1);
			} else {
				const key = bracket.bracketInfo.getClosedBrackets()[0].bracketText;
				let val = counts.has(key) ? counts.get(key) : 0;
				val -= 1;
				counts.set(key, Math.max(0, val));
				if (val < 0) {
					let list = ranges.get(key);
					if (!list) {
						list = new LinkedList();
						ranges.set(key, list);
					}
					list.push(bracket.range);
				}
			}
			pos = bracket.range.getEndPosition();
		}
	}
	static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {
		const counts = /* @__PURE__ */ new Map();
		const t1 = Date.now();
		while (true) {
			if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {
				resolve();
				break;
			}
			if (!pos) {
				resolve();
				break;
			}
			const bracket = model.bracketPairs.findPrevBracket(pos);
			if (!bracket) {
				resolve();
				break;
			}
			if (Date.now() - t1 > BracketSelectionRangeProvider._maxDuration) {
				setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));
				break;
			}
			if (!bracket.bracketInfo.isOpeningBracket) {
				const key = bracket.bracketInfo.getClosedBrackets()[0].bracketText;
				const val = counts.has(key) ? counts.get(key) : 0;
				counts.set(key, val + 1);
			} else {
				const key = bracket.bracketInfo.bracketText;
				let val = counts.has(key) ? counts.get(key) : 0;
				val -= 1;
				counts.set(key, Math.max(0, val));
				if (val < 0) {
					const list = ranges.get(key);
					if (list) {
						const closing = list.shift();
						if (list.size === 0) ranges.delete(key);
						const innerBracket = Range$1.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());
						const outerBracket = Range$1.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());
						bucket.push({ range: innerBracket });
						bucket.push({ range: outerBracket });
						BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);
					}
				}
			}
			pos = bracket.range.getStartPosition();
		}
	}
	static _addBracketLeading(model, bracket, bucket) {
		if (bracket.startLineNumber === bracket.endLineNumber) return;
		const startLine = bracket.startLineNumber;
		const column = model.getLineFirstNonWhitespaceColumn(startLine);
		if (column !== 0 && column !== bracket.startColumn) {
			bucket.push({ range: Range$1.fromPositions(new Position$1(startLine, column), bracket.getEndPosition()) });
			bucket.push({ range: Range$1.fromPositions(new Position$1(startLine, 1), bracket.getEndPosition()) });
		}
		const aboveLine = startLine - 1;
		if (aboveLine > 0) {
			const column$1 = model.getLineFirstNonWhitespaceColumn(aboveLine);
			if (column$1 === bracket.startColumn && column$1 !== model.getLineLastNonWhitespaceColumn(aboveLine)) {
				bucket.push({ range: Range$1.fromPositions(new Position$1(aboveLine, column$1), bracket.getEndPosition()) });
				bucket.push({ range: Range$1.fromPositions(new Position$1(aboveLine, 1), bracket.getEndPosition()) });
			}
		}
	}
};
BracketSelectionRangeProvider._maxDuration = 30;
BracketSelectionRangeProvider._maxRounds = 2;

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordDistance.js
var __awaiter$24 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var WordDistance = class WordDistance {
	static create(service, editor$1) {
		return __awaiter$24(this, void 0, void 0, function* () {
			if (!editor$1.getOption(108).localityBonus) return WordDistance.None;
			if (!editor$1.hasModel()) return WordDistance.None;
			const model = editor$1.getModel();
			const position = editor$1.getPosition();
			if (!service.canComputeWordRanges(model.uri)) return WordDistance.None;
			const [ranges] = yield new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
			if (ranges.length === 0) return WordDistance.None;
			const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);
			if (!wordRanges) return WordDistance.None;
			const wordUntilPos = model.getWordUntilPosition(position);
			delete wordRanges[wordUntilPos.word];
			return new class extends WordDistance {
				distance(anchor, item) {
					if (!position.equals(editor$1.getPosition())) return 0;
					if (item.kind === 17) return 2 << 20;
					const wordLines = wordRanges[typeof item.label === "string" ? item.label : item.label.label];
					if (isFalsyOrEmpty(wordLines)) return 2 << 20;
					const idx = binarySearch(wordLines, Range$1.fromPositions(anchor), Range$1.compareRangesUsingStarts);
					const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
					let blockDistance = ranges.length;
					for (const range of ranges) {
						if (!Range$1.containsRange(range.range, bestWordRange)) break;
						blockDistance -= 1;
					}
					return blockDistance;
				}
			}();
		});
	}
};
WordDistance.None = new class extends WordDistance {
	distance() {
		return 0;
	}
}();

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/completionModel.js
var LineContext = class {
	constructor(leadingLineContent, characterCountDelta) {
		this.leadingLineContent = leadingLineContent;
		this.characterCountDelta = characterCountDelta;
	}
};
/**
* Sorted, filtered completion view model
* */
var CompletionModel = class CompletionModel {
	constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, fuzzyScoreOptions = FuzzyScoreOptions.default, clipboardText = void 0) {
		this.clipboardText = clipboardText;
		this._snippetCompareFn = CompletionModel._compareCompletionItems;
		this._items = items;
		this._column = column;
		this._wordDistance = wordDistance;
		this._options = options;
		this._refilterKind = 1;
		this._lineContext = lineContext;
		this._fuzzyScoreOptions = fuzzyScoreOptions;
		if (snippetSuggestions === "top") this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;
		else if (snippetSuggestions === "bottom") this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;
	}
	get lineContext() {
		return this._lineContext;
	}
	set lineContext(value) {
		if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
			this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
			this._lineContext = value;
		}
	}
	get items() {
		this._ensureCachedState();
		return this._filteredItems;
	}
	get allProvider() {
		this._ensureCachedState();
		return this._providerInfo.keys();
	}
	get incomplete() {
		this._ensureCachedState();
		const result = /* @__PURE__ */ new Set();
		for (const [provider, incomplete] of this._providerInfo) if (incomplete) result.add(provider);
		return result;
	}
	adopt(except) {
		const res = [];
		for (let i = 0; i < this._items.length;) if (!except.has(this._items[i].provider)) {
			res.push(this._items[i]);
			this._items[i] = this._items[this._items.length - 1];
			this._items.pop();
		} else i++;
		this._refilterKind = 1;
		return res;
	}
	get stats() {
		this._ensureCachedState();
		return this._stats;
	}
	_ensureCachedState() {
		if (this._refilterKind !== 0) this._createCachedState();
	}
	_createCachedState() {
		this._providerInfo = /* @__PURE__ */ new Map();
		const labelLengths = [];
		const { leadingLineContent, characterCountDelta } = this._lineContext;
		let word = "";
		let wordLow = "";
		const source = this._refilterKind === 1 ? this._items : this._filteredItems;
		const target = [];
		const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
		for (let i = 0; i < source.length; i++) {
			const item = source[i];
			if (item.isInvalid) continue;
			this._providerInfo.set(item.provider, Boolean(item.container.incomplete));
			const overwriteBefore = item.position.column - item.editStart.column;
			const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);
			if (word.length !== wordLen) {
				word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
				wordLow = word.toLowerCase();
			}
			item.word = word;
			if (wordLen === 0) item.score = FuzzyScore.Default;
			else {
				let wordPos = 0;
				while (wordPos < overwriteBefore) {
					const ch = word.charCodeAt(wordPos);
					if (ch === 32 || ch === 9) wordPos += 1;
					else break;
				}
				if (wordPos >= wordLen) item.score = FuzzyScore.Default;
				else if (typeof item.completion.filterText === "string") {
					const match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);
					if (!match) continue;
					if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) item.score = match;
					else {
						item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);
						item.score[0] = match[0];
					}
				} else {
					const match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);
					if (!match) continue;
					item.score = match;
				}
			}
			item.idx = i;
			item.distance = this._wordDistance.distance(item.position, item.completion);
			target.push(item);
			labelLengths.push(item.textLabel.length);
		}
		this._filteredItems = target.sort(this._snippetCompareFn);
		this._refilterKind = 0;
		this._stats = { pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b) : 0 };
	}
	static _compareCompletionItems(a, b) {
		if (a.score[0] > b.score[0]) return -1;
		else if (a.score[0] < b.score[0]) return 1;
		else if (a.distance < b.distance) return -1;
		else if (a.distance > b.distance) return 1;
		else if (a.idx < b.idx) return -1;
		else if (a.idx > b.idx) return 1;
		else return 0;
	}
	static _compareCompletionItemsSnippetsDown(a, b) {
		if (a.completion.kind !== b.completion.kind) {
			if (a.completion.kind === 27) return 1;
			else if (b.completion.kind === 27) return -1;
		}
		return CompletionModel._compareCompletionItems(a, b);
	}
	static _compareCompletionItemsSnippetsUp(a, b) {
		if (a.completion.kind !== b.completion.kind) {
			if (a.completion.kind === 27) return -1;
			else if (b.completion.kind === 27) return 1;
		}
		return CompletionModel._compareCompletionItems(a, b);
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
var __decorate$40 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$40 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$23 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var LineContext$1 = class {
	constructor(model, position, auto, shy, noSelect) {
		this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
		this.leadingWord = model.getWordUntilPosition(position);
		this.lineNumber = position.lineNumber;
		this.column = position.column;
		this.auto = auto;
		this.shy = shy;
		this.noSelect = noSelect;
	}
	static shouldAutoTrigger(editor$1) {
		if (!editor$1.hasModel()) return false;
		const model = editor$1.getModel();
		const pos = editor$1.getPosition();
		model.tokenization.tokenizeIfCheap(pos.lineNumber);
		const word = model.getWordAtPosition(pos);
		if (!word) return false;
		if (word.endColumn !== pos.column) return false;
		if (!isNaN(Number(word.word))) return false;
		return true;
	}
};
function canShowQuickSuggest(editor$1, contextKeyService, configurationService) {
	if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) return true;
	const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowQuickSuggestions");
	if (allowQuickSuggestions !== void 0) return Boolean(allowQuickSuggestions);
	return false;
}
function canShowSuggestOnTriggerCharacters(editor$1, contextKeyService, configurationService) {
	if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) return true;
	const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowSuggestOnTriggerCharacters");
	if (allowQuickSuggestions !== void 0) return Boolean(allowQuickSuggestions);
	return false;
}
var SuggestModel = class SuggestModel$1 {
	constructor(_editor, _editorWorkerService, _clipboardService, _telemetryService, _logService, _contextKeyService, _configurationService, _languageFeaturesService) {
		this._editor = _editor;
		this._editorWorkerService = _editorWorkerService;
		this._clipboardService = _clipboardService;
		this._telemetryService = _telemetryService;
		this._logService = _logService;
		this._contextKeyService = _contextKeyService;
		this._configurationService = _configurationService;
		this._languageFeaturesService = _languageFeaturesService;
		this._toDispose = new DisposableStore();
		this._triggerCharacterListener = new DisposableStore();
		this._triggerQuickSuggest = new TimeoutTimer();
		this._state = 0;
		this._completionDisposables = new DisposableStore();
		this._onDidCancel = new Emitter$1();
		this._onDidTrigger = new Emitter$1();
		this._onDidSuggest = new Emitter$1();
		this.onDidCancel = this._onDidCancel.event;
		this.onDidTrigger = this._onDidTrigger.event;
		this.onDidSuggest = this._onDidSuggest.event;
		this._telemetryGate = 0;
		this._currentSelection = this._editor.getSelection() || new Selection$1(1, 1, 1, 1);
		this._toDispose.add(this._editor.onDidChangeModel(() => {
			this._updateTriggerCharacters();
			this.cancel();
		}));
		this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
			this._updateTriggerCharacters();
			this.cancel();
		}));
		this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
			this._updateTriggerCharacters();
		}));
		this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
			this._updateTriggerCharacters();
			this._updateActiveSuggestSession();
		}));
		let editorIsComposing = false;
		this._toDispose.add(this._editor.onDidCompositionStart(() => {
			editorIsComposing = true;
		}));
		this._toDispose.add(this._editor.onDidCompositionEnd(() => {
			editorIsComposing = false;
			this._onCompositionEnd();
		}));
		this._toDispose.add(this._editor.onDidChangeCursorSelection((e) => {
			if (!editorIsComposing) this._onCursorChange(e);
		}));
		this._toDispose.add(this._editor.onDidChangeModelContent(() => {
			if (!editorIsComposing) this._refilterCompletionItems();
		}));
		this._updateTriggerCharacters();
	}
	dispose() {
		dispose(this._triggerCharacterListener);
		dispose([
			this._onDidCancel,
			this._onDidSuggest,
			this._onDidTrigger,
			this._triggerQuickSuggest
		]);
		this._toDispose.dispose();
		this._completionDisposables.dispose();
		this.cancel();
	}
	_updateTriggerCharacters() {
		this._triggerCharacterListener.clear();
		if (this._editor.getOption(83) || !this._editor.hasModel() || !this._editor.getOption(111)) return;
		const supportsByTriggerCharacter = /* @__PURE__ */ new Map();
		for (const support of this._languageFeaturesService.completionProvider.all(this._editor.getModel())) for (const ch of support.triggerCharacters || []) {
			let set = supportsByTriggerCharacter.get(ch);
			if (!set) {
				set = /* @__PURE__ */ new Set();
				set.add(getSnippetSuggestSupport());
				supportsByTriggerCharacter.set(ch, set);
			}
			set.add(support);
		}
		const checkTriggerCharacter = (text) => {
			if (!canShowSuggestOnTriggerCharacters(this._editor, this._contextKeyService, this._configurationService)) return;
			if (LineContext$1.shouldAutoTrigger(this._editor)) return;
			if (!text) {
				const position = this._editor.getPosition();
				text = this._editor.getModel().getLineContent(position.lineNumber).substr(0, position.column - 1);
			}
			let lastChar = "";
			if (isLowSurrogate(text.charCodeAt(text.length - 1))) {
				if (isHighSurrogate(text.charCodeAt(text.length - 2))) lastChar = text.substr(text.length - 2);
			} else lastChar = text.charAt(text.length - 1);
			const supports = supportsByTriggerCharacter.get(lastChar);
			if (supports) {
				const existing = this._completionModel ? {
					items: this._completionModel.adopt(supports),
					clipboardText: this._completionModel.clipboardText
				} : void 0;
				this.trigger({
					auto: true,
					shy: false,
					noSelect: false,
					triggerCharacter: lastChar
				}, Boolean(this._completionModel), supports, existing);
			}
		};
		this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));
		this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => checkTriggerCharacter()));
	}
	get state() {
		return this._state;
	}
	cancel(retrigger = false) {
		var _a$5;
		if (this._state !== 0) {
			this._triggerQuickSuggest.cancel();
			(_a$5 = this._requestToken) === null || _a$5 === void 0 || _a$5.cancel();
			this._requestToken = void 0;
			this._state = 0;
			this._completionModel = void 0;
			this._context = void 0;
			this._onDidCancel.fire({ retrigger });
		}
	}
	clear() {
		this._completionDisposables.clear();
	}
	_updateActiveSuggestSession() {
		if (this._state !== 0) if (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel())) this.cancel();
		else this.trigger({
			auto: this._state === 2,
			shy: false,
			noSelect: false
		}, true);
	}
	_onCursorChange(e) {
		if (!this._editor.hasModel()) return;
		const prevSelection = this._currentSelection;
		this._currentSelection = this._editor.getSelection();
		if (!e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
			this.cancel();
			return;
		}
		if (this._state === 0 && e.reason === 0) {
			if (prevSelection.containsRange(this._currentSelection) || prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) this._doTriggerQuickSuggest();
		} else if (this._state !== 0 && e.reason === 3) this._refilterCompletionItems();
	}
	_onCompositionEnd() {
		if (this._state === 0) this._doTriggerQuickSuggest();
		else this._refilterCompletionItems();
	}
	_doTriggerQuickSuggest() {
		var _a$5;
		if (QuickSuggestionsOptions.isAllOff(this._editor.getOption(81))) return;
		if (this._editor.getOption(108).snippetsPreventQuickSuggestions && ((_a$5 = SnippetController2.get(this._editor)) === null || _a$5 === void 0 ? void 0 : _a$5.isInSnippet())) return;
		this.cancel();
		this._triggerQuickSuggest.cancelAndSet(() => {
			if (this._state !== 0) return;
			if (!LineContext$1.shouldAutoTrigger(this._editor)) return;
			if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) return;
			const model = this._editor.getModel();
			const pos = this._editor.getPosition();
			const config = this._editor.getOption(81);
			if (QuickSuggestionsOptions.isAllOff(config)) return;
			if (!QuickSuggestionsOptions.isAllOn(config)) {
				model.tokenization.tokenizeIfCheap(pos.lineNumber);
				const lineTokens = model.tokenization.getLineTokens(pos.lineNumber);
				const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
				if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "on") return;
			}
			if (!canShowQuickSuggest(this._editor, this._contextKeyService, this._configurationService)) return;
			if (!this._languageFeaturesService.completionProvider.has(model)) return;
			this.trigger({
				auto: true,
				shy: false,
				noSelect: false
			});
		}, this._editor.getOption(82));
	}
	_refilterCompletionItems() {
		Promise.resolve().then(() => {
			if (this._state === 0) return;
			if (!this._editor.hasModel()) return;
			const ctx = new LineContext$1(this._editor.getModel(), this._editor.getPosition(), this._state === 2, false, false);
			this._onNewContext(ctx);
		});
	}
	trigger(context, retrigger = false, onlyFrom, existing, noFilter) {
		var _a$5;
		if (!this._editor.hasModel()) return;
		const model = this._editor.getModel();
		const auto = context.auto;
		const ctx = new LineContext$1(model, this._editor.getPosition(), auto, context.shy, context.noSelect);
		this.cancel(retrigger);
		this._state = auto ? 2 : 1;
		this._onDidTrigger.fire({
			auto,
			shy: context.shy,
			position: this._editor.getPosition()
		});
		this._context = ctx;
		let suggestCtx = { triggerKind: (_a$5 = context.triggerKind) !== null && _a$5 !== void 0 ? _a$5 : 0 };
		if (context.triggerCharacter) suggestCtx = {
			triggerKind: 1,
			triggerCharacter: context.triggerCharacter
		};
		this._requestToken = new CancellationTokenSource$1();
		const snippetSuggestions = this._editor.getOption(103);
		let snippetSortOrder = 1;
		switch (snippetSuggestions) {
			case "top":
				snippetSortOrder = 0;
				break;
			case "bottom":
				snippetSortOrder = 2;
				break;
		}
		const { itemKind: itemKindFilter, showDeprecated } = SuggestModel$1._createSuggestFilter(this._editor);
		const completionOptions = new CompletionOptions(snippetSortOrder, !noFilter ? itemKindFilter : /* @__PURE__ */ new Set(), onlyFrom, showDeprecated);
		const wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
		const completions = provideSuggestionItems(this._languageFeaturesService.completionProvider, model, this._editor.getPosition(), completionOptions, suggestCtx, this._requestToken.token);
		Promise.all([completions, wordDistance]).then(([completions$1, wordDistance$1]) => __awaiter$23(this, void 0, void 0, function* () {
			var _b$1;
			(_b$1 = this._requestToken) === null || _b$1 === void 0 || _b$1.dispose();
			if (!this._editor.hasModel()) return;
			let clipboardText = existing === null || existing === void 0 ? void 0 : existing.clipboardText;
			if (!clipboardText && completions$1.needsClipboard) clipboardText = yield this._clipboardService.readText();
			if (this._state === 0) return;
			const model$1 = this._editor.getModel();
			let items = completions$1.items;
			if (existing) {
				const cmpFn = getSuggestionComparator(snippetSortOrder);
				items = items.concat(existing.items).sort(cmpFn);
			}
			const ctx$1 = new LineContext$1(model$1, this._editor.getPosition(), auto, context.shy, context.noSelect);
			this._completionModel = new CompletionModel(items, this._context.column, {
				leadingLineContent: ctx$1.leadingLineContent,
				characterCountDelta: ctx$1.column - this._context.column
			}, wordDistance$1, this._editor.getOption(108), this._editor.getOption(103), void 0, clipboardText);
			this._completionDisposables.add(completions$1.disposable);
			this._onNewContext(ctx$1);
			this._reportDurationsTelemetry(completions$1.durations);
		})).catch(onUnexpectedError);
	}
	_reportDurationsTelemetry(durations) {
		if (this._telemetryGate++ % 230 !== 0) return;
		setTimeout(() => {
			this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(durations) });
			this._logService.debug("suggest.durations.json", durations);
		});
	}
	static _createSuggestFilter(editor$1) {
		const result = /* @__PURE__ */ new Set();
		if (editor$1.getOption(103) === "none") result.add(27);
		const suggestOptions = editor$1.getOption(108);
		if (!suggestOptions.showMethods) result.add(0);
		if (!suggestOptions.showFunctions) result.add(1);
		if (!suggestOptions.showConstructors) result.add(2);
		if (!suggestOptions.showFields) result.add(3);
		if (!suggestOptions.showVariables) result.add(4);
		if (!suggestOptions.showClasses) result.add(5);
		if (!suggestOptions.showStructs) result.add(6);
		if (!suggestOptions.showInterfaces) result.add(7);
		if (!suggestOptions.showModules) result.add(8);
		if (!suggestOptions.showProperties) result.add(9);
		if (!suggestOptions.showEvents) result.add(10);
		if (!suggestOptions.showOperators) result.add(11);
		if (!suggestOptions.showUnits) result.add(12);
		if (!suggestOptions.showValues) result.add(13);
		if (!suggestOptions.showConstants) result.add(14);
		if (!suggestOptions.showEnums) result.add(15);
		if (!suggestOptions.showEnumMembers) result.add(16);
		if (!suggestOptions.showKeywords) result.add(17);
		if (!suggestOptions.showWords) result.add(18);
		if (!suggestOptions.showColors) result.add(19);
		if (!suggestOptions.showFiles) result.add(20);
		if (!suggestOptions.showReferences) result.add(21);
		if (!suggestOptions.showColors) result.add(22);
		if (!suggestOptions.showFolders) result.add(23);
		if (!suggestOptions.showTypeParameters) result.add(24);
		if (!suggestOptions.showSnippets) result.add(27);
		if (!suggestOptions.showUsers) result.add(25);
		if (!suggestOptions.showIssues) result.add(26);
		return {
			itemKind: result,
			showDeprecated: suggestOptions.showDeprecated
		};
	}
	_onNewContext(ctx) {
		if (!this._context) return;
		if (ctx.lineNumber !== this._context.lineNumber) {
			this.cancel();
			return;
		}
		if (getLeadingWhitespace(ctx.leadingLineContent) !== getLeadingWhitespace(this._context.leadingLineContent)) {
			this.cancel();
			return;
		}
		if (ctx.column < this._context.column) {
			if (ctx.leadingWord.word) this.trigger({
				auto: this._context.auto,
				shy: false,
				noSelect: false
			}, true);
			else this.cancel();
			return;
		}
		if (!this._completionModel) return;
		if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {
			const inactiveProvider = new Set(this._languageFeaturesService.completionProvider.all(this._editor.getModel()));
			for (const provider of this._completionModel.allProvider) inactiveProvider.delete(provider);
			const items = this._completionModel.adopt(/* @__PURE__ */ new Set());
			this.trigger({
				auto: this._context.auto,
				shy: false,
				noSelect: false
			}, true, inactiveProvider, {
				items,
				clipboardText: this._completionModel.clipboardText
			});
			return;
		}
		if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {
			const { incomplete } = this._completionModel;
			const items = this._completionModel.adopt(incomplete);
			this.trigger({
				auto: this._state === 2,
				shy: false,
				noSelect: false,
				triggerKind: 2
			}, true, incomplete, {
				items,
				clipboardText: this._completionModel.clipboardText
			});
		} else {
			const oldLineContext = this._completionModel.lineContext;
			let isFrozen = false;
			this._completionModel.lineContext = {
				leadingLineContent: ctx.leadingLineContent,
				characterCountDelta: ctx.column - this._context.column
			};
			if (this._completionModel.items.length === 0) {
				if (LineContext$1.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
					this.trigger({
						auto: this._context.auto,
						shy: false,
						noSelect: false
					}, true);
					return;
				}
				if (!this._context.auto) {
					this._completionModel.lineContext = oldLineContext;
					isFrozen = this._completionModel.items.length > 0;
					if (isFrozen && ctx.leadingWord.word.length === 0) {
						this.cancel();
						return;
					}
				} else {
					this.cancel();
					return;
				}
			}
			this._onDidSuggest.fire({
				completionModel: this._completionModel,
				auto: this._context.auto,
				shy: this._context.shy,
				noSelect: this._context.noSelect,
				isFrozen
			});
		}
	}
};
SuggestModel = __decorate$40([
	__param$40(1, IEditorWorkerService),
	__param$40(2, IClipboardService),
	__param$40(3, ITelemetryService),
	__param$40(4, ILogService),
	__param$40(5, IContextKeyService),
	__param$40(6, IConfigurationService),
	__param$40(7, ILanguageFeaturesService)
], SuggestModel);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestOvertypingCapturer.js
var OvertypingCapturer = class OvertypingCapturer {
	constructor(editor$1, suggestModel) {
		this._disposables = new DisposableStore();
		this._lastOvertyped = [];
		this._empty = true;
		this._disposables.add(editor$1.onWillType(() => {
			if (!this._empty) return;
			if (!editor$1.hasModel()) return;
			const selections = editor$1.getSelections();
			const selectionsLength = selections.length;
			let willOvertype = false;
			for (let i = 0; i < selectionsLength; i++) if (!selections[i].isEmpty()) {
				willOvertype = true;
				break;
			}
			if (!willOvertype) return;
			this._lastOvertyped = [];
			const model = editor$1.getModel();
			for (let i = 0; i < selectionsLength; i++) {
				const selection = selections[i];
				if (model.getValueLengthInRange(selection) > OvertypingCapturer._maxSelectionLength) return;
				this._lastOvertyped[i] = {
					value: model.getValueInRange(selection),
					multiline: selection.startLineNumber !== selection.endLineNumber
				};
			}
			this._empty = false;
		}));
		this._disposables.add(suggestModel.onDidCancel((e) => {
			if (!this._empty && !e.retrigger) this._empty = true;
		}));
	}
	getLastOvertypedInfo(idx) {
		if (!this._empty && idx >= 0 && idx < this._lastOvertyped.length) return this._lastOvertyped[idx];
	}
	dispose() {
		this._disposables.dispose();
	}
};
OvertypingCapturer._maxSelectionLength = 51200;

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js
var __decorate$39 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$39 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var StatusBarViewItem = class StatusBarViewItem extends MenuEntryActionViewItem {
	updateLabel() {
		const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
		if (!kb) return super.updateLabel();
		if (this.label) this.label.textContent = localize("ddd", "{0} ({1})", this._action.label, StatusBarViewItem.symbolPrintEnter(kb));
	}
	static symbolPrintEnter(kb) {
		var _a$5;
		return (_a$5 = kb.getLabel()) === null || _a$5 === void 0 ? void 0 : _a$5.replace(/\benter\b/gi, "");
	}
};
var SuggestWidgetStatus = class SuggestWidgetStatus$1 {
	constructor(container, instantiationService, _menuService, _contextKeyService) {
		this._menuService = _menuService;
		this._contextKeyService = _contextKeyService;
		this._menuDisposables = new DisposableStore();
		this.element = append(container, $(".suggest-status-bar"));
		const actionViewItemProvider = ((action) => {
			return action instanceof MenuItemAction ? instantiationService.createInstance(StatusBarViewItem, action, void 0) : void 0;
		});
		this._leftActions = new ActionBar(this.element, { actionViewItemProvider });
		this._rightActions = new ActionBar(this.element, { actionViewItemProvider });
		this._leftActions.domNode.classList.add("left");
		this._rightActions.domNode.classList.add("right");
	}
	dispose() {
		this._menuDisposables.dispose();
		this.element.remove();
	}
	show() {
		const menu = this._menuService.createMenu(suggestWidgetStatusbarMenu, this._contextKeyService);
		const renderMenu = () => {
			const left = [];
			const right = [];
			for (const [group, actions] of menu.getActions()) if (group === "left") left.push(...actions);
			else right.push(...actions);
			this._leftActions.clear();
			this._leftActions.push(left);
			this._rightActions.clear();
			this._rightActions.push(right);
		};
		this._menuDisposables.add(menu.onDidChange(() => renderMenu()));
		this._menuDisposables.add(menu);
	}
	hide() {
		this._menuDisposables.clear();
	}
};
SuggestWidgetStatus = __decorate$39([
	__param$39(1, IInstantiationService),
	__param$39(2, IMenuService),
	__param$39(3, IContextKeyService)
], SuggestWidgetStatus);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/browser/symbolIcons.js
const SYMBOL_ICON_ARRAY_FOREGROUND = registerColor("symbolIcon.arrayForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor("symbolIcon.booleanForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_CLASS_FOREGROUND = registerColor("symbolIcon.classForeground", {
	dark: "#EE9D28",
	light: "#D67E00",
	hcDark: "#EE9D28",
	hcLight: "#D67E00"
}, localize("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_COLOR_FOREGROUND = registerColor("symbolIcon.colorForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor("symbolIcon.constantForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor("symbolIcon.constructorForeground", {
	dark: "#B180D7",
	light: "#652D90",
	hcDark: "#B180D7",
	hcLight: "#652D90"
}, localize("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor("symbolIcon.enumeratorForeground", {
	dark: "#EE9D28",
	light: "#D67E00",
	hcDark: "#EE9D28",
	hcLight: "#D67E00"
}, localize("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor("symbolIcon.enumeratorMemberForeground", {
	dark: "#75BEFF",
	light: "#007ACC",
	hcDark: "#75BEFF",
	hcLight: "#007ACC"
}, localize("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_EVENT_FOREGROUND = registerColor("symbolIcon.eventForeground", {
	dark: "#EE9D28",
	light: "#D67E00",
	hcDark: "#EE9D28",
	hcLight: "#D67E00"
}, localize("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_FIELD_FOREGROUND = registerColor("symbolIcon.fieldForeground", {
	dark: "#75BEFF",
	light: "#007ACC",
	hcDark: "#75BEFF",
	hcLight: "#007ACC"
}, localize("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_FILE_FOREGROUND = registerColor("symbolIcon.fileForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_FOLDER_FOREGROUND = registerColor("symbolIcon.folderForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor("symbolIcon.functionForeground", {
	dark: "#B180D7",
	light: "#652D90",
	hcDark: "#B180D7",
	hcLight: "#652D90"
}, localize("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor("symbolIcon.interfaceForeground", {
	dark: "#75BEFF",
	light: "#007ACC",
	hcDark: "#75BEFF",
	hcLight: "#007ACC"
}, localize("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_KEY_FOREGROUND = registerColor("symbolIcon.keyForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor("symbolIcon.keywordForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_METHOD_FOREGROUND = registerColor("symbolIcon.methodForeground", {
	dark: "#B180D7",
	light: "#652D90",
	hcDark: "#B180D7",
	hcLight: "#652D90"
}, localize("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_MODULE_FOREGROUND = registerColor("symbolIcon.moduleForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor("symbolIcon.namespaceForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_NULL_FOREGROUND = registerColor("symbolIcon.nullForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_NUMBER_FOREGROUND = registerColor("symbolIcon.numberForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_OBJECT_FOREGROUND = registerColor("symbolIcon.objectForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor("symbolIcon.operatorForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor("symbolIcon.packageForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor("symbolIcon.propertyForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor("symbolIcon.referenceForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor("symbolIcon.snippetForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_STRING_FOREGROUND = registerColor("symbolIcon.stringForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_STRUCT_FOREGROUND = registerColor("symbolIcon.structForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_TEXT_FOREGROUND = registerColor("symbolIcon.textForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor("symbolIcon.typeParameterForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_UNIT_FOREGROUND = registerColor("symbolIcon.unitForeground", {
	dark: foreground,
	light: foreground,
	hcDark: foreground,
	hcLight: foreground
}, localize("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor("symbolIcon.variableForeground", {
	dark: "#75BEFF",
	light: "#007ACC",
	hcDark: "#75BEFF",
	hcLight: "#007ACC"
}, localize("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
registerThemingParticipant((theme, collector) => {
	const symbolIconArrayColor = theme.getColor(SYMBOL_ICON_ARRAY_FOREGROUND);
	if (symbolIconArrayColor) collector.addRule(`${Codicon.symbolArray.cssSelector} { color: ${symbolIconArrayColor}; }`);
	const symbolIconBooleanColor = theme.getColor(SYMBOL_ICON_BOOLEAN_FOREGROUND);
	if (symbolIconBooleanColor) collector.addRule(`${Codicon.symbolBoolean.cssSelector} { color: ${symbolIconBooleanColor}; }`);
	const symbolIconClassColor = theme.getColor(SYMBOL_ICON_CLASS_FOREGROUND);
	if (symbolIconClassColor) collector.addRule(`${Codicon.symbolClass.cssSelector} { color: ${symbolIconClassColor}; }`);
	const symbolIconMethodColor = theme.getColor(SYMBOL_ICON_METHOD_FOREGROUND);
	if (symbolIconMethodColor) collector.addRule(`${Codicon.symbolMethod.cssSelector} { color: ${symbolIconMethodColor}; }`);
	const symbolIconColorColor = theme.getColor(SYMBOL_ICON_COLOR_FOREGROUND);
	if (symbolIconColorColor) collector.addRule(`${Codicon.symbolColor.cssSelector} { color: ${symbolIconColorColor}; }`);
	const symbolIconConstantColor = theme.getColor(SYMBOL_ICON_CONSTANT_FOREGROUND);
	if (symbolIconConstantColor) collector.addRule(`${Codicon.symbolConstant.cssSelector} { color: ${symbolIconConstantColor}; }`);
	const symbolIconConstructorColor = theme.getColor(SYMBOL_ICON_CONSTRUCTOR_FOREGROUND);
	if (symbolIconConstructorColor) collector.addRule(`${Codicon.symbolConstructor.cssSelector} { color: ${symbolIconConstructorColor}; }`);
	const symbolIconEnumeratorColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_FOREGROUND);
	if (symbolIconEnumeratorColor) collector.addRule(`
			${Codicon.symbolValue.cssSelector},${Codicon.symbolEnum.cssSelector} { color: ${symbolIconEnumeratorColor}; }`);
	const symbolIconEnumeratorMemberColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND);
	if (symbolIconEnumeratorMemberColor) collector.addRule(`${Codicon.symbolEnumMember.cssSelector} { color: ${symbolIconEnumeratorMemberColor}; }`);
	const symbolIconEventColor = theme.getColor(SYMBOL_ICON_EVENT_FOREGROUND);
	if (symbolIconEventColor) collector.addRule(`${Codicon.symbolEvent.cssSelector} { color: ${symbolIconEventColor}; }`);
	const symbolIconFieldColor = theme.getColor(SYMBOL_ICON_FIELD_FOREGROUND);
	if (symbolIconFieldColor) collector.addRule(`${Codicon.symbolField.cssSelector} { color: ${symbolIconFieldColor}; }`);
	const symbolIconFileColor = theme.getColor(SYMBOL_ICON_FILE_FOREGROUND);
	if (symbolIconFileColor) collector.addRule(`${Codicon.symbolFile.cssSelector} { color: ${symbolIconFileColor}; }`);
	const symbolIconFolderColor = theme.getColor(SYMBOL_ICON_FOLDER_FOREGROUND);
	if (symbolIconFolderColor) collector.addRule(`${Codicon.symbolFolder.cssSelector} { color: ${symbolIconFolderColor}; }`);
	const symbolIconFunctionColor = theme.getColor(SYMBOL_ICON_FUNCTION_FOREGROUND);
	if (symbolIconFunctionColor) collector.addRule(`${Codicon.symbolFunction.cssSelector} { color: ${symbolIconFunctionColor}; }`);
	const symbolIconInterfaceColor = theme.getColor(SYMBOL_ICON_INTERFACE_FOREGROUND);
	if (symbolIconInterfaceColor) collector.addRule(`${Codicon.symbolInterface.cssSelector} { color: ${symbolIconInterfaceColor}; }`);
	const symbolIconKeyColor = theme.getColor(SYMBOL_ICON_KEY_FOREGROUND);
	if (symbolIconKeyColor) collector.addRule(`${Codicon.symbolKey.cssSelector} { color: ${symbolIconKeyColor}; }`);
	const symbolIconKeywordColor = theme.getColor(SYMBOL_ICON_KEYWORD_FOREGROUND);
	if (symbolIconKeywordColor) collector.addRule(`${Codicon.symbolKeyword.cssSelector} { color: ${symbolIconKeywordColor}; }`);
	const symbolIconModuleColor = theme.getColor(SYMBOL_ICON_MODULE_FOREGROUND);
	if (symbolIconModuleColor) collector.addRule(`${Codicon.symbolModule.cssSelector} { color: ${symbolIconModuleColor}; }`);
	const outlineNamespaceColor = theme.getColor(SYMBOL_ICON_NAMESPACE_FOREGROUND);
	if (outlineNamespaceColor) collector.addRule(`${Codicon.symbolNamespace.cssSelector} { color: ${outlineNamespaceColor}; }`);
	const symbolIconNullColor = theme.getColor(SYMBOL_ICON_NULL_FOREGROUND);
	if (symbolIconNullColor) collector.addRule(`${Codicon.symbolNull.cssSelector} { color: ${symbolIconNullColor}; }`);
	const symbolIconNumberColor = theme.getColor(SYMBOL_ICON_NUMBER_FOREGROUND);
	if (symbolIconNumberColor) collector.addRule(`${Codicon.symbolNumber.cssSelector} { color: ${symbolIconNumberColor}; }`);
	const symbolIconObjectColor = theme.getColor(SYMBOL_ICON_OBJECT_FOREGROUND);
	if (symbolIconObjectColor) collector.addRule(`${Codicon.symbolObject.cssSelector} { color: ${symbolIconObjectColor}; }`);
	const symbolIconOperatorColor = theme.getColor(SYMBOL_ICON_OPERATOR_FOREGROUND);
	if (symbolIconOperatorColor) collector.addRule(`${Codicon.symbolOperator.cssSelector} { color: ${symbolIconOperatorColor}; }`);
	const symbolIconPackageColor = theme.getColor(SYMBOL_ICON_PACKAGE_FOREGROUND);
	if (symbolIconPackageColor) collector.addRule(`${Codicon.symbolPackage.cssSelector} { color: ${symbolIconPackageColor}; }`);
	const symbolIconPropertyColor = theme.getColor(SYMBOL_ICON_PROPERTY_FOREGROUND);
	if (symbolIconPropertyColor) collector.addRule(`${Codicon.symbolProperty.cssSelector} { color: ${symbolIconPropertyColor}; }`);
	const symbolIconReferenceColor = theme.getColor(SYMBOL_ICON_REFERENCE_FOREGROUND);
	if (symbolIconReferenceColor) collector.addRule(`${Codicon.symbolReference.cssSelector} { color: ${symbolIconReferenceColor}; }`);
	const symbolIconSnippetColor = theme.getColor(SYMBOL_ICON_SNIPPET_FOREGROUND);
	if (symbolIconSnippetColor) collector.addRule(`${Codicon.symbolSnippet.cssSelector} { color: ${symbolIconSnippetColor}; }`);
	const symbolIconStringColor = theme.getColor(SYMBOL_ICON_STRING_FOREGROUND);
	if (symbolIconStringColor) collector.addRule(`${Codicon.symbolString.cssSelector} { color: ${symbolIconStringColor}; }`);
	const symbolIconStructColor = theme.getColor(SYMBOL_ICON_STRUCT_FOREGROUND);
	if (symbolIconStructColor) collector.addRule(`${Codicon.symbolStruct.cssSelector} { color: ${symbolIconStructColor}; }`);
	const symbolIconTextColor = theme.getColor(SYMBOL_ICON_TEXT_FOREGROUND);
	if (symbolIconTextColor) collector.addRule(`${Codicon.symbolText.cssSelector} { color: ${symbolIconTextColor}; }`);
	const symbolIconTypeParameterColor = theme.getColor(SYMBOL_ICON_TYPEPARAMETER_FOREGROUND);
	if (symbolIconTypeParameterColor) collector.addRule(`${Codicon.symbolTypeParameter.cssSelector} { color: ${symbolIconTypeParameterColor}; }`);
	const symbolIconUnitColor = theme.getColor(SYMBOL_ICON_UNIT_FOREGROUND);
	if (symbolIconUnitColor) collector.addRule(`${Codicon.symbolUnit.cssSelector} { color: ${symbolIconUnitColor}; }`);
	const symbolIconVariableColor = theme.getColor(SYMBOL_ICON_VARIABLE_FOREGROUND);
	if (symbolIconVariableColor) collector.addRule(`${Codicon.symbolVariable.cssSelector} { color: ${symbolIconVariableColor}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/browser/ui/resizable/resizable.js
var ResizableHTMLElement = class {
	constructor() {
		this._onDidWillResize = new Emitter$1();
		this.onDidWillResize = this._onDidWillResize.event;
		this._onDidResize = new Emitter$1();
		this.onDidResize = this._onDidResize.event;
		this._sashListener = new DisposableStore();
		this._size = new Dimension(0, 0);
		this._minSize = new Dimension(0, 0);
		this._maxSize = new Dimension(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
		this.domNode = document.createElement("div");
		this._eastSash = new Sash(this.domNode, { getVerticalSashLeft: () => this._size.width }, { orientation: 0 });
		this._westSash = new Sash(this.domNode, { getVerticalSashLeft: () => 0 }, { orientation: 0 });
		this._northSash = new Sash(this.domNode, { getHorizontalSashTop: () => 0 }, {
			orientation: 1,
			orthogonalEdge: OrthogonalEdge.North
		});
		this._southSash = new Sash(this.domNode, { getHorizontalSashTop: () => this._size.height }, {
			orientation: 1,
			orthogonalEdge: OrthogonalEdge.South
		});
		this._northSash.orthogonalStartSash = this._westSash;
		this._northSash.orthogonalEndSash = this._eastSash;
		this._southSash.orthogonalStartSash = this._westSash;
		this._southSash.orthogonalEndSash = this._eastSash;
		let currentSize;
		let deltaY = 0;
		let deltaX = 0;
		this._sashListener.add(Event.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
			if (currentSize === void 0) {
				this._onDidWillResize.fire();
				currentSize = this._size;
				deltaY = 0;
				deltaX = 0;
			}
		}));
		this._sashListener.add(Event.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
			if (currentSize !== void 0) {
				currentSize = void 0;
				deltaY = 0;
				deltaX = 0;
				this._onDidResize.fire({
					dimension: this._size,
					done: true
				});
			}
		}));
		this._sashListener.add(this._eastSash.onDidChange((e) => {
			if (currentSize) {
				deltaX = e.currentX - e.startX;
				this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
				this._onDidResize.fire({
					dimension: this._size,
					done: false,
					east: true
				});
			}
		}));
		this._sashListener.add(this._westSash.onDidChange((e) => {
			if (currentSize) {
				deltaX = -(e.currentX - e.startX);
				this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
				this._onDidResize.fire({
					dimension: this._size,
					done: false,
					west: true
				});
			}
		}));
		this._sashListener.add(this._northSash.onDidChange((e) => {
			if (currentSize) {
				deltaY = -(e.currentY - e.startY);
				this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
				this._onDidResize.fire({
					dimension: this._size,
					done: false,
					north: true
				});
			}
		}));
		this._sashListener.add(this._southSash.onDidChange((e) => {
			if (currentSize) {
				deltaY = e.currentY - e.startY;
				this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
				this._onDidResize.fire({
					dimension: this._size,
					done: false,
					south: true
				});
			}
		}));
		this._sashListener.add(Event.any(this._eastSash.onDidReset, this._westSash.onDidReset)((e) => {
			if (this._preferredSize) {
				this.layout(this._size.height, this._preferredSize.width);
				this._onDidResize.fire({
					dimension: this._size,
					done: true
				});
			}
		}));
		this._sashListener.add(Event.any(this._northSash.onDidReset, this._southSash.onDidReset)((e) => {
			if (this._preferredSize) {
				this.layout(this._preferredSize.height, this._size.width);
				this._onDidResize.fire({
					dimension: this._size,
					done: true
				});
			}
		}));
	}
	dispose() {
		this._northSash.dispose();
		this._southSash.dispose();
		this._eastSash.dispose();
		this._westSash.dispose();
		this._sashListener.dispose();
		this._onDidResize.dispose();
		this._onDidWillResize.dispose();
		this.domNode.remove();
	}
	enableSashes(north, east, south, west) {
		this._northSash.state = north ? 3 : 0;
		this._eastSash.state = east ? 3 : 0;
		this._southSash.state = south ? 3 : 0;
		this._westSash.state = west ? 3 : 0;
	}
	layout(height = this.size.height, width = this.size.width) {
		const { height: minHeight, width: minWidth } = this._minSize;
		const { height: maxHeight, width: maxWidth } = this._maxSize;
		height = Math.max(minHeight, Math.min(maxHeight, height));
		width = Math.max(minWidth, Math.min(maxWidth, width));
		const newSize = new Dimension(width, height);
		if (!Dimension.equals(newSize, this._size)) {
			this.domNode.style.height = height + "px";
			this.domNode.style.width = width + "px";
			this._size = newSize;
			this._northSash.layout();
			this._eastSash.layout();
			this._southSash.layout();
			this._westSash.layout();
		}
	}
	clearSashHoverState() {
		this._eastSash.clearSashHoverState();
		this._westSash.clearSashHoverState();
		this._northSash.clearSashHoverState();
		this._southSash.clearSashHoverState();
	}
	get size() {
		return this._size;
	}
	set maxSize(value) {
		this._maxSize = value;
	}
	get maxSize() {
		return this._maxSize;
	}
	set minSize(value) {
		this._minSize = value;
	}
	get minSize() {
		return this._minSize;
	}
	set preferredSize(value) {
		this._preferredSize = value;
	}
	get preferredSize() {
		return this._preferredSize;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js
var __decorate$38 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$38 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
function canExpandCompletionItem(item) {
	return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);
}
var SuggestDetailsWidget = class SuggestDetailsWidget$1 {
	constructor(_editor, instaService) {
		this._editor = _editor;
		this._onDidClose = new Emitter$1();
		this.onDidClose = this._onDidClose.event;
		this._onDidChangeContents = new Emitter$1();
		this.onDidChangeContents = this._onDidChangeContents.event;
		this._disposables = new DisposableStore();
		this._renderDisposeable = new DisposableStore();
		this._borderWidth = 1;
		this._size = new Dimension(330, 0);
		this.domNode = $(".suggest-details");
		this.domNode.classList.add("no-docs");
		this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor });
		this._body = $(".body");
		this._scrollbar = new DomScrollableElement(this._body, { alwaysConsumeMouseWheel: true });
		append(this.domNode, this._scrollbar.getDomNode());
		this._disposables.add(this._scrollbar);
		this._header = append(this._body, $(".header"));
		this._close = append(this._header, $("span" + Codicon.close.cssSelector));
		this._close.title = localize("details.close", "Close");
		this._type = append(this._header, $("p.type"));
		this._docs = append(this._body, $("p.docs"));
		this._configureFont();
		this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(46)) this._configureFont();
		}));
	}
	dispose() {
		this._disposables.dispose();
		this._renderDisposeable.dispose();
	}
	_configureFont() {
		const options = this._editor.getOptions();
		const fontInfo = options.get(46);
		const fontFamily = fontInfo.getMassagedFontFamily();
		const fontSize = options.get(109) || fontInfo.fontSize;
		const lineHeight = options.get(110) || fontInfo.lineHeight;
		const fontWeight = fontInfo.fontWeight;
		const fontSizePx = `${fontSize}px`;
		const lineHeightPx = `${lineHeight}px`;
		this.domNode.style.fontSize = fontSizePx;
		this.domNode.style.lineHeight = `${lineHeight / fontSize}`;
		this.domNode.style.fontWeight = fontWeight;
		this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
		this._type.style.fontFamily = fontFamily;
		this._close.style.height = lineHeightPx;
		this._close.style.width = lineHeightPx;
	}
	getLayoutInfo() {
		const lineHeight = this._editor.getOption(110) || this._editor.getOption(46).lineHeight;
		const borderWidth = this._borderWidth;
		return {
			lineHeight,
			borderWidth,
			borderHeight: borderWidth * 2,
			verticalPadding: 22,
			horizontalPadding: 14
		};
	}
	renderLoading() {
		this._type.textContent = localize("loading", "Loading...");
		this._docs.textContent = "";
		this.domNode.classList.remove("no-docs", "no-type");
		this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);
		this._onDidChangeContents.fire(this);
	}
	renderItem(item, explainMode) {
		var _a$5, _b$1;
		this._renderDisposeable.clear();
		let { detail, documentation } = item.completion;
		if (explainMode) {
			let md = "";
			md += `score: ${item.score[0]}\n`;
			md += `prefix: ${(_a$5 = item.word) !== null && _a$5 !== void 0 ? _a$5 : "(no prefix)"}\n`;
			md += `word: ${item.completion.filterText ? item.completion.filterText + " (filterText)" : item.textLabel}\n`;
			md += `distance: ${item.distance} (localityBonus-setting)\n`;
			md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || "label"}\n`;
			md += `commit_chars: ${(_b$1 = item.completion.commitCharacters) === null || _b$1 === void 0 ? void 0 : _b$1.join("")}\n`;
			documentation = new MarkdownString().appendCodeblock("empty", md);
			detail = `Provider: ${item.provider._debugDisplayName}`;
		}
		if (!explainMode && !canExpandCompletionItem(item)) {
			this.clearContents();
			return;
		}
		this.domNode.classList.remove("no-docs", "no-type");
		if (detail) {
			const cappedDetail = detail.length > 1e5 ? `${detail.substr(0, 1e5)}` : detail;
			this._type.textContent = cappedDetail;
			this._type.title = cappedDetail;
			show(this._type);
			this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gim.test(cappedDetail));
		} else {
			clearNode(this._type);
			this._type.title = "";
			hide(this._type);
			this.domNode.classList.add("no-type");
		}
		clearNode(this._docs);
		if (typeof documentation === "string") {
			this._docs.classList.remove("markdown-docs");
			this._docs.textContent = documentation;
		} else if (documentation) {
			this._docs.classList.add("markdown-docs");
			clearNode(this._docs);
			const renderedContents = this._markdownRenderer.render(documentation);
			this._docs.appendChild(renderedContents.element);
			this._renderDisposeable.add(renderedContents);
			this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
				this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
				this._onDidChangeContents.fire(this);
			}));
		}
		this.domNode.style.userSelect = "text";
		this.domNode.tabIndex = -1;
		this._close.onmousedown = (e) => {
			e.preventDefault();
			e.stopPropagation();
		};
		this._close.onclick = (e) => {
			e.preventDefault();
			e.stopPropagation();
			this._onDidClose.fire();
		};
		this._body.scrollTop = 0;
		this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
		this._onDidChangeContents.fire(this);
	}
	clearContents() {
		this.domNode.classList.add("no-docs");
		this._type.textContent = "";
		this._docs.textContent = "";
	}
	get size() {
		return this._size;
	}
	layout(width, height) {
		const newSize = new Dimension(width, height);
		if (!Dimension.equals(newSize, this._size)) {
			this._size = newSize;
			size(this.domNode, width, height);
		}
		this._scrollbar.scanDomNode();
	}
	scrollDown(much = 8) {
		this._body.scrollTop += much;
	}
	scrollUp(much = 8) {
		this._body.scrollTop -= much;
	}
	scrollTop() {
		this._body.scrollTop = 0;
	}
	scrollBottom() {
		this._body.scrollTop = this._body.scrollHeight;
	}
	pageDown() {
		this.scrollDown(80);
	}
	pageUp() {
		this.scrollUp(80);
	}
	set borderWidth(width) {
		this._borderWidth = width;
	}
	get borderWidth() {
		return this._borderWidth;
	}
};
SuggestDetailsWidget = __decorate$38([__param$38(1, IInstantiationService)], SuggestDetailsWidget);
var SuggestDetailsOverlay = class {
	constructor(widget, _editor) {
		this.widget = widget;
		this._editor = _editor;
		this._disposables = new DisposableStore();
		this._added = false;
		this._preferAlignAtTop = true;
		this._resizable = new ResizableHTMLElement();
		this._resizable.domNode.classList.add("suggest-details-container");
		this._resizable.domNode.appendChild(widget.domNode);
		this._resizable.enableSashes(false, true, true, false);
		let topLeftNow;
		let sizeNow;
		let deltaTop = 0;
		let deltaLeft = 0;
		this._disposables.add(this._resizable.onDidWillResize(() => {
			topLeftNow = this._topLeft;
			sizeNow = this._resizable.size;
		}));
		this._disposables.add(this._resizable.onDidResize((e) => {
			if (topLeftNow && sizeNow) {
				this.widget.layout(e.dimension.width, e.dimension.height);
				let updateTopLeft = false;
				if (e.west) {
					deltaLeft = sizeNow.width - e.dimension.width;
					updateTopLeft = true;
				}
				if (e.north) {
					deltaTop = sizeNow.height - e.dimension.height;
					updateTopLeft = true;
				}
				if (updateTopLeft) this._applyTopLeft({
					top: topLeftNow.top + deltaTop,
					left: topLeftNow.left + deltaLeft
				});
			}
			if (e.done) {
				topLeftNow = void 0;
				sizeNow = void 0;
				deltaTop = 0;
				deltaLeft = 0;
				this._userSize = e.dimension;
			}
		}));
		this._disposables.add(this.widget.onDidChangeContents(() => {
			var _a$5;
			if (this._anchorBox) this._placeAtAnchor(this._anchorBox, (_a$5 = this._userSize) !== null && _a$5 !== void 0 ? _a$5 : this.widget.size, this._preferAlignAtTop);
		}));
	}
	dispose() {
		this._resizable.dispose();
		this._disposables.dispose();
		this.hide();
	}
	getId() {
		return "suggest.details";
	}
	getDomNode() {
		return this._resizable.domNode;
	}
	getPosition() {
		return null;
	}
	show() {
		if (!this._added) {
			this._editor.addOverlayWidget(this);
			this.getDomNode().style.position = "fixed";
			this._added = true;
		}
	}
	hide(sessionEnded = false) {
		this._resizable.clearSashHoverState();
		if (this._added) {
			this._editor.removeOverlayWidget(this);
			this._added = false;
			this._anchorBox = void 0;
			this._topLeft = void 0;
		}
		if (sessionEnded) {
			this._userSize = void 0;
			this.widget.clearContents();
		}
	}
	placeAtAnchor(anchor, preferAlignAtTop) {
		var _a$5;
		this._anchorBox = anchor.getBoundingClientRect();
		this._preferAlignAtTop = preferAlignAtTop;
		this._placeAtAnchor(this._anchorBox, (_a$5 = this._userSize) !== null && _a$5 !== void 0 ? _a$5 : this.widget.size, preferAlignAtTop);
	}
	_placeAtAnchor(anchorBox, size$1, preferAlignAtTop) {
		var _a$5;
		const bodyBox = getClientArea(document.body);
		const info = this.widget.getLayoutInfo();
		const defaultMinSize = new Dimension(220, 2 * info.lineHeight);
		const defaultTop = anchorBox.top;
		const eastPlacement = (function() {
			const width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);
			const left = -info.borderWidth + anchorBox.left + anchorBox.width;
			const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
			const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
			return {
				top: defaultTop,
				left,
				fit: width - size$1.width,
				maxSizeTop,
				maxSizeBottom,
				minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width))
			};
		})();
		const placements = [
			eastPlacement,
			(function() {
				const width = anchorBox.left - info.borderWidth - info.horizontalPadding;
				const left = Math.max(info.horizontalPadding, anchorBox.left - size$1.width - info.borderWidth);
				const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
				const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
				return {
					top: defaultTop,
					left,
					fit: width - size$1.width,
					maxSizeTop,
					maxSizeBottom,
					minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width))
				};
			})(),
			(function() {
				const left = anchorBox.left;
				const top = -info.borderWidth + anchorBox.top + anchorBox.height;
				const maxSizeBottom = new Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);
				return {
					top,
					left,
					fit: maxSizeBottom.height - size$1.height,
					maxSizeBottom,
					maxSizeTop: maxSizeBottom,
					minSize: defaultMinSize.with(maxSizeBottom.width)
				};
			})()
		];
		const placement = (_a$5 = placements.find((p) => p.fit >= 0)) !== null && _a$5 !== void 0 ? _a$5 : placements.sort((a, b) => b.fit - a.fit)[0];
		const bottom = anchorBox.top + anchorBox.height - info.borderHeight;
		let alignAtTop;
		let height = size$1.height;
		const maxHeight = Math.max(placement.maxSizeTop.height, placement.maxSizeBottom.height);
		if (height > maxHeight) height = maxHeight;
		let maxSize;
		if (preferAlignAtTop) if (height <= placement.maxSizeTop.height) {
			alignAtTop = true;
			maxSize = placement.maxSizeTop;
		} else {
			alignAtTop = false;
			maxSize = placement.maxSizeBottom;
		}
		else if (height <= placement.maxSizeBottom.height) {
			alignAtTop = false;
			maxSize = placement.maxSizeBottom;
		} else {
			alignAtTop = true;
			maxSize = placement.maxSizeTop;
		}
		this._applyTopLeft({
			left: placement.left,
			top: alignAtTop ? placement.top : bottom - height
		});
		this.getDomNode().style.position = "fixed";
		this._resizable.enableSashes(!alignAtTop, placement === eastPlacement, alignAtTop, placement !== eastPlacement);
		this._resizable.minSize = placement.minSize;
		this._resizable.maxSize = maxSize;
		this._resizable.layout(height, Math.min(maxSize.width, size$1.width));
		this.widget.layout(this._resizable.size.width, this._resizable.size.height);
	}
	_applyTopLeft(topLeft) {
		this._topLeft = topLeft;
		this.getDomNode().style.left = `${this._topLeft.left}px`;
		this.getDomNode().style.top = `${this._topLeft.top}px`;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/files/common/files.js
var FileKind;
(function(FileKind$1) {
	FileKind$1[FileKind$1["FILE"] = 0] = "FILE";
	FileKind$1[FileKind$1["FOLDER"] = 1] = "FOLDER";
	FileKind$1[FileKind$1["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
var fileIconDirectoryRegex = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
function getIconClasses(modelService, languageService, resource, fileKind) {
	const classes = fileKind === FileKind.ROOT_FOLDER ? ["rootfolder-icon"] : fileKind === FileKind.FOLDER ? ["folder-icon"] : ["file-icon"];
	if (resource) {
		let name;
		if (resource.scheme === Schemas.data) name = DataUri.parseMetaData(resource).get(DataUri.META_DATA_LABEL);
		else {
			const match = resource.path.match(fileIconDirectoryRegex);
			if (match) {
				name = cssEscape(match[2].toLowerCase());
				if (match[1]) classes.push(`${cssEscape(match[1].toLowerCase())}-name-dir-icon`);
			} else name = cssEscape(resource.authority.toLowerCase());
		}
		if (fileKind === FileKind.FOLDER) classes.push(`${name}-name-folder-icon`);
		else {
			if (name) {
				classes.push(`${name}-name-file-icon`);
				classes.push(`name-file-icon`);
				if (name.length <= 255) {
					const dotSegments = name.split(".");
					for (let i = 1; i < dotSegments.length; i++) classes.push(`${dotSegments.slice(i).join(".")}-ext-file-icon`);
				}
				classes.push(`ext-file-icon`);
			}
			const detectedLanguageId = detectLanguageId(modelService, languageService, resource);
			if (detectedLanguageId) classes.push(`${cssEscape(detectedLanguageId)}-lang-file-icon`);
		}
	}
	return classes;
}
function detectLanguageId(modelService, languageService, resource) {
	if (!resource) return null;
	let languageId = null;
	if (resource.scheme === Schemas.data) {
		const mime = DataUri.parseMetaData(resource).get(DataUri.META_DATA_MIME);
		if (mime) languageId = languageService.getLanguageIdByMimeType(mime);
	} else {
		const model = modelService.getModel(resource);
		if (model) languageId = model.getLanguageId();
	}
	if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) return languageId;
	return languageService.guessLanguageIdByFilepathOrFirstLine(resource);
}
function cssEscape(str) {
	return str.replace(/[\11\12\14\15\40]/g, "/");
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js
var __decorate$37 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$37 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var _a$2;
function getAriaId(index) {
	return `suggest-aria-id:${index}`;
}
const suggestMoreInfoIcon = registerIcon("suggest-more-info", Codicon.chevronRight, localize("suggestMoreInfoIcon", "Icon for more information in the suggest widget."));
var _completionItemColor = new (_a$2 = class ColorExtractor {
	extract(item, out) {
		if (item.textLabel.match(ColorExtractor._regexStrict)) {
			out[0] = item.textLabel;
			return true;
		}
		if (item.completion.detail && item.completion.detail.match(ColorExtractor._regexStrict)) {
			out[0] = item.completion.detail;
			return true;
		}
		if (typeof item.completion.documentation === "string") {
			const match = ColorExtractor._regexRelaxed.exec(item.completion.documentation);
			if (match && (match.index === 0 || match.index + match[0].length === item.completion.documentation.length)) {
				out[0] = match[0];
				return true;
			}
		}
		return false;
	}
}, _a$2._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, _a$2._regexStrict = new RegExp(`^${_a$2._regexRelaxed.source}$`, "i"), _a$2)();
var ItemRenderer = class ItemRenderer$1 {
	constructor(_editor, _modelService, _languageService, _themeService) {
		this._editor = _editor;
		this._modelService = _modelService;
		this._languageService = _languageService;
		this._themeService = _themeService;
		this._onDidToggleDetails = new Emitter$1();
		this.onDidToggleDetails = this._onDidToggleDetails.event;
		this.templateId = "suggestion";
	}
	dispose() {
		this._onDidToggleDetails.dispose();
	}
	renderTemplate(container) {
		const data = Object.create(null);
		data.disposables = new DisposableStore();
		data.root = container;
		data.root.classList.add("show-file-icons");
		data.icon = append(container, $(".icon"));
		data.colorspan = append(data.icon, $("span.colorspan"));
		const main = append(append(container, $(".contents")), $(".main"));
		data.iconContainer = append(main, $(".icon-label.codicon"));
		data.left = append(main, $("span.left"));
		data.right = append(main, $("span.right"));
		data.iconLabel = new IconLabel(data.left, {
			supportHighlights: true,
			supportIcons: true
		});
		data.disposables.add(data.iconLabel);
		data.parametersLabel = append(data.left, $("span.signature-label"));
		data.qualifierLabel = append(data.left, $("span.qualifier-label"));
		data.detailsLabel = append(data.right, $("span.details-label"));
		data.readMore = append(data.right, $("span.readMore" + ThemeIcon.asCSSSelector(suggestMoreInfoIcon)));
		data.readMore.title = localize("readMore", "Read More");
		const configureFont = () => {
			const options = this._editor.getOptions();
			const fontInfo = options.get(46);
			const fontFamily = fontInfo.getMassagedFontFamily();
			const fontFeatureSettings = fontInfo.fontFeatureSettings;
			const fontSize = options.get(109) || fontInfo.fontSize;
			const lineHeight = options.get(110) || fontInfo.lineHeight;
			const fontWeight = fontInfo.fontWeight;
			const letterSpacing = fontInfo.letterSpacing;
			const fontSizePx = `${fontSize}px`;
			const lineHeightPx = `${lineHeight}px`;
			const letterSpacingPx = `${letterSpacing}px`;
			data.root.style.fontSize = fontSizePx;
			data.root.style.fontWeight = fontWeight;
			data.root.style.letterSpacing = letterSpacingPx;
			main.style.fontFamily = fontFamily;
			main.style.fontFeatureSettings = fontFeatureSettings;
			main.style.lineHeight = lineHeightPx;
			data.icon.style.height = lineHeightPx;
			data.icon.style.width = lineHeightPx;
			data.readMore.style.height = lineHeightPx;
			data.readMore.style.width = lineHeightPx;
		};
		configureFont();
		data.disposables.add(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(46) || e.hasChanged(109) || e.hasChanged(110)) configureFont();
		}));
		return data;
	}
	renderElement(element, index, data) {
		const { completion } = element;
		data.root.id = getAriaId(index);
		data.colorspan.style.backgroundColor = "";
		const labelOptions = {
			labelEscapeNewLines: true,
			matches: createMatches(element.score)
		};
		const color = [];
		if (completion.kind === 19 && _completionItemColor.extract(element, color)) {
			data.icon.className = "icon customcolor";
			data.iconContainer.className = "icon hide";
			data.colorspan.style.backgroundColor = color[0];
		} else if (completion.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
			data.icon.className = "icon hide";
			data.iconContainer.className = "icon hide";
			const labelClasses = getIconClasses(this._modelService, this._languageService, URI.from({
				scheme: "fake",
				path: element.textLabel
			}), FileKind.FILE);
			const detailClasses = getIconClasses(this._modelService, this._languageService, URI.from({
				scheme: "fake",
				path: completion.detail
			}), FileKind.FILE);
			labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;
		} else if (completion.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons) {
			data.icon.className = "icon hide";
			data.iconContainer.className = "icon hide";
			labelOptions.extraClasses = [getIconClasses(this._modelService, this._languageService, URI.from({
				scheme: "fake",
				path: element.textLabel
			}), FileKind.FOLDER), getIconClasses(this._modelService, this._languageService, URI.from({
				scheme: "fake",
				path: completion.detail
			}), FileKind.FOLDER)].flat();
		} else {
			data.icon.className = "icon hide";
			data.iconContainer.className = "";
			data.iconContainer.classList.add("suggest-icon", ...CSSIcon.asClassNameArray(CompletionItemKinds.toIcon(completion.kind)));
		}
		if (completion.tags && completion.tags.indexOf(1) >= 0) {
			labelOptions.extraClasses = (labelOptions.extraClasses || []).concat(["deprecated"]);
			labelOptions.matches = [];
		}
		data.iconLabel.setLabel(element.textLabel, void 0, labelOptions);
		if (typeof completion.label === "string") {
			data.parametersLabel.textContent = "";
			data.detailsLabel.textContent = stripNewLines(completion.detail || "");
			data.root.classList.add("string-label");
		} else {
			data.parametersLabel.textContent = stripNewLines(completion.label.detail || "");
			data.detailsLabel.textContent = stripNewLines(completion.label.description || "");
			data.root.classList.remove("string-label");
		}
		if (this._editor.getOption(108).showInlineDetails) show(data.detailsLabel);
		else hide(data.detailsLabel);
		if (canExpandCompletionItem(element)) {
			data.right.classList.add("can-expand-details");
			show(data.readMore);
			data.readMore.onmousedown = (e) => {
				e.stopPropagation();
				e.preventDefault();
			};
			data.readMore.onclick = (e) => {
				e.stopPropagation();
				e.preventDefault();
				this._onDidToggleDetails.fire();
			};
		} else {
			data.right.classList.remove("can-expand-details");
			hide(data.readMore);
			data.readMore.onmousedown = null;
			data.readMore.onclick = null;
		}
	}
	disposeTemplate(templateData) {
		templateData.disposables.dispose();
	}
};
ItemRenderer = __decorate$37([
	__param$37(1, IModelService),
	__param$37(2, ILanguageService),
	__param$37(3, IThemeService)
], ItemRenderer);
function stripNewLines(str) {
	return str.replace(/\r\n|\r|\n/g, "");
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
var __decorate$36 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$36 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$22 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
/**
* Suggest widget colors
*/
const editorSuggestWidgetBackground = registerColor("editorSuggestWidget.background", {
	dark: editorWidgetBackground,
	light: editorWidgetBackground,
	hcDark: editorWidgetBackground,
	hcLight: editorWidgetBackground
}, localize("editorSuggestWidgetBackground", "Background color of the suggest widget."));
const editorSuggestWidgetBorder = registerColor("editorSuggestWidget.border", {
	dark: editorWidgetBorder,
	light: editorWidgetBorder,
	hcDark: editorWidgetBorder,
	hcLight: editorWidgetBorder
}, localize("editorSuggestWidgetBorder", "Border color of the suggest widget."));
const editorSuggestWidgetForeground = registerColor("editorSuggestWidget.foreground", {
	dark: editorForeground,
	light: editorForeground,
	hcDark: editorForeground,
	hcLight: editorForeground
}, localize("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
const editorSuggestWidgetSelectedForeground = registerColor("editorSuggestWidget.selectedForeground", {
	dark: quickInputListFocusForeground,
	light: quickInputListFocusForeground,
	hcDark: quickInputListFocusForeground,
	hcLight: quickInputListFocusForeground
}, localize("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
const editorSuggestWidgetSelectedIconForeground = registerColor("editorSuggestWidget.selectedIconForeground", {
	dark: quickInputListFocusIconForeground,
	light: quickInputListFocusIconForeground,
	hcDark: quickInputListFocusIconForeground,
	hcLight: quickInputListFocusIconForeground
}, localize("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
const editorSuggestWidgetSelectedBackground = registerColor("editorSuggestWidget.selectedBackground", {
	dark: quickInputListFocusBackground,
	light: quickInputListFocusBackground,
	hcDark: quickInputListFocusBackground,
	hcLight: quickInputListFocusBackground
}, localize("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
const editorSuggestWidgetHighlightForeground = registerColor("editorSuggestWidget.highlightForeground", {
	dark: listHighlightForeground,
	light: listHighlightForeground,
	hcDark: listHighlightForeground,
	hcLight: listHighlightForeground
}, localize("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
const editorSuggestWidgetHighlightFocusForeground = registerColor("editorSuggestWidget.focusHighlightForeground", {
	dark: listFocusHighlightForeground,
	light: listFocusHighlightForeground,
	hcDark: listFocusHighlightForeground,
	hcLight: listFocusHighlightForeground
}, localize("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
const editorSuggestWidgetStatusForeground = registerColor("editorSuggestWidgetStatus.foreground", {
	dark: transparent(editorSuggestWidgetForeground, .5),
	light: transparent(editorSuggestWidgetForeground, .5),
	hcDark: transparent(editorSuggestWidgetForeground, .5),
	hcLight: transparent(editorSuggestWidgetForeground, .5)
}, localize("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
var PersistedWidgetSize = class {
	constructor(_service, editor$1) {
		this._service = _service;
		this._key = `suggestWidget.size/${editor$1.getEditorType()}/${editor$1 instanceof EmbeddedCodeEditorWidget}`;
	}
	restore() {
		var _a$5;
		const raw = (_a$5 = this._service.get(this._key, 0)) !== null && _a$5 !== void 0 ? _a$5 : "";
		try {
			const obj = JSON.parse(raw);
			if (Dimension.is(obj)) return Dimension.lift(obj);
		} catch (_b$1) {}
	}
	store(size$1) {
		this._service.store(this._key, JSON.stringify(size$1), 0, 1);
	}
	reset() {
		this._service.remove(this._key, 0);
	}
};
var SuggestWidget = class SuggestWidget$1 {
	constructor(editor$1, _storageService, _contextKeyService, _themeService, instantiationService) {
		this.editor = editor$1;
		this._storageService = _storageService;
		this._state = 0;
		this._isAuto = false;
		this._ignoreFocusEvents = false;
		this._forceRenderingAbove = false;
		this._explainMode = false;
		this._showTimeout = new TimeoutTimer();
		this._disposables = new DisposableStore();
		this._onDidSelect = new Emitter$1();
		this._onDidFocus = new Emitter$1();
		this._onDidHide = new Emitter$1();
		this._onDidShow = new Emitter$1();
		this.onDidSelect = this._onDidSelect.event;
		this.onDidFocus = this._onDidFocus.event;
		this.onDidHide = this._onDidHide.event;
		this.onDidShow = this._onDidShow.event;
		this._onDetailsKeydown = new Emitter$1();
		this.onDetailsKeyDown = this._onDetailsKeydown.event;
		this.element = new ResizableHTMLElement();
		this.element.domNode.classList.add("editor-widget", "suggest-widget");
		this._contentWidget = new SuggestContentWidget(this, editor$1);
		this._persistedSize = new PersistedWidgetSize(_storageService, editor$1);
		class ResizeState {
			constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {
				this.persistedSize = persistedSize;
				this.currentSize = currentSize;
				this.persistHeight = persistHeight;
				this.persistWidth = persistWidth;
			}
		}
		let state;
		this._disposables.add(this.element.onDidWillResize(() => {
			this._contentWidget.lockPreference();
			state = new ResizeState(this._persistedSize.restore(), this.element.size);
		}));
		this._disposables.add(this.element.onDidResize((e) => {
			var _a$5, _b$1, _c$1, _d$1;
			this._resize(e.dimension.width, e.dimension.height);
			if (state) {
				state.persistHeight = state.persistHeight || !!e.north || !!e.south;
				state.persistWidth = state.persistWidth || !!e.east || !!e.west;
			}
			if (!e.done) return;
			if (state) {
				const { itemHeight, defaultSize } = this.getLayoutInfo();
				const threshold = Math.round(itemHeight / 2);
				let { width, height } = this.element.size;
				if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) height = (_b$1 = (_a$5 = state.persistedSize) === null || _a$5 === void 0 ? void 0 : _a$5.height) !== null && _b$1 !== void 0 ? _b$1 : defaultSize.height;
				if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) width = (_d$1 = (_c$1 = state.persistedSize) === null || _c$1 === void 0 ? void 0 : _c$1.width) !== null && _d$1 !== void 0 ? _d$1 : defaultSize.width;
				this._persistedSize.store(new Dimension(width, height));
			}
			this._contentWidget.unlockPreference();
			state = void 0;
		}));
		this._messageElement = append(this.element.domNode, $(".message"));
		this._listElement = append(this.element.domNode, $(".tree"));
		const details = instantiationService.createInstance(SuggestDetailsWidget, this.editor);
		details.onDidClose(this.toggleDetails, this, this._disposables);
		this._details = new SuggestDetailsOverlay(details, this.editor);
		const applyIconStyle = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(108).showIcons);
		applyIconStyle();
		const renderer = instantiationService.createInstance(ItemRenderer, this.editor);
		this._disposables.add(renderer);
		this._disposables.add(renderer.onDidToggleDetails(() => this.toggleDetails()));
		this._list = new List("SuggestWidget", this._listElement, {
			getHeight: (_element) => this.getLayoutInfo().itemHeight,
			getTemplateId: (_element) => "suggestion"
		}, [renderer], {
			alwaysConsumeMouseWheel: true,
			useShadows: false,
			mouseSupport: false,
			multipleSelectionSupport: false,
			accessibilityProvider: {
				getRole: () => "option",
				getWidgetAriaLabel: () => localize("suggest", "Suggest"),
				getWidgetRole: () => "listbox",
				getAriaLabel: (item) => {
					let label = item.textLabel;
					if (typeof item.completion.label !== "string") {
						const { detail: detail$1, description } = item.completion.label;
						if (detail$1 && description) label = localize("label.full", "{0}{1}, {2}", label, detail$1, description);
						else if (detail$1) label = localize("label.detail", "{0}{1}", label, detail$1);
						else if (description) label = localize("label.desc", "{0}, {1}", label, description);
					}
					if (!item.isResolved || !this._isDetailsVisible()) return label;
					const { documentation, detail } = item.completion;
					const docs = format("{0}{1}", detail || "", documentation ? typeof documentation === "string" ? documentation : documentation.value : "");
					return localize("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", label, docs);
				}
			}
		});
		this._status = instantiationService.createInstance(SuggestWidgetStatus, this.element.domNode);
		const applyStatusBarStyle = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(108).showStatusBar);
		applyStatusBarStyle();
		this._disposables.add(attachListStyler(this._list, _themeService, {
			listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
			listInactiveFocusOutline: activeContrastBorder
		}));
		this._disposables.add(_themeService.onDidColorThemeChange((t) => this._onThemeChange(t)));
		this._onThemeChange(_themeService.getColorTheme());
		this._disposables.add(this._list.onMouseDown((e) => this._onListMouseDownOrTap(e)));
		this._disposables.add(this._list.onTap((e) => this._onListMouseDownOrTap(e)));
		this._disposables.add(this._list.onDidChangeSelection((e) => this._onListSelection(e)));
		this._disposables.add(this._list.onDidChangeFocus((e) => this._onListFocus(e)));
		this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged()));
		this._disposables.add(this.editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(108)) {
				applyStatusBarStyle();
				applyIconStyle();
			}
		}));
		this._ctxSuggestWidgetVisible = Context$1.Visible.bindTo(_contextKeyService);
		this._ctxSuggestWidgetDetailsVisible = Context$1.DetailsVisible.bindTo(_contextKeyService);
		this._ctxSuggestWidgetMultipleSuggestions = Context$1.MultipleSuggestions.bindTo(_contextKeyService);
		this._ctxSuggestWidgetHasFocusedSuggestion = Context$1.HasFocusedSuggestion.bindTo(_contextKeyService);
		this._disposables.add(addStandardDisposableListener(this._details.widget.domNode, "keydown", (e) => {
			this._onDetailsKeydown.fire(e);
		}));
		this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));
	}
	dispose() {
		var _a$5;
		this._details.widget.dispose();
		this._details.dispose();
		this._list.dispose();
		this._status.dispose();
		this._disposables.dispose();
		(_a$5 = this._loadingTimeout) === null || _a$5 === void 0 || _a$5.dispose();
		this._showTimeout.dispose();
		this._contentWidget.dispose();
		this.element.dispose();
	}
	_onEditorMouseDown(mouseEvent) {
		if (this._details.widget.domNode.contains(mouseEvent.target.element)) this._details.widget.domNode.focus();
		else if (this.element.domNode.contains(mouseEvent.target.element)) this.editor.focus();
	}
	_onCursorSelectionChanged() {
		if (this._state !== 0) this._contentWidget.layout();
	}
	_onListMouseDownOrTap(e) {
		if (typeof e.element === "undefined" || typeof e.index === "undefined") return;
		e.browserEvent.preventDefault();
		e.browserEvent.stopPropagation();
		this._select(e.element, e.index);
	}
	_onListSelection(e) {
		if (e.elements.length) this._select(e.elements[0], e.indexes[0]);
	}
	_select(item, index) {
		const completionModel = this._completionModel;
		if (completionModel) {
			this._onDidSelect.fire({
				item,
				index,
				model: completionModel
			});
			this.editor.focus();
		}
	}
	_onThemeChange(theme) {
		this._details.widget.borderWidth = isHighContrast(theme.type) ? 2 : 1;
	}
	_onListFocus(e) {
		var _a$5;
		if (this._ignoreFocusEvents) return;
		if (!e.elements.length) {
			if (this._currentSuggestionDetails) {
				this._currentSuggestionDetails.cancel();
				this._currentSuggestionDetails = void 0;
				this._focusedItem = void 0;
			}
			this.editor.setAriaOptions({ activeDescendant: void 0 });
			this._ctxSuggestWidgetHasFocusedSuggestion.set(false);
			return;
		}
		if (!this._completionModel) return;
		this._ctxSuggestWidgetHasFocusedSuggestion.set(true);
		const item = e.elements[0];
		const index = e.indexes[0];
		if (item !== this._focusedItem) {
			(_a$5 = this._currentSuggestionDetails) === null || _a$5 === void 0 || _a$5.cancel();
			this._currentSuggestionDetails = void 0;
			this._focusedItem = item;
			this._list.reveal(index);
			this._currentSuggestionDetails = createCancelablePromise((token) => __awaiter$22(this, void 0, void 0, function* () {
				const loading = disposableTimeout(() => {
					if (this._isDetailsVisible()) this.showDetails(true);
				}, 250);
				const sub = token.onCancellationRequested(() => loading.dispose());
				const result = yield item.resolve(token);
				loading.dispose();
				sub.dispose();
				return result;
			}));
			this._currentSuggestionDetails.then(() => {
				if (index >= this._list.length || item !== this._list.element(index)) return;
				this._ignoreFocusEvents = true;
				this._list.splice(index, 1, [item]);
				this._list.setFocus([index]);
				this._ignoreFocusEvents = false;
				if (this._isDetailsVisible()) this.showDetails(false);
				else this.element.domNode.classList.remove("docs-side");
				this.editor.setAriaOptions({ activeDescendant: getAriaId(index) });
			}).catch(onUnexpectedError);
		}
		this._onDidFocus.fire({
			item,
			index,
			model: this._completionModel
		});
	}
	_setState(state) {
		if (this._state === state) return;
		this._state = state;
		this.element.domNode.classList.toggle("frozen", state === 4);
		this.element.domNode.classList.remove("message");
		switch (state) {
			case 0:
				hide(this._messageElement, this._listElement, this._status.element);
				this._details.hide(true);
				this._status.hide();
				this._contentWidget.hide();
				this._ctxSuggestWidgetVisible.reset();
				this._ctxSuggestWidgetMultipleSuggestions.reset();
				this._ctxSuggestWidgetHasFocusedSuggestion.reset();
				this._showTimeout.cancel();
				this.element.domNode.classList.remove("visible");
				this._list.splice(0, this._list.length);
				this._focusedItem = void 0;
				this._cappedHeight = void 0;
				this._explainMode = false;
				break;
			case 1:
				this.element.domNode.classList.add("message");
				this._messageElement.textContent = SuggestWidget$1.LOADING_MESSAGE;
				hide(this._listElement, this._status.element);
				show(this._messageElement);
				this._details.hide();
				this._show();
				this._focusedItem = void 0;
				break;
			case 2:
				this.element.domNode.classList.add("message");
				this._messageElement.textContent = SuggestWidget$1.NO_SUGGESTIONS_MESSAGE;
				hide(this._listElement, this._status.element);
				show(this._messageElement);
				this._details.hide();
				this._show();
				this._focusedItem = void 0;
				break;
			case 3:
				hide(this._messageElement);
				show(this._listElement, this._status.element);
				this._show();
				break;
			case 4:
				hide(this._messageElement);
				show(this._listElement, this._status.element);
				this._show();
				break;
			case 5:
				hide(this._messageElement);
				show(this._listElement, this._status.element);
				this._details.show();
				this._show();
				break;
		}
	}
	_show() {
		this._status.show();
		this._contentWidget.show();
		this._layout(this._persistedSize.restore());
		this._ctxSuggestWidgetVisible.set(true);
		this._showTimeout.cancelAndSet(() => {
			this.element.domNode.classList.add("visible");
			this._onDidShow.fire(this);
		}, 100);
	}
	showTriggered(auto, delay) {
		if (this._state !== 0) return;
		this._contentWidget.setPosition(this.editor.getPosition());
		this._isAuto = !!auto;
		if (!this._isAuto) this._loadingTimeout = disposableTimeout(() => this._setState(1), delay);
	}
	showSuggestions(completionModel, selectionIndex, isFrozen, isAuto) {
		var _a$5, _b$1;
		this._contentWidget.setPosition(this.editor.getPosition());
		(_a$5 = this._loadingTimeout) === null || _a$5 === void 0 || _a$5.dispose();
		(_b$1 = this._currentSuggestionDetails) === null || _b$1 === void 0 || _b$1.cancel();
		this._currentSuggestionDetails = void 0;
		if (this._completionModel !== completionModel) this._completionModel = completionModel;
		if (isFrozen && this._state !== 2 && this._state !== 0) {
			this._setState(4);
			return;
		}
		const visibleCount = this._completionModel.items.length;
		const isEmpty = visibleCount === 0;
		this._ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);
		if (isEmpty) {
			this._setState(isAuto ? 0 : 2);
			this._completionModel = void 0;
			return;
		}
		this._focusedItem = void 0;
		this._list.splice(0, this._list.length, this._completionModel.items);
		this._setState(isFrozen ? 4 : 3);
		if (selectionIndex >= 0) {
			this._list.reveal(selectionIndex, 0);
			this._list.setFocus([selectionIndex]);
		}
		this._layout(this.element.size);
		this._details.widget.domNode.classList.remove("focused");
	}
	selectNextPage() {
		switch (this._state) {
			case 0: return false;
			case 5:
				this._details.widget.pageDown();
				return true;
			case 1: return !this._isAuto;
			default:
				this._list.focusNextPage();
				return true;
		}
	}
	selectNext() {
		switch (this._state) {
			case 0: return false;
			case 1: return !this._isAuto;
			default:
				this._list.focusNext(1, true);
				return true;
		}
	}
	selectLast() {
		switch (this._state) {
			case 0: return false;
			case 5:
				this._details.widget.scrollBottom();
				return true;
			case 1: return !this._isAuto;
			default:
				this._list.focusLast();
				return true;
		}
	}
	selectPreviousPage() {
		switch (this._state) {
			case 0: return false;
			case 5:
				this._details.widget.pageUp();
				return true;
			case 1: return !this._isAuto;
			default:
				this._list.focusPreviousPage();
				return true;
		}
	}
	selectPrevious() {
		switch (this._state) {
			case 0: return false;
			case 1: return !this._isAuto;
			default:
				this._list.focusPrevious(1, true);
				return false;
		}
	}
	selectFirst() {
		switch (this._state) {
			case 0: return false;
			case 5:
				this._details.widget.scrollTop();
				return true;
			case 1: return !this._isAuto;
			default:
				this._list.focusFirst();
				return true;
		}
	}
	getFocusedItem() {
		if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel) return {
			item: this._list.getFocusedElements()[0],
			index: this._list.getFocus()[0],
			model: this._completionModel
		};
	}
	toggleDetailsFocus() {
		if (this._state === 5) {
			this._setState(3);
			this._details.widget.domNode.classList.remove("focused");
		} else if (this._state === 3 && this._isDetailsVisible()) {
			this._setState(5);
			this._details.widget.domNode.classList.add("focused");
		}
	}
	toggleDetails() {
		if (this._isDetailsVisible()) {
			this._ctxSuggestWidgetDetailsVisible.set(false);
			this._setDetailsVisible(false);
			this._details.hide();
			this.element.domNode.classList.remove("shows-details");
		} else if ((canExpandCompletionItem(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4)) {
			this._ctxSuggestWidgetDetailsVisible.set(true);
			this._setDetailsVisible(true);
			this.showDetails(false);
		}
	}
	showDetails(loading) {
		this._details.show();
		if (loading) this._details.widget.renderLoading();
		else this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode);
		this._positionDetails();
		this.editor.focus();
		this.element.domNode.classList.add("shows-details");
	}
	toggleExplainMode() {
		if (this._list.getFocusedElements()[0]) {
			this._explainMode = !this._explainMode;
			if (!this._isDetailsVisible()) this.toggleDetails();
			else this.showDetails(false);
		}
	}
	resetPersistedSize() {
		this._persistedSize.reset();
	}
	hideWidget() {
		var _a$5;
		(_a$5 = this._loadingTimeout) === null || _a$5 === void 0 || _a$5.dispose();
		this._setState(0);
		this._onDidHide.fire(this);
		this.element.clearSashHoverState();
		const dim = this._persistedSize.restore();
		const minPersistedHeight = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
		if (dim && dim.height < minPersistedHeight) this._persistedSize.store(dim.with(void 0, minPersistedHeight));
	}
	isFrozen() {
		return this._state === 4;
	}
	_afterRender(position) {
		if (position === null) {
			if (this._isDetailsVisible()) this._details.hide();
			return;
		}
		if (this._state === 2 || this._state === 1) return;
		if (this._isDetailsVisible()) this._details.show();
		this._positionDetails();
	}
	_layout(size$1) {
		var _a$5, _b$1, _c$1;
		if (!this.editor.hasModel()) return;
		if (!this.editor.getDomNode()) return;
		const bodyBox = getClientArea(document.body);
		const info = this.getLayoutInfo();
		if (!size$1) size$1 = info.defaultSize;
		let height = size$1.height;
		let width = size$1.width;
		this._status.element.style.lineHeight = `${info.itemHeight}px`;
		if (this._state === 2 || this._state === 1) {
			height = info.itemHeight + info.borderHeight;
			width = info.defaultSize.width / 2;
			this.element.enableSashes(false, false, false, false);
			this.element.minSize = this.element.maxSize = new Dimension(width, height);
			this._contentWidget.setPreference(2);
		} else {
			const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;
			if (width > maxWidth) width = maxWidth;
			const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;
			const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;
			const minHeight = info.itemHeight + info.statusBarHeight;
			const editorBox = getDomNodePagePosition(this.editor.getDomNode());
			const cursorBox = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
			const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;
			const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);
			const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
			const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
			let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
			if (height === ((_a$5 = this._cappedHeight) === null || _a$5 === void 0 ? void 0 : _a$5.capped)) height = this._cappedHeight.wanted;
			if (height < minHeight) height = minHeight;
			if (height > maxHeight) height = maxHeight;
			if (height > maxHeightBelow || this._forceRenderingAbove && availableSpaceAbove > 150) {
				this._contentWidget.setPreference(1);
				this.element.enableSashes(true, true, false, false);
				maxHeight = maxHeightAbove;
			} else {
				this._contentWidget.setPreference(2);
				this.element.enableSashes(false, true, true, false);
				maxHeight = maxHeightBelow;
			}
			this.element.preferredSize = new Dimension(preferredWidth, info.defaultSize.height);
			this.element.maxSize = new Dimension(maxWidth, maxHeight);
			this.element.minSize = new Dimension(220, minHeight);
			this._cappedHeight = height === fullHeight ? {
				wanted: (_c$1 = (_b$1 = this._cappedHeight) === null || _b$1 === void 0 ? void 0 : _b$1.wanted) !== null && _c$1 !== void 0 ? _c$1 : size$1.height,
				capped: height
			} : void 0;
		}
		this._resize(width, height);
	}
	_resize(width, height) {
		const { width: maxWidth, height: maxHeight } = this.element.maxSize;
		width = Math.min(maxWidth, width);
		height = Math.min(maxHeight, height);
		const { statusBarHeight } = this.getLayoutInfo();
		this._list.layout(height - statusBarHeight, width);
		this._listElement.style.height = `${height - statusBarHeight}px`;
		this.element.layout(height, width);
		this._contentWidget.layout();
		this._positionDetails();
	}
	_positionDetails() {
		var _a$5;
		if (this._isDetailsVisible()) this._details.placeAtAnchor(this.element.domNode, ((_a$5 = this._contentWidget.getPosition()) === null || _a$5 === void 0 ? void 0 : _a$5.preference[0]) === 2);
	}
	getLayoutInfo() {
		const fontInfo = this.editor.getOption(46);
		const itemHeight = clamp(this.editor.getOption(110) || fontInfo.lineHeight, 8, 1e3);
		const statusBarHeight = !this.editor.getOption(108).showStatusBar || this._state === 2 || this._state === 1 ? 0 : itemHeight;
		const borderWidth = this._details.widget.borderWidth;
		const borderHeight = 2 * borderWidth;
		return {
			itemHeight,
			statusBarHeight,
			borderWidth,
			borderHeight,
			typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,
			verticalPadding: 22,
			horizontalPadding: 14,
			defaultSize: new Dimension(430, statusBarHeight + 12 * itemHeight + borderHeight)
		};
	}
	_isDetailsVisible() {
		return this._storageService.getBoolean("expandSuggestionDocs", 0, false);
	}
	_setDetailsVisible(value) {
		this._storageService.store("expandSuggestionDocs", value, 0, 0);
	}
	forceRenderingAbove() {
		if (!this._forceRenderingAbove) {
			this._forceRenderingAbove = true;
			this._layout(this._persistedSize.restore());
		}
	}
	stopForceRenderingAbove() {
		this._forceRenderingAbove = false;
	}
};
SuggestWidget.LOADING_MESSAGE = localize("suggestWidget.loading", "Loading...");
SuggestWidget.NO_SUGGESTIONS_MESSAGE = localize("suggestWidget.noSuggestions", "No suggestions.");
SuggestWidget = __decorate$36([
	__param$36(1, IStorageService),
	__param$36(2, IContextKeyService),
	__param$36(3, IThemeService),
	__param$36(4, IInstantiationService)
], SuggestWidget);
var SuggestContentWidget = class {
	constructor(_widget, _editor) {
		this._widget = _widget;
		this._editor = _editor;
		this.allowEditorOverflow = true;
		this.suppressMouseDown = false;
		this._preferenceLocked = false;
		this._added = false;
		this._hidden = false;
	}
	dispose() {
		if (this._added) {
			this._added = false;
			this._editor.removeContentWidget(this);
		}
	}
	getId() {
		return "editor.widget.suggestWidget";
	}
	getDomNode() {
		return this._widget.element.domNode;
	}
	show() {
		this._hidden = false;
		if (!this._added) {
			this._added = true;
			this._editor.addContentWidget(this);
		}
	}
	hide() {
		if (!this._hidden) {
			this._hidden = true;
			this.layout();
		}
	}
	layout() {
		this._editor.layoutContentWidget(this);
	}
	getPosition() {
		if (this._hidden || !this._position || !this._preference) return null;
		return {
			position: this._position,
			preference: [this._preference]
		};
	}
	beforeRender() {
		const { height, width } = this._widget.element.size;
		const { borderWidth, horizontalPadding } = this._widget.getLayoutInfo();
		return new Dimension(width + 2 * borderWidth + horizontalPadding, height + 2 * borderWidth);
	}
	afterRender(position) {
		this._widget._afterRender(position);
	}
	setPreference(preference) {
		if (!this._preferenceLocked) this._preference = preference;
	}
	lockPreference() {
		this._preferenceLocked = true;
	}
	unlockPreference() {
		this._preferenceLocked = false;
	}
	setPosition(position) {
		this._position = position;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
var __decorate$35 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$35 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var LineSuffix = class {
	constructor(_model, _position) {
		this._model = _model;
		this._position = _position;
		if (_model.getLineMaxColumn(_position.lineNumber) !== _position.column) {
			const offset = _model.getOffsetAt(_position);
			const end = _model.getPositionAt(offset + 1);
			this._marker = _model.deltaDecorations([], [{
				range: Range$1.fromPositions(_position, end),
				options: {
					description: "suggest-line-suffix",
					stickiness: 1
				}
			}]);
		}
	}
	dispose() {
		if (this._marker && !this._model.isDisposed()) this._model.deltaDecorations(this._marker, []);
	}
	delta(position) {
		if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) return 0;
		if (this._marker) {
			const range = this._model.getDecorationRange(this._marker[0]);
			return this._model.getOffsetAt(range.getStartPosition()) - this._model.getOffsetAt(position);
		} else return this._model.getLineMaxColumn(position.lineNumber) - position.column;
	}
};
var SuggestController = class SuggestController$1 {
	constructor(editor$1, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService, _telemetryService) {
		this._memoryService = _memoryService;
		this._commandService = _commandService;
		this._contextKeyService = _contextKeyService;
		this._instantiationService = _instantiationService;
		this._logService = _logService;
		this._telemetryService = _telemetryService;
		this._lineSuffix = new MutableDisposable();
		this._toDispose = new DisposableStore();
		this._selectors = new PriorityRegistry((s) => s.priority);
		this._telemetryGate = 0;
		this.editor = editor$1;
		this.model = _instantiationService.createInstance(SuggestModel, this.editor);
		const ctxInsertMode = Context$1.InsertMode.bindTo(_contextKeyService);
		ctxInsertMode.set(editor$1.getOption(108).insertMode);
		this.model.onDidTrigger(() => ctxInsertMode.set(editor$1.getOption(108).insertMode));
		this.widget = this._toDispose.add(new IdleValue(() => {
			const widget = this._instantiationService.createInstance(SuggestWidget, this.editor);
			this._toDispose.add(widget);
			this._toDispose.add(widget.onDidSelect((item) => this._insertSuggestion(item, 0), this));
			const commitCharacterController = new CommitCharacterController(this.editor, widget, (item) => this._insertSuggestion(item, 2));
			this._toDispose.add(commitCharacterController);
			this._toDispose.add(this.model.onDidSuggest((e) => {
				if (e.completionModel.items.length === 0) commitCharacterController.reset();
			}));
			const ctxMakesTextEdit = Context$1.MakesTextEdit.bindTo(this._contextKeyService);
			const ctxHasInsertAndReplace = Context$1.HasInsertAndReplaceRange.bindTo(this._contextKeyService);
			const ctxCanResolve = Context$1.CanResolve.bindTo(this._contextKeyService);
			this._toDispose.add(toDisposable(() => {
				ctxMakesTextEdit.reset();
				ctxHasInsertAndReplace.reset();
				ctxCanResolve.reset();
			}));
			this._toDispose.add(widget.onDidFocus(({ item }) => {
				const position = this.editor.getPosition();
				const startColumn = item.editStart.column;
				const endColumn = position.column;
				let value = true;
				if (this.editor.getOption(1) === "smart" && this.model.state === 2 && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4) && endColumn - startColumn === item.completion.insertText.length) value = this.editor.getModel().getValueInRange({
					startLineNumber: position.lineNumber,
					startColumn,
					endLineNumber: position.lineNumber,
					endColumn
				}) !== item.completion.insertText;
				ctxMakesTextEdit.set(value);
				ctxHasInsertAndReplace.set(!Position$1.equals(item.editInsertEnd, item.editReplaceEnd));
				ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);
			}));
			this._toDispose.add(widget.onDetailsKeyDown((e) => {
				if (e.toKeybinding().equals(new SimpleKeybinding(true, false, false, false, 33)) || isMacintosh && e.toKeybinding().equals(new SimpleKeybinding(false, false, false, true, 33))) {
					e.stopPropagation();
					return;
				}
				if (!e.toKeybinding().isModifierKey()) this.editor.focus();
			}));
			return widget;
		}));
		this._overtypingCapturer = this._toDispose.add(new IdleValue(() => {
			return this._toDispose.add(new OvertypingCapturer(this.editor, this.model));
		}));
		this._alternatives = this._toDispose.add(new IdleValue(() => {
			return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));
		}));
		this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor$1));
		this._toDispose.add(this.model.onDidTrigger((e) => {
			this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);
			this._lineSuffix.value = new LineSuffix(this.editor.getModel(), e.position);
		}));
		this._toDispose.add(this.model.onDidSuggest((e) => {
			if (e.shy) return;
			let index = -1;
			if (!e.noSelect) {
				for (const selector of this._selectors.itemsOrderedByPriorityDesc) {
					index = selector.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
					if (index !== -1) break;
				}
				if (index === -1) index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
			}
			this.widget.value.showSuggestions(e.completionModel, index, e.isFrozen, e.auto);
		}));
		this._toDispose.add(this.model.onDidCancel((e) => {
			if (!e.retrigger) this.widget.value.hideWidget();
		}));
		this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
			this.model.cancel();
			this.model.clear();
		}));
		const acceptSuggestionsOnEnter = Context$1.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
		const updateFromConfig = () => {
			const acceptSuggestionOnEnter = this.editor.getOption(1);
			acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === "on" || acceptSuggestionOnEnter === "smart");
		};
		this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));
		updateFromConfig();
	}
	static get(editor$1) {
		return editor$1.getContribution(SuggestController$1.ID);
	}
	dispose() {
		this._alternatives.dispose();
		this._toDispose.dispose();
		this.widget.dispose();
		this.model.dispose();
		this._lineSuffix.dispose();
	}
	_insertSuggestion(event, flags) {
		if (!event || !event.item) {
			this._alternatives.value.reset();
			this.model.cancel();
			this.model.clear();
			return;
		}
		if (!this.editor.hasModel()) return;
		const snippetController = SnippetController2.get(this.editor);
		if (!snippetController) return;
		const model = this.editor.getModel();
		const modelVersionNow = model.getAlternativeVersionId();
		const { item } = event;
		const tasks = [];
		const cts = new CancellationTokenSource$1();
		if (!(flags & 1)) this.editor.pushUndoStop();
		const info = this.getOverwriteInfo(item, Boolean(flags & 8));
		this._memoryService.memorize(model, this.editor.getPosition(), item);
		if (Array.isArray(item.completion.additionalTextEdits)) {
			const scrollState = StableEditorScrollState.capture(this.editor);
			this.editor.executeEdits("suggestController.additionalTextEdits.sync", item.completion.additionalTextEdits.map((edit) => EditOperation.replaceMove(Range$1.lift(edit.range), edit.text)));
			scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
		} else if (!item.isResolved) {
			const sw = new StopWatch(true);
			let position;
			const docListener = model.onDidChangeContent((e) => {
				if (e.isFlush) {
					cts.cancel();
					docListener.dispose();
					return;
				}
				for (const change of e.changes) {
					const thisPosition = Range$1.getEndPosition(change.range);
					if (!position || Position$1.isBefore(thisPosition, position)) position = thisPosition;
				}
			});
			const oldFlags = flags;
			flags |= 2;
			let didType = false;
			const typeListener = this.editor.onWillType(() => {
				typeListener.dispose();
				didType = true;
				if (!(oldFlags & 2)) this.editor.pushUndoStop();
			});
			tasks.push(item.resolve(cts.token).then(() => {
				if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) return false;
				if (position && item.completion.additionalTextEdits.some((edit) => Position$1.isBefore(position, Range$1.getStartPosition(edit.range)))) return false;
				if (didType) this.editor.pushUndoStop();
				const scrollState = StableEditorScrollState.capture(this.editor);
				this.editor.executeEdits("suggestController.additionalTextEdits.async", item.completion.additionalTextEdits.map((edit) => EditOperation.replaceMove(Range$1.lift(edit.range), edit.text)));
				scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
				if (didType || !(oldFlags & 2)) this.editor.pushUndoStop();
				return true;
			}).then((applied) => {
				this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", sw.elapsed(), applied);
				docListener.dispose();
				typeListener.dispose();
			}));
		}
		let { insertText } = item.completion;
		if (!(item.completion.insertTextRules & 4)) insertText = SnippetParser.escape(insertText);
		snippetController.insert(insertText, {
			overwriteBefore: info.overwriteBefore,
			overwriteAfter: info.overwriteAfter,
			undoStopBefore: false,
			undoStopAfter: false,
			adjustWhitespace: !(item.completion.insertTextRules & 1),
			clipboardText: event.model.clipboardText,
			overtypingCapturer: this._overtypingCapturer.value
		});
		if (!(flags & 2)) this.editor.pushUndoStop();
		if (!item.completion.command) this.model.cancel();
		else if (item.completion.command.id === TriggerSuggestAction.id) this.model.trigger({
			auto: true,
			shy: false,
			noSelect: false
		}, true);
		else {
			tasks.push(this._commandService.executeCommand(item.completion.command.id, ...item.completion.command.arguments ? [...item.completion.command.arguments] : []).catch(onUnexpectedError));
			this.model.cancel();
		}
		if (flags & 4) this._alternatives.value.set(event, (next) => {
			cts.cancel();
			while (model.canUndo()) {
				if (modelVersionNow !== model.getAlternativeVersionId()) model.undo();
				this._insertSuggestion(next, 3 | (flags & 8 ? 8 : 0));
				break;
			}
		});
		this._alertCompletionItem(item);
		Promise.all(tasks).finally(() => {
			this._reportSuggestionAcceptedTelemetry(item, model, event);
			this.model.clear();
			cts.dispose();
		});
	}
	_reportSuggestionAcceptedTelemetry(item, model, acceptedSuggestion) {
		var _a$5;
		if (this._telemetryGate++ % 100 !== 0) return;
		const providerId = item.extensionId ? item.extensionId.value : ((_a$5 = acceptedSuggestion.item.provider._debugDisplayName) !== null && _a$5 !== void 0 ? _a$5 : "unknown").split("(", 1)[0].toLowerCase();
		this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
			providerId,
			kind: item.completion.kind,
			basenameHash: hash(basename(model.uri)).toString(16),
			languageId: model.getLanguageId(),
			fileExtension: extname(model.uri)
		});
	}
	getOverwriteInfo(item, toggleMode) {
		assertType(this.editor.hasModel());
		let replace = this.editor.getOption(108).insertMode === "replace";
		if (toggleMode) replace = !replace;
		const overwriteBefore = item.position.column - item.editStart.column;
		const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;
		const columnDelta = this.editor.getPosition().column - item.position.column;
		const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
		return {
			overwriteBefore: overwriteBefore + columnDelta,
			overwriteAfter: overwriteAfter + suffixDelta
		};
	}
	_alertCompletionItem(item) {
		if (isNonEmptyArray(item.completion.additionalTextEdits)) alert(localize("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length));
	}
	triggerSuggest(onlyFrom, auto, noFilter, noSelect) {
		if (this.editor.hasModel()) {
			this.model.trigger({
				auto: auto !== null && auto !== void 0 ? auto : false,
				shy: false,
				noSelect: noSelect !== null && noSelect !== void 0 ? noSelect : false
			}, false, onlyFrom, void 0, noFilter);
			this.editor.revealPosition(this.editor.getPosition(), 0);
			this.editor.focus();
		}
	}
	triggerSuggestAndAcceptBest(arg) {
		if (!this.editor.hasModel()) return;
		const positionNow = this.editor.getPosition();
		const fallback = () => {
			if (positionNow.equals(this.editor.getPosition())) this._commandService.executeCommand(arg.fallback);
		};
		const makesTextEdit = (item) => {
			if (item.completion.insertTextRules & 4 || item.completion.additionalTextEdits) return true;
			const position = this.editor.getPosition();
			const startColumn = item.editStart.column;
			const endColumn = position.column;
			if (endColumn - startColumn !== item.completion.insertText.length) return true;
			return this.editor.getModel().getValueInRange({
				startLineNumber: position.lineNumber,
				startColumn,
				endLineNumber: position.lineNumber,
				endColumn
			}) !== item.completion.insertText;
		};
		Event.once(this.model.onDidTrigger)((_) => {
			const listener = [];
			Event.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
				dispose(listener);
				fallback();
			}, void 0, listener);
			this.model.onDidSuggest(({ completionModel }) => {
				dispose(listener);
				if (completionModel.items.length === 0) {
					fallback();
					return;
				}
				const index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);
				const item = completionModel.items[index];
				if (!makesTextEdit(item)) {
					fallback();
					return;
				}
				this.editor.pushUndoStop();
				this._insertSuggestion({
					index,
					item,
					model: completionModel
				}, 7);
			}, void 0, listener);
		});
		this.model.trigger({
			auto: false,
			shy: true,
			noSelect: false
		});
		this.editor.revealPosition(positionNow, 0);
		this.editor.focus();
	}
	acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {
		const item = this.widget.value.getFocusedItem();
		let flags = 0;
		if (keepAlternativeSuggestions) flags |= 4;
		if (alternativeOverwriteConfig) flags |= 8;
		this._insertSuggestion(item, flags);
	}
	acceptNextSuggestion() {
		this._alternatives.value.next();
	}
	acceptPrevSuggestion() {
		this._alternatives.value.prev();
	}
	cancelSuggestWidget() {
		this.model.cancel();
		this.model.clear();
		this.widget.value.hideWidget();
	}
	selectNextSuggestion() {
		this.widget.value.selectNext();
	}
	selectNextPageSuggestion() {
		this.widget.value.selectNextPage();
	}
	selectLastSuggestion() {
		this.widget.value.selectLast();
	}
	selectPrevSuggestion() {
		this.widget.value.selectPrevious();
	}
	selectPrevPageSuggestion() {
		this.widget.value.selectPreviousPage();
	}
	selectFirstSuggestion() {
		this.widget.value.selectFirst();
	}
	toggleSuggestionDetails() {
		this.widget.value.toggleDetails();
	}
	toggleExplainMode() {
		this.widget.value.toggleExplainMode();
	}
	toggleSuggestionFocus() {
		this.widget.value.toggleDetailsFocus();
	}
	resetWidgetSize() {
		this.widget.value.resetPersistedSize();
	}
	forceRenderingAbove() {
		this.widget.value.forceRenderingAbove();
	}
	stopForceRenderingAbove() {
		if (!this.widget.isInitialized) return;
		this.widget.value.stopForceRenderingAbove();
	}
	registerSelector(selector) {
		return this._selectors.register(selector);
	}
};
SuggestController.ID = "editor.contrib.suggestController";
SuggestController = __decorate$35([
	__param$35(1, ISuggestMemoryService),
	__param$35(2, ICommandService),
	__param$35(3, IContextKeyService),
	__param$35(4, IInstantiationService),
	__param$35(5, ILogService),
	__param$35(6, ITelemetryService)
], SuggestController);
var PriorityRegistry = class {
	constructor(prioritySelector) {
		this.prioritySelector = prioritySelector;
		this._items = new Array();
	}
	register(value) {
		if (this._items.indexOf(value) !== -1) throw new Error("Value is already registered");
		this._items.push(value);
		this._items.sort((s1, s2) => this.prioritySelector(s2) - this.prioritySelector(s1));
		return { dispose: () => {
			const idx = this._items.indexOf(value);
			if (idx >= 0) this._items.splice(idx, 1);
		} };
	}
	get itemsOrderedByPriorityDesc() {
		return this._items;
	}
};
var TriggerSuggestAction = class TriggerSuggestAction extends EditorAction {
	constructor() {
		super({
			id: TriggerSuggestAction.id,
			label: localize("suggest.trigger.label", "Trigger Suggest"),
			alias: "Trigger Suggest",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 2058,
				secondary: [2087],
				mac: {
					primary: 266,
					secondary: [521, 2087]
				},
				weight: 100
			}
		});
	}
	run(_accessor, editor$1, args) {
		const controller = SuggestController.get(editor$1);
		if (!controller) return;
		let auto;
		let noSelect;
		if (args && typeof args === "object") {
			if (args.auto === true) auto = true;
			if (args.noSelection === true) noSelect = true;
		}
		controller.triggerSuggest(void 0, auto, void 0, noSelect);
	}
};
TriggerSuggestAction.id = "editor.action.triggerSuggest";
registerEditorContribution(SuggestController.ID, SuggestController);
registerEditorAction(TriggerSuggestAction);
var weight$1 = 190;
var SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
registerEditorCommand(new SuggestCommand({
	id: "acceptSelectedSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.HasFocusedSuggestion),
	handler(x) {
		x.acceptSelectedSuggestion(true, false);
	},
	kbOpts: [{
		primary: 2,
		kbExpr: ContextKeyExpr.and(Context$1.Visible, EditorContextKeys.textInputFocus),
		weight: weight$1
	}, {
		primary: 3,
		kbExpr: ContextKeyExpr.and(Context$1.Visible, EditorContextKeys.textInputFocus, Context$1.AcceptSuggestionsOnEnter, Context$1.MakesTextEdit),
		weight: weight$1
	}],
	menuOpts: [
		{
			menuId: suggestWidgetStatusbarMenu,
			title: localize("accept.insert", "Insert"),
			group: "left",
			order: 1,
			when: Context$1.HasInsertAndReplaceRange.toNegated()
		},
		{
			menuId: suggestWidgetStatusbarMenu,
			title: localize("accept.insert", "Insert"),
			group: "left",
			order: 1,
			when: ContextKeyExpr.and(Context$1.HasInsertAndReplaceRange, Context$1.InsertMode.isEqualTo("insert"))
		},
		{
			menuId: suggestWidgetStatusbarMenu,
			title: localize("accept.replace", "Replace"),
			group: "left",
			order: 1,
			when: ContextKeyExpr.and(Context$1.HasInsertAndReplaceRange, Context$1.InsertMode.isEqualTo("replace"))
		}
	]
}));
registerEditorCommand(new SuggestCommand({
	id: "acceptAlternativeSelectedSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, EditorContextKeys.textInputFocus, Context$1.HasFocusedSuggestion),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 1027,
		secondary: [1026]
	},
	handler(x) {
		x.acceptSelectedSuggestion(false, true);
	},
	menuOpts: [{
		menuId: suggestWidgetStatusbarMenu,
		group: "left",
		order: 2,
		when: ContextKeyExpr.and(Context$1.HasInsertAndReplaceRange, Context$1.InsertMode.isEqualTo("insert")),
		title: localize("accept.replace", "Replace")
	}, {
		menuId: suggestWidgetStatusbarMenu,
		group: "left",
		order: 2,
		when: ContextKeyExpr.and(Context$1.HasInsertAndReplaceRange, Context$1.InsertMode.isEqualTo("replace")),
		title: localize("accept.insert", "Insert")
	}]
}));
CommandsRegistry.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
registerEditorCommand(new SuggestCommand({
	id: "hideSuggestWidget",
	precondition: Context$1.Visible,
	handler: (x) => x.cancelSuggestWidget(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 9,
		secondary: [1033]
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "selectNextSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
	handler: (c) => c.selectNextSuggestion(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 18,
		secondary: [2066],
		mac: {
			primary: 18,
			secondary: [2066, 300]
		}
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "selectNextPageSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
	handler: (c) => c.selectNextPageSuggestion(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 12,
		secondary: [2060]
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "selectLastSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
	handler: (c) => c.selectLastSuggestion()
}));
registerEditorCommand(new SuggestCommand({
	id: "selectPrevSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
	handler: (c) => c.selectPrevSuggestion(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 16,
		secondary: [2064],
		mac: {
			primary: 16,
			secondary: [2064, 302]
		}
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "selectPrevPageSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
	handler: (c) => c.selectPrevPageSuggestion(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 11,
		secondary: [2059]
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "selectFirstSuggestion",
	precondition: ContextKeyExpr.and(Context$1.Visible, Context$1.MultipleSuggestions),
	handler: (c) => c.selectFirstSuggestion()
}));
registerEditorCommand(new SuggestCommand({
	id: "toggleSuggestionDetails",
	precondition: Context$1.Visible,
	handler: (x) => x.toggleSuggestionDetails(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 2058,
		secondary: [2087],
		mac: {
			primary: 266,
			secondary: [2087]
		}
	},
	menuOpts: [{
		menuId: suggestWidgetStatusbarMenu,
		group: "right",
		order: 1,
		when: ContextKeyExpr.and(Context$1.DetailsVisible, Context$1.CanResolve),
		title: localize("detail.more", "show less")
	}, {
		menuId: suggestWidgetStatusbarMenu,
		group: "right",
		order: 1,
		when: ContextKeyExpr.and(Context$1.DetailsVisible.toNegated(), Context$1.CanResolve),
		title: localize("detail.less", "show more")
	}]
}));
registerEditorCommand(new SuggestCommand({
	id: "toggleExplainMode",
	precondition: Context$1.Visible,
	handler: (x) => x.toggleExplainMode(),
	kbOpts: {
		weight: 100,
		primary: 2133
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "toggleSuggestionFocus",
	precondition: Context$1.Visible,
	handler: (x) => x.toggleSuggestionFocus(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 2570,
		mac: { primary: 778 }
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "insertBestCompletion",
	precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), WordContextKey.AtEnd, Context$1.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
	handler: (x, arg) => {
		x.triggerSuggestAndAcceptBest(isObject(arg) ? Object.assign({ fallback: "tab" }, arg) : { fallback: "tab" });
	},
	kbOpts: {
		weight: weight$1,
		primary: 2
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "insertNextSuggestion",
	precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context$1.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
	handler: (x) => x.acceptNextSuggestion(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 2
	}
}));
registerEditorCommand(new SuggestCommand({
	id: "insertPrevSuggestion",
	precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context$1.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
	handler: (x) => x.acceptPrevSuggestion(),
	kbOpts: {
		weight: weight$1,
		kbExpr: EditorContextKeys.textInputFocus,
		primary: 1026
	}
}));
registerEditorAction(class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.resetSuggestSize",
			label: localize("suggest.reset.label", "Reset Suggest Widget Size"),
			alias: "Reset Suggest Widget Size",
			precondition: void 0
		});
	}
	run(_accessor, editor$1) {
		var _a$5;
		(_a$5 = SuggestController.get(editor$1)) === null || _a$5 === void 0 || _a$5.resetWidgetSize();
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js
var SuggestWidgetInlineCompletionProvider = class extends Disposable {
	constructor(editor$1, suggestControllerPreselector) {
		super();
		this.editor = editor$1;
		this.suggestControllerPreselector = suggestControllerPreselector;
		this.isSuggestWidgetVisible = false;
		this.isShiftKeyPressed = false;
		this._isActive = false;
		this._currentSuggestItemInfo = void 0;
		this.onDidChangeEmitter = new Emitter$1();
		this.onDidChange = this.onDidChangeEmitter.event;
		this.setInactiveDelayed = this._register(new RunOnceScheduler(() => {
			if (!this.isSuggestWidgetVisible) {
				if (this._isActive) {
					this._isActive = false;
					this.onDidChangeEmitter.fire();
				}
			}
		}, 100));
		this._register(editor$1.onKeyDown((e) => {
			if (e.shiftKey && !this.isShiftKeyPressed) {
				this.isShiftKeyPressed = true;
				this.update(this._isActive);
			}
		}));
		this._register(editor$1.onKeyUp((e) => {
			if (e.shiftKey && this.isShiftKeyPressed) {
				this.isShiftKeyPressed = false;
				this.update(this._isActive);
			}
		}));
		const suggestController = SuggestController.get(this.editor);
		if (suggestController) {
			this._register(suggestController.registerSelector({
				priority: 100,
				select: (model, pos, suggestItems) => {
					const textModel = this.editor.getModel();
					const normalizedItemToPreselect = minimizeInlineCompletion(textModel, this.suggestControllerPreselector());
					if (!normalizedItemToPreselect) return -1;
					const position = Position$1.lift(pos);
					const result = findMaxBy(suggestItems.map((suggestItem, index) => {
						const inlineSuggestItem = suggestionToSuggestItemInfo(suggestController, position, suggestItem, this.isShiftKeyPressed);
						const normalizedSuggestItem = minimizeInlineCompletion(textModel, inlineSuggestItem === null || inlineSuggestItem === void 0 ? void 0 : inlineSuggestItem.normalizedInlineCompletion);
						if (!normalizedSuggestItem) return;
						return {
							index,
							valid: rangeStartsWith(normalizedItemToPreselect.range, normalizedSuggestItem.range) && normalizedItemToPreselect.insertText.startsWith(normalizedSuggestItem.insertText),
							prefixLength: normalizedSuggestItem.insertText.length,
							suggestItem
						};
					}).filter((item) => item && item.valid), compareBy((s) => s.prefixLength, numberComparator));
					return result ? result.index : -1;
				}
			}));
			let isBoundToSuggestWidget = false;
			const bindToSuggestWidget = () => {
				if (isBoundToSuggestWidget) return;
				isBoundToSuggestWidget = true;
				this._register(suggestController.widget.value.onDidShow(() => {
					this.isSuggestWidgetVisible = true;
					this.update(true);
				}));
				this._register(suggestController.widget.value.onDidHide(() => {
					this.isSuggestWidgetVisible = false;
					this.setInactiveDelayed.schedule();
					this.update(this._isActive);
				}));
				this._register(suggestController.widget.value.onDidFocus(() => {
					this.isSuggestWidgetVisible = true;
					this.update(true);
				}));
			};
			this._register(Event.once(suggestController.model.onDidTrigger)((e) => {
				bindToSuggestWidget();
			}));
		}
		this.update(this._isActive);
	}
	/**
	* Returns undefined if the suggest widget is not active.
	*/
	get state() {
		if (!this._isActive) return;
		return { selectedItem: this._currentSuggestItemInfo };
	}
	update(newActive) {
		const newInlineCompletion = this.getSuggestItemInfo();
		let shouldFire = false;
		if (!suggestItemInfoEquals(this._currentSuggestItemInfo, newInlineCompletion)) {
			this._currentSuggestItemInfo = newInlineCompletion;
			shouldFire = true;
		}
		if (this._isActive !== newActive) {
			this._isActive = newActive;
			shouldFire = true;
		}
		if (shouldFire) this.onDidChangeEmitter.fire();
	}
	getSuggestItemInfo() {
		const suggestController = SuggestController.get(this.editor);
		if (!suggestController) return;
		if (!this.isSuggestWidgetVisible) return;
		const focusedItem = suggestController.widget.value.getFocusedItem();
		if (!focusedItem) return;
		return suggestionToSuggestItemInfo(suggestController, this.editor.getPosition(), focusedItem.item, this.isShiftKeyPressed);
	}
	stopForceRenderingAbove() {
		const suggestController = SuggestController.get(this.editor);
		if (suggestController) suggestController.stopForceRenderingAbove();
	}
	forceRenderingAbove() {
		const suggestController = SuggestController.get(this.editor);
		if (suggestController) suggestController.forceRenderingAbove();
	}
};
function rangeStartsWith(rangeToTest, prefix) {
	return prefix.startLineNumber === rangeToTest.startLineNumber && prefix.startColumn === rangeToTest.startColumn && (prefix.endLineNumber < rangeToTest.endLineNumber || prefix.endLineNumber === rangeToTest.endLineNumber && prefix.endColumn <= rangeToTest.endColumn);
}
function suggestItemInfoEquals(a, b) {
	if (a === b) return true;
	if (!a || !b) return false;
	return a.completionItemKind === b.completionItemKind && a.isSnippetText === b.isSnippetText && normalizedInlineCompletionsEquals(a.normalizedInlineCompletion, b.normalizedInlineCompletion);
}
function suggestionToSuggestItemInfo(suggestController, position, item, toggleMode) {
	if (Array.isArray(item.completion.additionalTextEdits) && item.completion.additionalTextEdits.length > 0) return {
		completionItemKind: item.completion.kind,
		isSnippetText: false,
		normalizedInlineCompletion: {
			range: Range$1.fromPositions(position, position),
			insertText: "",
			filterText: "",
			snippetInfo: void 0,
			additionalTextEdits: []
		}
	};
	let { insertText } = item.completion;
	let isSnippetText = false;
	if (item.completion.insertTextRules & 4) {
		const snippet = new SnippetParser().parse(insertText);
		const model = suggestController.editor.getModel();
		if (snippet.children.length > 100) return;
		SnippetSession.adjustWhitespace(model, position, snippet, true, true);
		insertText = snippet.toString();
		isSnippetText = true;
	}
	const info = suggestController.getOverwriteInfo(item, toggleMode);
	return {
		isSnippetText,
		completionItemKind: item.completion.kind,
		normalizedInlineCompletion: {
			insertText,
			filterText: insertText,
			range: Range$1.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0))),
			snippetInfo: void 0,
			additionalTextEdits: []
		}
	};
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/suggestWidgetPreviewModel.js
var __decorate$34 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$34 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$21 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var SuggestWidgetPreviewModel = class SuggestWidgetPreviewModel$1 extends BaseGhostTextWidgetModel {
	constructor(editor$1, cache, languageFeaturesService) {
		super(editor$1);
		this.cache = cache;
		this.languageFeaturesService = languageFeaturesService;
		this.suggestionInlineCompletionSource = this._register(new SuggestWidgetInlineCompletionProvider(this.editor, () => {
			var _a$5, _b$1;
			return (_b$1 = (_a$5 = this.cache.value) === null || _a$5 === void 0 ? void 0 : _a$5.completions[0]) === null || _b$1 === void 0 ? void 0 : _b$1.toLiveInlineCompletion();
		}));
		this.updateOperation = this._register(new MutableDisposable());
		this.updateCacheSoon = this._register(new RunOnceScheduler(() => this.updateCache(), 50));
		this.minReservedLineCount = 0;
		this._register(this.suggestionInlineCompletionSource.onDidChange(() => {
			if (!this.editor.hasModel()) return;
			this.updateCacheSoon.schedule();
			if (!this.suggestionInlineCompletionSource.state) this.minReservedLineCount = 0;
			const newGhostText = this.ghostText;
			if (newGhostText) this.minReservedLineCount = Math.max(this.minReservedLineCount, sum(newGhostText.parts.map((p) => p.lines.length - 1)));
			if (this.minReservedLineCount >= 1) this.suggestionInlineCompletionSource.forceRenderingAbove();
			else this.suggestionInlineCompletionSource.stopForceRenderingAbove();
			this.onDidChangeEmitter.fire();
		}));
		this._register(this.cache.onDidChange(() => {
			this.onDidChangeEmitter.fire();
		}));
		this._register(this.editor.onDidChangeCursorPosition((e) => {
			this.minReservedLineCount = 0;
			this.updateCacheSoon.schedule();
			this.onDidChangeEmitter.fire();
		}));
		this._register(toDisposable(() => this.suggestionInlineCompletionSource.stopForceRenderingAbove()));
	}
	get isActive() {
		return this.suggestionInlineCompletionSource.state !== void 0;
	}
	isSuggestionPreviewEnabled() {
		return this.editor.getOption(108).preview;
	}
	updateCache() {
		return __awaiter$21(this, void 0, void 0, function* () {
			const state = this.suggestionInlineCompletionSource.state;
			if (!state || !state.selectedItem) return;
			const info = {
				text: state.selectedItem.normalizedInlineCompletion.insertText,
				range: state.selectedItem.normalizedInlineCompletion.range,
				isSnippetText: state.selectedItem.isSnippetText,
				completionKind: state.selectedItem.completionItemKind
			};
			const position = this.editor.getPosition();
			if (state.selectedItem.isSnippetText || state.selectedItem.completionItemKind === 27 || state.selectedItem.completionItemKind === 20 || state.selectedItem.completionItemKind === 23) {
				this.cache.clear();
				return;
			}
			const promise = createCancelablePromise((token) => __awaiter$21(this, void 0, void 0, function* () {
				let result;
				try {
					result = yield provideInlineCompletions(this.languageFeaturesService.inlineCompletionsProvider, position, this.editor.getModel(), {
						triggerKind: InlineCompletionTriggerKind.Automatic,
						selectedSuggestionInfo: info
					}, token);
				} catch (e) {
					onUnexpectedError(e);
					return;
				}
				if (token.isCancellationRequested) {
					result.dispose();
					return;
				}
				this.cache.setValue(this.editor, result, InlineCompletionTriggerKind.Automatic);
				this.onDidChangeEmitter.fire();
			}));
			const operation = new UpdateOperation(promise, InlineCompletionTriggerKind.Automatic);
			this.updateOperation.value = operation;
			yield promise;
			if (this.updateOperation.value === operation) this.updateOperation.clear();
		});
	}
	get ghostText() {
		var _a$5, _b$1, _c$1;
		const isSuggestionPreviewEnabled = this.isSuggestionPreviewEnabled();
		const model = this.editor.getModel();
		const augmentedCompletion = minimizeInlineCompletion(model, (_b$1 = (_a$5 = this.cache.value) === null || _a$5 === void 0 ? void 0 : _a$5.completions[0]) === null || _b$1 === void 0 ? void 0 : _b$1.toLiveInlineCompletion());
		const suggestWidgetState = this.suggestionInlineCompletionSource.state;
		const suggestInlineCompletion = minimizeInlineCompletion(model, (_c$1 = suggestWidgetState === null || suggestWidgetState === void 0 ? void 0 : suggestWidgetState.selectedItem) === null || _c$1 === void 0 ? void 0 : _c$1.normalizedInlineCompletion);
		const isAugmentedCompletionValid = augmentedCompletion && suggestInlineCompletion && augmentedCompletion.insertText.startsWith(suggestInlineCompletion.insertText) && augmentedCompletion.range.equalsRange(suggestInlineCompletion.range);
		if (!isSuggestionPreviewEnabled && !isAugmentedCompletionValid) return;
		const finalCompletion = isAugmentedCompletionValid ? augmentedCompletion : suggestInlineCompletion || augmentedCompletion;
		const inlineCompletionPreviewLength = isAugmentedCompletionValid ? finalCompletion.insertText.length - suggestInlineCompletion.insertText.length : 0;
		return this.toGhostText(finalCompletion, inlineCompletionPreviewLength);
	}
	toGhostText(completion, inlineCompletionPreviewLength) {
		const mode = this.editor.getOptions().get(108).previewMode;
		return completion ? inlineCompletionToGhostText(completion, this.editor.getModel(), mode, this.editor.getPosition(), inlineCompletionPreviewLength) || new GhostText(completion.range.endLineNumber, [], this.minReservedLineCount) : void 0;
	}
};
SuggestWidgetPreviewModel = __decorate$34([__param$34(2, ILanguageFeaturesService)], SuggestWidgetPreviewModel);
function sum(arr) {
	return arr.reduce((a, b) => a + b, 0);
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextModel.js
var __decorate$33 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$33 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$20 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var DelegatingModel = class extends Disposable {
	constructor() {
		super(...arguments);
		this.onDidChangeEmitter = new Emitter$1();
		this.onDidChange = this.onDidChangeEmitter.event;
		this.hasCachedGhostText = false;
		this.currentModelRef = this._register(new MutableDisposable());
	}
	get targetModel() {
		var _a$5;
		return (_a$5 = this.currentModelRef.value) === null || _a$5 === void 0 ? void 0 : _a$5.object;
	}
	setTargetModel(model) {
		var _a$5;
		if (((_a$5 = this.currentModelRef.value) === null || _a$5 === void 0 ? void 0 : _a$5.object) === model) return;
		this.currentModelRef.clear();
		this.currentModelRef.value = model ? createDisposableRef(model, model.onDidChange(() => {
			this.hasCachedGhostText = false;
			this.onDidChangeEmitter.fire();
		})) : void 0;
		this.hasCachedGhostText = false;
		this.onDidChangeEmitter.fire();
	}
	get ghostText() {
		var _a$5, _b$1;
		if (!this.hasCachedGhostText) {
			this.cachedGhostText = (_b$1 = (_a$5 = this.currentModelRef.value) === null || _a$5 === void 0 ? void 0 : _a$5.object) === null || _b$1 === void 0 ? void 0 : _b$1.ghostText;
			this.hasCachedGhostText = true;
		}
		return this.cachedGhostText;
	}
	setExpanded(expanded) {
		var _a$5;
		(_a$5 = this.targetModel) === null || _a$5 === void 0 || _a$5.setExpanded(expanded);
	}
	get minReservedLineCount() {
		return this.targetModel ? this.targetModel.minReservedLineCount : 0;
	}
};
/**
* A ghost text model that is both driven by inline completions and the suggest widget.
*/
var GhostTextModel = class GhostTextModel$1 extends DelegatingModel {
	constructor(editor$1, instantiationService) {
		super();
		this.editor = editor$1;
		this.instantiationService = instantiationService;
		this.sharedCache = this._register(new SharedInlineCompletionCache());
		this.suggestWidgetAdapterModel = this._register(this.instantiationService.createInstance(SuggestWidgetPreviewModel, this.editor, this.sharedCache));
		this.inlineCompletionsModel = this._register(this.instantiationService.createInstance(InlineCompletionsModel, this.editor, this.sharedCache));
		this._register(this.suggestWidgetAdapterModel.onDidChange(() => {
			this.updateModel();
		}));
		this.updateModel();
	}
	get activeInlineCompletionsModel() {
		if (this.targetModel === this.inlineCompletionsModel) return this.inlineCompletionsModel;
	}
	updateModel() {
		this.setTargetModel(this.suggestWidgetAdapterModel.isActive ? this.suggestWidgetAdapterModel : this.inlineCompletionsModel);
		this.inlineCompletionsModel.setActive(this.targetModel === this.inlineCompletionsModel);
	}
	shouldShowHoverAt(hoverRange) {
		var _a$5;
		const ghostText = (_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 ? void 0 : _a$5.ghostText;
		if (ghostText) return ghostText.parts.some((p) => hoverRange.containsPosition(new Position$1(ghostText.lineNumber, p.column)));
		return false;
	}
	triggerInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 || _a$5.trigger(InlineCompletionTriggerKind.Explicit);
	}
	commitInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 || _a$5.commitCurrentSuggestion();
	}
	hideInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 || _a$5.hide();
	}
	showNextInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 || _a$5.showNext();
	}
	showPreviousInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 || _a$5.showPrevious();
	}
	hasMultipleInlineCompletions() {
		var _a$5;
		return __awaiter$20(this, void 0, void 0, function* () {
			const result = yield (_a$5 = this.activeInlineCompletionsModel) === null || _a$5 === void 0 ? void 0 : _a$5.hasMultipleInlineCompletions();
			return result !== void 0 ? result : false;
		});
	}
};
GhostTextModel = __decorate$33([__param$33(1, IInstantiationService)], GhostTextModel);
var SharedInlineCompletionCache = class extends Disposable {
	constructor() {
		super(...arguments);
		this.onDidChangeEmitter = new Emitter$1();
		this.onDidChange = this.onDidChangeEmitter.event;
		this.cache = this._register(new MutableDisposable());
	}
	get value() {
		return this.cache.value;
	}
	setValue(editor$1, completionsSource, triggerKind) {
		this.cache.value = new SynchronizedInlineCompletionsCache(completionsSource, editor$1, () => this.onDidChangeEmitter.fire(), triggerKind);
	}
	clearAndLeak() {
		return this.cache.clearAndLeak();
	}
	clear() {
		this.cache.clear();
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextWidget.js
var __decorate$32 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$32 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var _a$1;
var ttPolicy = (_a$1 = window.trustedTypes) === null || _a$1 === void 0 ? void 0 : _a$1.createPolicy("editorGhostText", { createHTML: (value) => value });
var GhostTextWidget = class GhostTextWidget$1 extends Disposable {
	constructor(editor$1, model, instantiationService, languageService) {
		super();
		this.editor = editor$1;
		this.model = model;
		this.instantiationService = instantiationService;
		this.languageService = languageService;
		this.disposed = false;
		this.partsWidget = this._register(this.instantiationService.createInstance(DecorationsWidget, this.editor));
		this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor, this.languageService.languageIdCodec));
		this.viewMoreContentWidget = void 0;
		this.replacementDecoration = this._register(new DisposableDecorations(this.editor));
		this._register(this.editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(29) || e.hasChanged(107) || e.hasChanged(90) || e.hasChanged(85) || e.hasChanged(47) || e.hasChanged(46) || e.hasChanged(61)) this.update();
		}));
		this._register(toDisposable(() => {
			var _a$5;
			this.disposed = true;
			this.update();
			(_a$5 = this.viewMoreContentWidget) === null || _a$5 === void 0 || _a$5.dispose();
			this.viewMoreContentWidget = void 0;
		}));
		this._register(model.onDidChange(() => {
			this.update();
		}));
		this.update();
	}
	shouldShowHoverAtViewZone(viewZoneId) {
		return this.additionalLinesWidget.viewZoneId === viewZoneId;
	}
	update() {
		var _a$5;
		const ghostText = this.model.ghostText;
		if (!this.editor.hasModel() || !ghostText || this.disposed) {
			this.partsWidget.clear();
			this.additionalLinesWidget.clear();
			this.replacementDecoration.clear();
			return;
		}
		const inlineTexts = new Array();
		const additionalLines = new Array();
		function addToAdditionalLines(lines, className) {
			if (additionalLines.length > 0) {
				const lastLine = additionalLines[additionalLines.length - 1];
				if (className) lastLine.decorations.push(new LineDecoration(lastLine.content.length + 1, lastLine.content.length + 1 + lines[0].length, className, 0));
				lastLine.content += lines[0];
				lines = lines.slice(1);
			}
			for (const line of lines) additionalLines.push({
				content: line,
				decorations: className ? [new LineDecoration(1, line.length + 1, className, 0)] : []
			});
		}
		if (ghostText instanceof GhostTextReplacement) this.replacementDecoration.setDecorations([{
			range: new Range$1(ghostText.lineNumber, ghostText.columnStart, ghostText.lineNumber, ghostText.columnStart + ghostText.length),
			options: {
				inlineClassName: "inline-completion-text-to-replace",
				description: "GhostTextReplacement"
			}
		}]);
		else this.replacementDecoration.setDecorations([]);
		const textBufferLine = this.editor.getModel().getLineContent(ghostText.lineNumber);
		let hiddenTextStartColumn = void 0;
		let lastIdx = 0;
		for (const part of ghostText.parts) {
			let lines = part.lines;
			if (hiddenTextStartColumn === void 0) {
				inlineTexts.push({
					column: part.column,
					text: lines[0],
					preview: part.preview
				});
				lines = lines.slice(1);
			} else addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], void 0);
			if (lines.length > 0) {
				addToAdditionalLines(lines, "ghost-text");
				if (hiddenTextStartColumn === void 0 && part.column <= textBufferLine.length) hiddenTextStartColumn = part.column;
			}
			lastIdx = part.column - 1;
		}
		if (hiddenTextStartColumn !== void 0) addToAdditionalLines([textBufferLine.substring(lastIdx)], void 0);
		this.partsWidget.setParts(ghostText.lineNumber, inlineTexts, hiddenTextStartColumn !== void 0 ? {
			column: hiddenTextStartColumn,
			length: textBufferLine.length + 1 - hiddenTextStartColumn
		} : void 0);
		this.additionalLinesWidget.updateLines(ghostText.lineNumber, additionalLines, ghostText.additionalReservedLineCount);
		(_a$5 = this.viewMoreContentWidget) === null || _a$5 === void 0 || _a$5.dispose();
		this.viewMoreContentWidget = void 0;
	}
	renderViewMoreLines(position, firstLineText, remainingLinesLength) {
		const fontInfo = this.editor.getOption(46);
		const domNode = document.createElement("div");
		domNode.className = "suggest-preview-additional-widget";
		applyFontInfo(domNode, fontInfo);
		const spacer = document.createElement("span");
		spacer.className = "content-spacer";
		spacer.append(firstLineText);
		domNode.append(spacer);
		const newline = document.createElement("span");
		newline.className = "content-newline suggest-preview-text";
		newline.append("  ");
		domNode.append(newline);
		const disposableStore = new DisposableStore();
		const button = document.createElement("div");
		button.className = "button suggest-preview-text";
		button.append(`+${remainingLinesLength} lines`);
		disposableStore.add(addStandardDisposableListener(button, "mousedown", (e) => {
			var _a$5;
			(_a$5 = this.model) === null || _a$5 === void 0 || _a$5.setExpanded(true);
			e.preventDefault();
			this.editor.focus();
		}));
		domNode.append(button);
		return new ViewMoreLinesContentWidget(this.editor, position, domNode, disposableStore);
	}
};
GhostTextWidget = __decorate$32([__param$32(2, IInstantiationService), __param$32(3, ILanguageService)], GhostTextWidget);
var DisposableDecorations = class {
	constructor(editor$1) {
		this.editor = editor$1;
		this.decorationIds = [];
	}
	setDecorations(decorations) {
		this.editor.changeDecorations((accessor) => {
			this.decorationIds = accessor.deltaDecorations(this.decorationIds, decorations);
		});
	}
	clear() {
		this.setDecorations([]);
	}
	dispose() {
		this.clear();
	}
};
var DecorationsWidget = class {
	constructor(editor$1) {
		this.editor = editor$1;
		this.decorationIds = [];
	}
	dispose() {
		this.clear();
	}
	clear() {
		this.editor.changeDecorations((accessor) => {
			this.decorationIds = accessor.deltaDecorations(this.decorationIds, []);
		});
	}
	setParts(lineNumber, parts, hiddenText) {
		if (!this.editor.getModel()) return;
		const hiddenTextDecorations = new Array();
		if (hiddenText) hiddenTextDecorations.push({
			range: Range$1.fromPositions(new Position$1(lineNumber, hiddenText.column), new Position$1(lineNumber, hiddenText.column + hiddenText.length)),
			options: {
				inlineClassName: "ghost-text-hidden",
				description: "ghost-text-hidden"
			}
		});
		this.editor.changeDecorations((accessor) => {
			this.decorationIds = accessor.deltaDecorations(this.decorationIds, parts.map((p) => {
				return {
					range: Range$1.fromPositions(new Position$1(lineNumber, p.column)),
					options: {
						description: "ghost-text",
						after: {
							content: p.text,
							inlineClassName: p.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration",
							cursorStops: InjectedTextCursorStops.Left
						},
						showIfCollapsed: true
					}
				};
			}).concat(hiddenTextDecorations));
		});
	}
};
var AdditionalLinesWidget = class {
	constructor(editor$1, languageIdCodec) {
		this.editor = editor$1;
		this.languageIdCodec = languageIdCodec;
		this._viewZoneId = void 0;
	}
	get viewZoneId() {
		return this._viewZoneId;
	}
	dispose() {
		this.clear();
	}
	clear() {
		this.editor.changeViewZones((changeAccessor) => {
			if (this._viewZoneId) {
				changeAccessor.removeZone(this._viewZoneId);
				this._viewZoneId = void 0;
			}
		});
	}
	updateLines(lineNumber, additionalLines, minReservedLineCount) {
		const textModel = this.editor.getModel();
		if (!textModel) return;
		const { tabSize } = textModel.getOptions();
		this.editor.changeViewZones((changeAccessor) => {
			if (this._viewZoneId) {
				changeAccessor.removeZone(this._viewZoneId);
				this._viewZoneId = void 0;
			}
			const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
			if (heightInLines > 0) {
				const domNode = document.createElement("div");
				renderLines(domNode, tabSize, additionalLines, this.editor.getOptions(), this.languageIdCodec);
				this._viewZoneId = changeAccessor.addZone({
					afterLineNumber: lineNumber,
					heightInLines,
					domNode,
					afterColumnAffinity: 1
				});
			}
		});
	}
};
function renderLines(domNode, tabSize, lines, opts, languageIdCodec) {
	const disableMonospaceOptimizations = opts.get(29);
	const stopRenderingLineAfter = opts.get(107);
	const renderWhitespace = "none";
	const renderControlCharacters = opts.get(85);
	const fontLigatures = opts.get(47);
	const fontInfo = opts.get(46);
	const lineHeight = opts.get(61);
	const sb = createStringBuilder(1e4);
	sb.appendASCIIString("<div class=\"suggest-preview-text\">");
	for (let i = 0, len = lines.length; i < len; i++) {
		const lineData = lines[i];
		const line = lineData.content;
		sb.appendASCIIString("<div class=\"view-line");
		sb.appendASCIIString("\" style=\"top:");
		sb.appendASCIIString(String(i * lineHeight));
		sb.appendASCIIString("px;width:1000000px;\">");
		const isBasicASCII$1 = isBasicASCII(line);
		const containsRTL$1 = containsRTL(line);
		const lineTokens = LineTokens.createEmpty(line, languageIdCodec);
		renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII$1, containsRTL$1, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null), sb);
		sb.appendASCIIString("</div>");
	}
	sb.appendASCIIString("</div>");
	applyFontInfo(domNode, fontInfo);
	const html = sb.build();
	domNode.innerHTML = ttPolicy ? ttPolicy.createHTML(html) : html;
}
var ViewMoreLinesContentWidget = class extends Disposable {
	constructor(editor$1, position, domNode, disposableStore) {
		super();
		this.editor = editor$1;
		this.position = position;
		this.domNode = domNode;
		this.allowEditorOverflow = false;
		this.suppressMouseDown = false;
		this._register(disposableStore);
		this._register(toDisposable(() => {
			this.editor.removeContentWidget(this);
		}));
		this.editor.addContentWidget(this);
	}
	getId() {
		return "editor.widget.viewMoreLinesWidget";
	}
	getDomNode() {
		return this.domNode;
	}
	getPosition() {
		return {
			position: this.position,
			preference: [0]
		};
	}
};
registerThemingParticipant((theme, collector) => {
	const foreground$1 = theme.getColor(ghostTextForeground);
	if (foreground$1) {
		collector.addRule(`.monaco-editor .ghost-text-decoration { color: ${foreground$1.toString()} !important; }`);
		collector.addRule(`.monaco-editor .ghost-text-decoration-preview { color: ${foreground$1.toString()} !important; }`);
		collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { color: ${foreground$1.toString()} !important; }`);
	}
	const background = theme.getColor(ghostTextBackground);
	if (background) {
		collector.addRule(`.monaco-editor .ghost-text-decoration { background-color: ${background.toString()}; }`);
		collector.addRule(`.monaco-editor .ghost-text-decoration-preview { background-color: ${background.toString()}; }`);
		collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { background-color: ${background.toString()}; }`);
	}
	const border = theme.getColor(ghostTextBorder);
	if (border) {
		collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { border: 1px solid ${border}; }`);
		collector.addRule(`.monaco-editor .ghost-text-decoration { border: 1px solid ${border}; }`);
		collector.addRule(`.monaco-editor .ghost-text-decoration-preview { border: 1px solid ${border}; }`);
	}
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextController.js
var __decorate$31 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$31 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$19 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var GhostTextController = class GhostTextController$1 extends Disposable {
	constructor(editor$1, instantiationService) {
		super();
		this.editor = editor$1;
		this.instantiationService = instantiationService;
		this.triggeredExplicitly = false;
		this.activeController = this._register(new MutableDisposable());
		this.activeModelDidChangeEmitter = this._register(new Emitter$1());
		this._register(this.editor.onDidChangeModel(() => {
			this.updateModelController();
		}));
		this._register(this.editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(108)) this.updateModelController();
			if (e.hasChanged(57)) this.updateModelController();
		}));
		this.updateModelController();
	}
	static get(editor$1) {
		return editor$1.getContribution(GhostTextController$1.ID);
	}
	get activeModel() {
		var _a$5;
		return (_a$5 = this.activeController.value) === null || _a$5 === void 0 ? void 0 : _a$5.model;
	}
	updateModelController() {
		const suggestOptions = this.editor.getOption(108);
		const inlineSuggestOptions = this.editor.getOption(57);
		this.activeController.value = void 0;
		this.activeController.value = this.editor.hasModel() && (suggestOptions.preview || inlineSuggestOptions.enabled || this.triggeredExplicitly) ? this.instantiationService.createInstance(ActiveGhostTextController, this.editor) : void 0;
		this.activeModelDidChangeEmitter.fire();
	}
	shouldShowHoverAt(hoverRange) {
		var _a$5;
		return ((_a$5 = this.activeModel) === null || _a$5 === void 0 ? void 0 : _a$5.shouldShowHoverAt(hoverRange)) || false;
	}
	shouldShowHoverAtViewZone(viewZoneId) {
		var _a$5, _b$1;
		return ((_b$1 = (_a$5 = this.activeController.value) === null || _a$5 === void 0 ? void 0 : _a$5.widget) === null || _b$1 === void 0 ? void 0 : _b$1.shouldShowHoverAtViewZone(viewZoneId)) || false;
	}
	trigger() {
		var _a$5;
		this.triggeredExplicitly = true;
		if (!this.activeController.value) this.updateModelController();
		(_a$5 = this.activeModel) === null || _a$5 === void 0 || _a$5.triggerInlineCompletion();
	}
	commit() {
		var _a$5;
		(_a$5 = this.activeModel) === null || _a$5 === void 0 || _a$5.commitInlineCompletion();
	}
	hide() {
		var _a$5;
		(_a$5 = this.activeModel) === null || _a$5 === void 0 || _a$5.hideInlineCompletion();
	}
	showNextInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeModel) === null || _a$5 === void 0 || _a$5.showNextInlineCompletion();
	}
	showPreviousInlineCompletion() {
		var _a$5;
		(_a$5 = this.activeModel) === null || _a$5 === void 0 || _a$5.showPreviousInlineCompletion();
	}
	hasMultipleInlineCompletions() {
		var _a$5;
		return __awaiter$19(this, void 0, void 0, function* () {
			const result = yield (_a$5 = this.activeModel) === null || _a$5 === void 0 ? void 0 : _a$5.hasMultipleInlineCompletions();
			return result !== void 0 ? result : false;
		});
	}
};
GhostTextController.inlineSuggestionVisible = new RawContextKey("inlineSuggestionVisible", false, localize("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
GhostTextController.inlineSuggestionHasIndentation = new RawContextKey("inlineSuggestionHasIndentation", false, localize("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
GhostTextController.inlineSuggestionHasIndentationLessThanTabSize = new RawContextKey("inlineSuggestionHasIndentationLessThanTabSize", true, localize("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
GhostTextController.ID = "editor.contrib.ghostTextController";
GhostTextController = __decorate$31([__param$31(1, IInstantiationService)], GhostTextController);
var GhostTextContextKeys = class {
	constructor(contextKeyService) {
		this.contextKeyService = contextKeyService;
		this.inlineCompletionVisible = GhostTextController.inlineSuggestionVisible.bindTo(this.contextKeyService);
		this.inlineCompletionSuggestsIndentation = GhostTextController.inlineSuggestionHasIndentation.bindTo(this.contextKeyService);
		this.inlineCompletionSuggestsIndentationLessThanTabSize = GhostTextController.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService);
	}
};
/**
* The controller for a text editor with an initialized text model.
* Must be disposed as soon as the model detaches from the editor.
*/
var ActiveGhostTextController = class ActiveGhostTextController$1 extends Disposable {
	constructor(editor$1, instantiationService, contextKeyService) {
		super();
		this.editor = editor$1;
		this.instantiationService = instantiationService;
		this.contextKeyService = contextKeyService;
		this.contextKeys = new GhostTextContextKeys(this.contextKeyService);
		this.model = this._register(this.instantiationService.createInstance(GhostTextModel, this.editor));
		this.widget = this._register(this.instantiationService.createInstance(GhostTextWidget, this.editor, this.model));
		this._register(toDisposable(() => {
			this.contextKeys.inlineCompletionVisible.set(false);
			this.contextKeys.inlineCompletionSuggestsIndentation.set(false);
			this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(true);
		}));
		this._register(this.model.onDidChange(() => {
			this.updateContextKeys();
		}));
		this.updateContextKeys();
	}
	updateContextKeys() {
		var _a$5;
		this.contextKeys.inlineCompletionVisible.set(((_a$5 = this.model.activeInlineCompletionsModel) === null || _a$5 === void 0 ? void 0 : _a$5.ghostText) !== void 0);
		let startsWithIndentation = false;
		let startsWithIndentationLessThanTabSize = true;
		const ghostText = this.model.inlineCompletionsModel.ghostText;
		if (!!this.model.activeInlineCompletionsModel && ghostText && ghostText.parts.length > 0) {
			const { column, lines } = ghostText.parts[0];
			const firstLine = lines[0];
			if (column <= this.editor.getModel().getLineIndentColumn(ghostText.lineNumber)) {
				let firstNonWsIdx = firstNonWhitespaceIndex(firstLine);
				if (firstNonWsIdx === -1) firstNonWsIdx = firstLine.length - 1;
				startsWithIndentation = firstNonWsIdx > 0;
				const tabSize = this.editor.getModel().getOptions().tabSize;
				startsWithIndentationLessThanTabSize = CursorColumns.visibleColumnFromColumn(firstLine, firstNonWsIdx + 1, tabSize) < tabSize;
			}
		}
		this.contextKeys.inlineCompletionSuggestsIndentation.set(startsWithIndentation);
		this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(startsWithIndentationLessThanTabSize);
	}
};
ActiveGhostTextController = __decorate$31([__param$31(1, IInstantiationService), __param$31(2, IContextKeyService)], ActiveGhostTextController);
var ShowNextInlineSuggestionAction = class ShowNextInlineSuggestionAction extends EditorAction {
	constructor() {
		super({
			id: ShowNextInlineSuggestionAction.ID,
			label: localize("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
			alias: "Show Next Inline Suggestion",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
			kbOpts: {
				weight: 100,
				primary: 601
			}
		});
	}
	run(accessor, editor$1) {
		return __awaiter$19(this, void 0, void 0, function* () {
			const controller = GhostTextController.get(editor$1);
			if (controller) {
				controller.showNextInlineCompletion();
				editor$1.focus();
			}
		});
	}
};
ShowNextInlineSuggestionAction.ID = "editor.action.inlineSuggest.showNext";
var ShowPreviousInlineSuggestionAction = class ShowPreviousInlineSuggestionAction extends EditorAction {
	constructor() {
		super({
			id: ShowPreviousInlineSuggestionAction.ID,
			label: localize("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
			alias: "Show Previous Inline Suggestion",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
			kbOpts: {
				weight: 100,
				primary: 599
			}
		});
	}
	run(accessor, editor$1) {
		return __awaiter$19(this, void 0, void 0, function* () {
			const controller = GhostTextController.get(editor$1);
			if (controller) {
				controller.showPreviousInlineCompletion();
				editor$1.focus();
			}
		});
	}
};
ShowPreviousInlineSuggestionAction.ID = "editor.action.inlineSuggest.showPrevious";
var TriggerInlineSuggestionAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.inlineSuggest.trigger",
			label: localize("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
			alias: "Trigger Inline Suggestion",
			precondition: EditorContextKeys.writable
		});
	}
	run(accessor, editor$1) {
		return __awaiter$19(this, void 0, void 0, function* () {
			const controller = GhostTextController.get(editor$1);
			if (controller) controller.trigger();
		});
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextHoverParticipant.js
var __decorate$30 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$30 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var InlineCompletionsHover = class {
	constructor(owner, range, controller) {
		this.owner = owner;
		this.range = range;
		this.controller = controller;
	}
	isValidForHoverAnchor(anchor) {
		return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
	}
	hasMultipleSuggestions() {
		return this.controller.hasMultipleInlineCompletions();
	}
	get commands() {
		var _a$5, _b$1, _c$1;
		return ((_c$1 = (_b$1 = (_a$5 = this.controller.activeModel) === null || _a$5 === void 0 ? void 0 : _a$5.activeInlineCompletionsModel) === null || _b$1 === void 0 ? void 0 : _b$1.completionSession.value) === null || _c$1 === void 0 ? void 0 : _c$1.commands) || [];
	}
};
var InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant$1 {
	constructor(_editor, _commandService, _menuService, _contextKeyService, _languageService, _openerService, accessibilityService) {
		this._editor = _editor;
		this._commandService = _commandService;
		this._menuService = _menuService;
		this._contextKeyService = _contextKeyService;
		this._languageService = _languageService;
		this._openerService = _openerService;
		this.accessibilityService = accessibilityService;
		this.hoverOrdinal = 3;
	}
	suggestHoverAnchor(mouseEvent) {
		const controller = GhostTextController.get(this._editor);
		if (!controller) return null;
		const target = mouseEvent.target;
		if (target.type === 8) {
			const viewZoneData = target.detail;
			if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) return new HoverForeignElementAnchor(1e3, this, Range$1.fromPositions(viewZoneData.positionBefore || viewZoneData.position, viewZoneData.positionBefore || viewZoneData.position));
		}
		if (target.type === 7) {
			if (controller.shouldShowHoverAt(target.range)) return new HoverForeignElementAnchor(1e3, this, target.range);
		}
		if (target.type === 6) {
			if (target.detail.mightBeForeignElement && controller.shouldShowHoverAt(target.range)) return new HoverForeignElementAnchor(1e3, this, target.range);
		}
		return null;
	}
	computeSync(anchor, lineDecorations) {
		const controller = GhostTextController.get(this._editor);
		if (controller && controller.shouldShowHoverAt(anchor.range)) return [new InlineCompletionsHover(this, anchor.range, controller)];
		return [];
	}
	renderHoverParts(context, hoverParts) {
		const disposableStore = new DisposableStore();
		const part = hoverParts[0];
		if (this.accessibilityService.isScreenReaderOptimized()) this.renderScreenReaderText(context, part, disposableStore);
		const menu = disposableStore.add(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
		const previousAction = context.statusBar.addAction({
			label: localize("showNextInlineSuggestion", "Next"),
			commandId: ShowNextInlineSuggestionAction.ID,
			run: () => this._commandService.executeCommand(ShowNextInlineSuggestionAction.ID)
		});
		const nextAction = context.statusBar.addAction({
			label: localize("showPreviousInlineSuggestion", "Previous"),
			commandId: ShowPreviousInlineSuggestionAction.ID,
			run: () => this._commandService.executeCommand(ShowPreviousInlineSuggestionAction.ID)
		});
		context.statusBar.addAction({
			label: localize("acceptInlineSuggestion", "Accept"),
			commandId: inlineSuggestCommitId,
			run: () => this._commandService.executeCommand(inlineSuggestCommitId)
		});
		const actions = [previousAction, nextAction];
		for (const action of actions) action.setEnabled(false);
		part.hasMultipleSuggestions().then((hasMore) => {
			for (const action of actions) action.setEnabled(hasMore);
		});
		for (const command of part.commands) context.statusBar.addAction({
			label: command.title,
			commandId: command.id,
			run: () => this._commandService.executeCommand(command.id, ...command.arguments || [])
		});
		for (const [_, group] of menu.getActions()) for (const action of group) if (action instanceof MenuItemAction) context.statusBar.addAction({
			label: action.label,
			commandId: action.item.id,
			run: () => this._commandService.executeCommand(action.item.id)
		});
		return disposableStore;
	}
	renderScreenReaderText(context, part, disposableStore) {
		var _a$5, _b$1;
		const $$8 = $;
		const markdownHoverElement = $$8("div.hover-row.markdown-hover");
		const hoverContentsElement = append(markdownHoverElement, $$8("div.hover-contents"));
		const renderer = disposableStore.add(new MarkdownRenderer({ editor: this._editor }, this._languageService, this._openerService));
		const render = (code) => {
			disposableStore.add(renderer.onDidRenderAsync(() => {
				hoverContentsElement.className = "hover-contents code-hover-contents";
				context.onContentsChanged();
			}));
			const inlineSuggestionAvailable = localize("inlineSuggestionFollows", "Suggestion:");
			const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code)));
			hoverContentsElement.replaceChildren(renderedContents.element);
		};
		const ghostText = (_b$1 = (_a$5 = part.controller.activeModel) === null || _a$5 === void 0 ? void 0 : _a$5.inlineCompletionsModel) === null || _b$1 === void 0 ? void 0 : _b$1.ghostText;
		if (ghostText) {
			const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
			render(ghostText.renderForScreenReader(lineText));
		}
		context.fragment.appendChild(markdownHoverElement);
	}
};
InlineCompletionsHoverParticipant = __decorate$30([
	__param$30(1, ICommandService),
	__param$30(2, IMenuService),
	__param$30(3, IContextKeyService),
	__param$30(4, ILanguageService),
	__param$30(5, IOpenerService),
	__param$30(6, IAccessibilityService)
], InlineCompletionsHoverParticipant);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.contribution.js
registerEditorContribution(GhostTextController.ID, GhostTextController);
registerEditorAction(TriggerInlineSuggestionAction);
registerEditorAction(ShowNextInlineSuggestionAction);
registerEditorAction(ShowPreviousInlineSuggestionAction);
HoverParticipantRegistry.register(InlineCompletionsHoverParticipant);
var GhostTextCommand = EditorCommand.bindToContribution(GhostTextController.get);
const commitInlineSuggestionAction = new GhostTextCommand({
	id: inlineSuggestCommitId,
	precondition: GhostTextController.inlineSuggestionVisible,
	handler(x) {
		x.commit();
		x.editor.focus();
	}
});
registerEditorCommand(commitInlineSuggestionAction);
KeybindingsRegistry.registerKeybindingRule({
	primary: 2,
	weight: 200,
	id: commitInlineSuggestionAction.id,
	when: ContextKeyExpr.and(commitInlineSuggestionAction.precondition, EditorContextKeys.tabMovesFocus.toNegated(), GhostTextController.inlineSuggestionHasIndentationLessThanTabSize)
});
registerEditorCommand(new GhostTextCommand({
	id: "editor.action.inlineSuggest.hide",
	precondition: GhostTextController.inlineSuggestionVisible,
	kbOpts: {
		weight: 100,
		primary: 9
	},
	handler(x) {
		x.hide();
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentUtils.js
function getSpaceCnt(str, tabSize) {
	let spacesCnt = 0;
	for (let i = 0; i < str.length; i++) if (str.charAt(i) === "	") spacesCnt += tabSize;
	else spacesCnt++;
	return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
	spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
	let result = "";
	if (!insertSpaces) {
		const tabsCnt = Math.floor(spacesCnt / tabSize);
		spacesCnt = spacesCnt % tabSize;
		for (let i = 0; i < tabsCnt; i++) result += "	";
	}
	for (let i = 0; i < spacesCnt; i++) result += " ";
	return result;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
var __decorate$29 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$29 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber, inheritedIndent) {
	if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) return [];
	const indentationRules = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentationRules;
	if (!indentationRules) return [];
	endLineNumber = Math.min(endLineNumber, model.getLineCount());
	while (startLineNumber <= endLineNumber) {
		if (!indentationRules.unIndentedLinePattern) break;
		const text = model.getLineContent(startLineNumber);
		if (!indentationRules.unIndentedLinePattern.test(text)) break;
		startLineNumber++;
	}
	if (startLineNumber > endLineNumber - 1) return [];
	const { tabSize, indentSize, insertSpaces } = model.getOptions();
	const shiftIndent = (indentation, count) => {
		count = count || 1;
		return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
	};
	const unshiftIndent = (indentation, count) => {
		count = count || 1;
		return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
	};
	const indentEdits = [];
	let globalIndent;
	const currentLineText = model.getLineContent(startLineNumber);
	let adjustedLineContent = currentLineText;
	if (inheritedIndent !== void 0 && inheritedIndent !== null) {
		globalIndent = inheritedIndent;
		const oldIndentation = getLeadingWhitespace(currentLineText);
		adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
		if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
			globalIndent = unshiftIndent(globalIndent);
			adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
		}
		if (currentLineText !== adjustedLineContent) indentEdits.push(EditOperation.replaceMove(new Selection$1(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), normalizeIndentation(globalIndent, indentSize, insertSpaces)));
	} else globalIndent = getLeadingWhitespace(currentLineText);
	let idealIndentForNextLine = globalIndent;
	if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
		idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
		globalIndent = shiftIndent(globalIndent);
	} else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
	startLineNumber++;
	for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
		const text = model.getLineContent(lineNumber);
		const oldIndentation = getLeadingWhitespace(text);
		const adjustedLineContent$1 = idealIndentForNextLine + text.substring(oldIndentation.length);
		if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent$1)) {
			idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
			globalIndent = unshiftIndent(globalIndent);
		}
		if (oldIndentation !== idealIndentForNextLine) indentEdits.push(EditOperation.replaceMove(new Selection$1(lineNumber, 1, lineNumber, oldIndentation.length + 1), normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
		if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) continue;
		else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent$1)) {
			globalIndent = shiftIndent(globalIndent);
			idealIndentForNextLine = globalIndent;
		} else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent$1)) idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
		else idealIndentForNextLine = globalIndent;
	}
	return indentEdits;
}
var IndentationToSpacesAction = class IndentationToSpacesAction extends EditorAction {
	constructor() {
		super({
			id: IndentationToSpacesAction.ID,
			label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
			alias: "Convert Indentation to Spaces",
			precondition: EditorContextKeys.writable
		});
	}
	run(accessor, editor$1) {
		const model = editor$1.getModel();
		if (!model) return;
		const modelOpts = model.getOptions();
		const selection = editor$1.getSelection();
		if (!selection) return;
		const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, [command]);
		editor$1.pushUndoStop();
		model.updateOptions({ insertSpaces: true });
	}
};
IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
var IndentationToTabsAction = class IndentationToTabsAction extends EditorAction {
	constructor() {
		super({
			id: IndentationToTabsAction.ID,
			label: localize("indentationToTabs", "Convert Indentation to Tabs"),
			alias: "Convert Indentation to Tabs",
			precondition: EditorContextKeys.writable
		});
	}
	run(accessor, editor$1) {
		const model = editor$1.getModel();
		if (!model) return;
		const modelOpts = model.getOptions();
		const selection = editor$1.getSelection();
		if (!selection) return;
		const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, [command]);
		editor$1.pushUndoStop();
		model.updateOptions({ insertSpaces: false });
	}
};
IndentationToTabsAction.ID = "editor.action.indentationToTabs";
var ChangeIndentationSizeAction = class extends EditorAction {
	constructor(insertSpaces, opts) {
		super(opts);
		this.insertSpaces = insertSpaces;
	}
	run(accessor, editor$1) {
		const quickInputService = accessor.get(IQuickInputService);
		const modelService = accessor.get(IModelService);
		const model = editor$1.getModel();
		if (!model) return;
		const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
		const picks = [
			1,
			2,
			3,
			4,
			5,
			6,
			7,
			8
		].map((n) => ({
			id: n.toString(),
			label: n.toString(),
			description: n === creationOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : void 0
		}));
		const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
		setTimeout(() => {
			quickInputService.pick(picks, {
				placeHolder: localize({
					key: "selectTabWidth",
					comment: ["Tab corresponds to the tab key"]
				}, "Select Tab Size for Current File"),
				activeItem: picks[autoFocusIndex]
			}).then((pick) => {
				if (pick) {
					if (model && !model.isDisposed()) model.updateOptions({
						tabSize: parseInt(pick.label, 10),
						insertSpaces: this.insertSpaces
					});
				}
			});
		}, 50);
	}
};
var IndentUsingTabs = class IndentUsingTabs extends ChangeIndentationSizeAction {
	constructor() {
		super(false, {
			id: IndentUsingTabs.ID,
			label: localize("indentUsingTabs", "Indent Using Tabs"),
			alias: "Indent Using Tabs",
			precondition: void 0
		});
	}
};
IndentUsingTabs.ID = "editor.action.indentUsingTabs";
var IndentUsingSpaces = class IndentUsingSpaces extends ChangeIndentationSizeAction {
	constructor() {
		super(true, {
			id: IndentUsingSpaces.ID,
			label: localize("indentUsingSpaces", "Indent Using Spaces"),
			alias: "Indent Using Spaces",
			precondition: void 0
		});
	}
};
IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
var DetectIndentation = class DetectIndentation extends EditorAction {
	constructor() {
		super({
			id: DetectIndentation.ID,
			label: localize("detectIndentation", "Detect Indentation from Content"),
			alias: "Detect Indentation from Content",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		const modelService = accessor.get(IModelService);
		const model = editor$1.getModel();
		if (!model) return;
		const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
		model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
	}
};
DetectIndentation.ID = "editor.action.detectIndentation";
var ReindentLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.reindentlines",
			label: localize("editor.reindentlines", "Reindent Lines"),
			alias: "Reindent Lines",
			precondition: EditorContextKeys.writable
		});
	}
	run(accessor, editor$1) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		const model = editor$1.getModel();
		if (!model) return;
		const edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());
		if (edits.length > 0) {
			editor$1.pushUndoStop();
			editor$1.executeEdits(this.id, edits);
			editor$1.pushUndoStop();
		}
	}
};
var ReindentSelectedLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.reindentselectedlines",
			label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
			alias: "Reindent Selected Lines",
			precondition: EditorContextKeys.writable
		});
	}
	run(accessor, editor$1) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		const model = editor$1.getModel();
		if (!model) return;
		const selections = editor$1.getSelections();
		if (selections === null) return;
		const edits = [];
		for (const selection of selections) {
			let startLineNumber = selection.startLineNumber;
			let endLineNumber = selection.endLineNumber;
			if (startLineNumber !== endLineNumber && selection.endColumn === 1) endLineNumber--;
			if (startLineNumber === 1) {
				if (startLineNumber === endLineNumber) continue;
			} else startLineNumber--;
			const editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);
			edits.push(...editOperations);
		}
		if (edits.length > 0) {
			editor$1.pushUndoStop();
			editor$1.executeEdits(this.id, edits);
			editor$1.pushUndoStop();
		}
	}
};
var AutoIndentOnPasteCommand = class {
	constructor(edits, initialSelection) {
		this._initialSelection = initialSelection;
		this._edits = [];
		this._selectionId = null;
		for (const edit of edits) if (edit.range && typeof edit.text === "string") this._edits.push(edit);
	}
	getEditOperations(model, builder) {
		for (const edit of this._edits) builder.addEditOperation(Range$1.lift(edit.range), edit.text);
		let selectionIsSet = false;
		if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
			if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
				selectionIsSet = true;
				this._selectionId = builder.trackSelection(this._initialSelection, true);
			} else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
				selectionIsSet = true;
				this._selectionId = builder.trackSelection(this._initialSelection, false);
			}
		}
		if (!selectionIsSet) this._selectionId = builder.trackSelection(this._initialSelection);
	}
	computeCursorState(model, helper) {
		return helper.getTrackedSelection(this._selectionId);
	}
};
var AutoIndentOnPaste = class AutoIndentOnPaste$1 {
	constructor(editor$1, _languageConfigurationService) {
		this.editor = editor$1;
		this._languageConfigurationService = _languageConfigurationService;
		this.callOnDispose = new DisposableStore();
		this.callOnModel = new DisposableStore();
		this.callOnDispose.add(editor$1.onDidChangeConfiguration(() => this.update()));
		this.callOnDispose.add(editor$1.onDidChangeModel(() => this.update()));
		this.callOnDispose.add(editor$1.onDidChangeModelLanguage(() => this.update()));
	}
	update() {
		this.callOnModel.clear();
		if (this.editor.getOption(9) < 4 || this.editor.getOption(50)) return;
		if (!this.editor.hasModel()) return;
		this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
			this.trigger(range);
		}));
	}
	trigger(range) {
		const selections = this.editor.getSelections();
		if (selections === null || selections.length > 1) return;
		const model = this.editor.getModel();
		if (!model) return;
		if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber)) return;
		const autoIndent = this.editor.getOption(9);
		const { tabSize, indentSize, insertSpaces } = model.getOptions();
		const textEdits = [];
		const indentConverter = {
			shiftIndent: (indentation) => {
				return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
			},
			unshiftIndent: (indentation) => {
				return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
			}
		};
		let startLineNumber = range.startLineNumber;
		while (startLineNumber <= range.endLineNumber) {
			if (this.shouldIgnoreLine(model, startLineNumber)) {
				startLineNumber++;
				continue;
			}
			break;
		}
		if (startLineNumber > range.endLineNumber) return;
		let firstLineText = model.getLineContent(startLineNumber);
		if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
			const indentOfFirstLine = getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter, this._languageConfigurationService);
			if (indentOfFirstLine !== null) {
				const oldIndentation = getLeadingWhitespace(firstLineText);
				const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
				if (newSpaceCnt !== getSpaceCnt(oldIndentation, tabSize)) {
					const newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
					textEdits.push({
						range: new Range$1(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
						text: newIndent
					});
					firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
				} else {
					const indentMetadata = getIndentMetadata(model, startLineNumber, this._languageConfigurationService);
					if (indentMetadata === 0 || indentMetadata === 8) return;
				}
			}
		}
		const firstLineNumber = startLineNumber;
		while (startLineNumber < range.endLineNumber) {
			if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
				startLineNumber++;
				continue;
			}
			break;
		}
		if (startLineNumber !== range.endLineNumber) {
			const indentOfSecondLine = getGoodIndentForLine(autoIndent, {
				tokenization: {
					getLineTokens: (lineNumber) => {
						return model.tokenization.getLineTokens(lineNumber);
					},
					getLanguageId: () => {
						return model.getLanguageId();
					},
					getLanguageIdAtPosition: (lineNumber, column) => {
						return model.getLanguageIdAtPosition(lineNumber, column);
					}
				},
				getLineContent: (lineNumber) => {
					if (lineNumber === firstLineNumber) return firstLineText;
					else return model.getLineContent(lineNumber);
				}
			}, model.getLanguageId(), startLineNumber + 1, indentConverter, this._languageConfigurationService);
			if (indentOfSecondLine !== null) {
				const newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
				const oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
				if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
					const spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
					for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {
						const lineContent = model.getLineContent(i);
						const originalIndent = getLeadingWhitespace(lineContent);
						const newSpacesCnt = getSpaceCnt(originalIndent, tabSize) + spaceCntOffset;
						const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
						if (newIndent !== originalIndent) textEdits.push({
							range: new Range$1(i, 1, i, originalIndent.length + 1),
							text: newIndent
						});
					}
				}
			}
		}
		if (textEdits.length > 0) {
			this.editor.pushUndoStop();
			const cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
			this.editor.executeCommand("autoIndentOnPaste", cmd);
			this.editor.pushUndoStop();
		}
	}
	shouldIgnoreLine(model, lineNumber) {
		model.tokenization.forceTokenization(lineNumber);
		const nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
		if (nonWhitespaceColumn === 0) return true;
		const tokens = model.tokenization.getLineTokens(lineNumber);
		if (tokens.getCount() > 0) {
			const firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
			if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) return true;
		}
		return false;
	}
	dispose() {
		this.callOnDispose.dispose();
		this.callOnModel.dispose();
	}
};
AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
AutoIndentOnPaste = __decorate$29([__param$29(1, ILanguageConfigurationService)], AutoIndentOnPaste);
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
	if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) return;
	let spaces = "";
	for (let i = 0; i < tabSize; i++) spaces += " ";
	const spacesRegExp = new RegExp(spaces, "gi");
	for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
		let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
		if (lastIndentationColumn === 0) lastIndentationColumn = model.getLineMaxColumn(lineNumber);
		if (lastIndentationColumn === 1) continue;
		const originalIndentationRange = new Range$1(lineNumber, 1, lineNumber, lastIndentationColumn);
		const originalIndentation = model.getValueInRange(originalIndentationRange);
		const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/gi, spaces) : originalIndentation.replace(spacesRegExp, "	");
		builder.addEditOperation(originalIndentationRange, newIndentation);
	}
}
var IndentationToSpacesCommand = class {
	constructor(selection, tabSize) {
		this.selection = selection;
		this.tabSize = tabSize;
		this.selectionId = null;
	}
	getEditOperations(model, builder) {
		this.selectionId = builder.trackSelection(this.selection);
		getIndentationEditOperations(model, builder, this.tabSize, true);
	}
	computeCursorState(model, helper) {
		return helper.getTrackedSelection(this.selectionId);
	}
};
var IndentationToTabsCommand = class {
	constructor(selection, tabSize) {
		this.selection = selection;
		this.tabSize = tabSize;
		this.selectionId = null;
	}
	getEditOperations(model, builder) {
		this.selectionId = builder.trackSelection(this.selection);
		getIndentationEditOperations(model, builder, this.tabSize, false);
	}
	computeCursorState(model, helper) {
		return helper.getTrackedSelection(this.selectionId);
	}
};
registerEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHints.js
var __awaiter$18 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var InlayHintAnchor = class {
	constructor(range, direction) {
		this.range = range;
		this.direction = direction;
	}
};
var InlayHintItem = class InlayHintItem {
	constructor(hint, anchor, provider) {
		this.hint = hint;
		this.anchor = anchor;
		this.provider = provider;
		this._isResolved = false;
	}
	with(delta) {
		const result = new InlayHintItem(this.hint, delta.anchor, this.provider);
		result._isResolved = this._isResolved;
		result._currentResolve = this._currentResolve;
		return result;
	}
	resolve(token) {
		return __awaiter$18(this, void 0, void 0, function* () {
			if (typeof this.provider.resolveInlayHint !== "function") return;
			if (this._currentResolve) {
				yield this._currentResolve;
				if (token.isCancellationRequested) return;
				return this.resolve(token);
			}
			if (!this._isResolved) this._currentResolve = this._doResolve(token).finally(() => this._currentResolve = void 0);
			yield this._currentResolve;
		});
	}
	_doResolve(token) {
		var _a$5, _b$1;
		return __awaiter$18(this, void 0, void 0, function* () {
			try {
				const newHint = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, token));
				this.hint.tooltip = (_a$5 = newHint === null || newHint === void 0 ? void 0 : newHint.tooltip) !== null && _a$5 !== void 0 ? _a$5 : this.hint.tooltip;
				this.hint.label = (_b$1 = newHint === null || newHint === void 0 ? void 0 : newHint.label) !== null && _b$1 !== void 0 ? _b$1 : this.hint.label;
				this._isResolved = true;
			} catch (err) {
				onUnexpectedExternalError(err);
				this._isResolved = false;
			}
		});
	}
};
var InlayHintsFragments = class InlayHintsFragments {
	constructor(ranges, data, model) {
		this._disposables = new DisposableStore();
		this.ranges = ranges;
		this.provider = /* @__PURE__ */ new Set();
		const items = [];
		for (const [list, provider] of data) {
			this._disposables.add(list);
			this.provider.add(provider);
			for (const hint of list.hints) {
				const position = model.validatePosition(hint.position);
				let direction = "before";
				const wordRange = InlayHintsFragments._getRangeAtPosition(model, position);
				let range;
				if (wordRange.getStartPosition().isBefore(position)) {
					range = Range$1.fromPositions(wordRange.getStartPosition(), position);
					direction = "after";
				} else {
					range = Range$1.fromPositions(position, wordRange.getEndPosition());
					direction = "before";
				}
				items.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));
			}
		}
		this.items = items.sort((a, b) => Position$1.compare(a.hint.position, b.hint.position));
	}
	static create(registry, model, ranges, token) {
		return __awaiter$18(this, void 0, void 0, function* () {
			const data = [];
			const promises = registry.ordered(model).reverse().map((provider) => ranges.map((range) => __awaiter$18(this, void 0, void 0, function* () {
				try {
					const result = yield provider.provideInlayHints(model, range, token);
					if (result === null || result === void 0 ? void 0 : result.hints.length) data.push([result, provider]);
				} catch (err) {
					onUnexpectedExternalError(err);
				}
			})));
			yield Promise.all(promises.flat());
			if (token.isCancellationRequested || model.isDisposed()) throw new CancellationError();
			return new InlayHintsFragments(ranges, data, model);
		});
	}
	dispose() {
		this._disposables.dispose();
	}
	static _getRangeAtPosition(model, position) {
		const line = position.lineNumber;
		const word = model.getWordAtPosition(position);
		if (word) return new Range$1(line, word.startColumn, line, word.endColumn);
		model.tokenization.tokenizeIfCheap(line);
		const tokens = model.tokenization.getLineTokens(line);
		const offset = position.column - 1;
		const idx = tokens.findTokenIndexAtOffset(offset);
		let start = tokens.getStartOffset(idx);
		let end = tokens.getEndOffset(idx);
		if (end - start === 1) {
			if (start === offset && idx > 1) {
				start = tokens.getStartOffset(idx - 1);
				end = tokens.getEndOffset(idx - 1);
			} else if (end === offset && idx < tokens.getCount() - 1) {
				start = tokens.getStartOffset(idx + 1);
				end = tokens.getEndOffset(idx + 1);
			}
		}
		return new Range$1(line, start + 1, line, end + 1);
	}
};
function asCommandLink(command) {
	return URI.from({
		scheme: Schemas.command,
		path: command.id,
		query: command.arguments && encodeURIComponent(JSON.stringify(command.arguments))
	}).toString();
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js
var __awaiter$17 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
function showGoToContextMenu(accessor, editor$1, anchor, part) {
	var _a$5;
	return __awaiter$17(this, void 0, void 0, function* () {
		const resolverService = accessor.get(ITextModelService);
		const contextMenuService = accessor.get(IContextMenuService);
		const commandService = accessor.get(ICommandService);
		const instaService = accessor.get(IInstantiationService);
		const notificationService = accessor.get(INotificationService);
		yield part.item.resolve(CancellationToken.None);
		if (!part.part.location) return;
		const location = part.part.location;
		const menuActions = [];
		const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext).map((item) => isIMenuItem(item) ? item.command.id : ""));
		for (const delegate of EditorExtensionsRegistry.getEditorActions()) if (delegate instanceof SymbolNavigationAction && filter.has(delegate.id)) menuActions.push(new Action(delegate.id, delegate.label, void 0, true, () => __awaiter$17(this, void 0, void 0, function* () {
			const ref = yield resolverService.createModelReference(location.uri);
			try {
				yield instaService.invokeFunction(delegate.run.bind(delegate), editor$1, new SymbolNavigationAnchor(ref.object.textEditorModel, Range$1.getStartPosition(location.range)));
			} finally {
				ref.dispose();
			}
		})));
		if (part.part.command) {
			const { command } = part.part;
			menuActions.push(new Separator());
			menuActions.push(new Action(command.id, command.title, void 0, true, () => __awaiter$17(this, void 0, void 0, function* () {
				var _b$1;
				try {
					yield commandService.executeCommand(command.id, ...(_b$1 = command.arguments) !== null && _b$1 !== void 0 ? _b$1 : []);
				} catch (err) {
					notificationService.notify({
						severity: Severity.Error,
						source: part.item.provider.displayName,
						message: err
					});
				}
			})));
		}
		const useShadowDOM = editor$1.getOption(117);
		contextMenuService.showContextMenu({
			domForShadowRoot: useShadowDOM ? (_a$5 = editor$1.getDomNode()) !== null && _a$5 !== void 0 ? _a$5 : void 0 : void 0,
			getAnchor: () => {
				const box = getDomNodePagePosition(anchor);
				return {
					x: box.left,
					y: box.top + box.height + 8
				};
			},
			getActions: () => menuActions,
			onHide: () => {
				editor$1.focus();
			},
			autoSelectFirstItem: true
		});
	});
}
function goToDefinitionWithLocation(accessor, event, editor$1, location) {
	return __awaiter$17(this, void 0, void 0, function* () {
		const ref = yield accessor.get(ITextModelService).createModelReference(location.uri);
		yield editor$1.invokeWithinContext((accessor$1) => __awaiter$17(this, void 0, void 0, function* () {
			const openToSide = event.hasSideBySideModifier;
			const contextKeyService = accessor$1.get(IContextKeyService);
			const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
			return new DefinitionAction({
				openToSide,
				openInPeek: !openToSide && editor$1.getOption(80) && !isInPeek,
				muteMessage: true
			}, {
				alias: "",
				label: "",
				id: "",
				precondition: void 0
			}).run(accessor$1, editor$1, {
				model: ref.object.textEditorModel,
				position: Range$1.getStartPosition(location.range)
			});
		}));
		ref.dispose();
	});
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
var __decorate$28 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$28 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$16 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var InlayHintsCache = class InlayHintsCache {
	constructor() {
		this._entries = new LRUCache(50);
	}
	get(model) {
		const key = InlayHintsCache._key(model);
		return this._entries.get(key);
	}
	set(model, value) {
		const key = InlayHintsCache._key(model);
		this._entries.set(key, value);
	}
	static _key(model) {
		return `${model.uri.toString()}/${model.getVersionId()}`;
	}
};
var IInlayHintsCache = createDecorator("IInlayHintsCache");
registerSingleton(IInlayHintsCache, InlayHintsCache, true);
var RenderedInlayHintLabelPart = class {
	constructor(item, index) {
		this.item = item;
		this.index = index;
	}
	get part() {
		const label = this.item.hint.label;
		if (typeof label === "string") return { label };
		else return label[this.index];
	}
};
var ActiveInlayHintInfo = class {
	constructor(part, hasTriggerModifier$1) {
		this.part = part;
		this.hasTriggerModifier = hasTriggerModifier$1;
	}
};
var InlayHintsController = class InlayHintsController$1 {
	constructor(_editor, _languageFeaturesService, _featureDebounce, _inlayHintsCache, _commandService, _notificationService, _instaService) {
		this._editor = _editor;
		this._languageFeaturesService = _languageFeaturesService;
		this._inlayHintsCache = _inlayHintsCache;
		this._commandService = _commandService;
		this._notificationService = _notificationService;
		this._instaService = _instaService;
		this._disposables = new DisposableStore();
		this._sessionDisposables = new DisposableStore();
		this._decorationsMetadata = /* @__PURE__ */ new Map();
		this._ruleFactory = new DynamicCssRules(this._editor);
		this._activeRenderMode = 0;
		this._debounceInfo = _featureDebounce.for(_languageFeaturesService.inlayHintsProvider, "InlayHint", { min: 25 });
		this._disposables.add(_languageFeaturesService.inlayHintsProvider.onDidChange(() => this._update()));
		this._disposables.add(_editor.onDidChangeModel(() => this._update()));
		this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
		this._disposables.add(_editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(129)) this._update();
		}));
		this._update();
	}
	static get(editor$1) {
		var _a$5;
		return (_a$5 = editor$1.getContribution(InlayHintsController$1.ID)) !== null && _a$5 !== void 0 ? _a$5 : void 0;
	}
	dispose() {
		this._sessionDisposables.dispose();
		this._removeAllDecorations();
		this._disposables.dispose();
	}
	_update() {
		this._sessionDisposables.clear();
		this._removeAllDecorations();
		const options = this._editor.getOption(129);
		if (options.enabled === "off") return;
		const model = this._editor.getModel();
		if (!model || !this._languageFeaturesService.inlayHintsProvider.has(model)) return;
		const cached = this._inlayHintsCache.get(model);
		if (cached) this._updateHintsDecorators([model.getFullModelRange()], cached);
		this._sessionDisposables.add(toDisposable(() => {
			if (!model.isDisposed()) this._cacheHintsForFastRestore(model);
		}));
		let cts;
		const watchedProviders = /* @__PURE__ */ new Set();
		const scheduler = new RunOnceScheduler(() => __awaiter$16(this, void 0, void 0, function* () {
			const t1 = Date.now();
			cts === null || cts === void 0 || cts.dispose(true);
			cts = new CancellationTokenSource$1();
			const listener = model.onWillDispose(() => cts === null || cts === void 0 ? void 0 : cts.cancel());
			try {
				const myToken = cts.token;
				const inlayHints = yield InlayHintsFragments.create(this._languageFeaturesService.inlayHintsProvider, model, this._getHintsRanges(), myToken);
				scheduler.delay = this._debounceInfo.update(model, Date.now() - t1);
				if (myToken.isCancellationRequested) {
					inlayHints.dispose();
					return;
				}
				for (const provider of inlayHints.provider) if (typeof provider.onDidChangeInlayHints === "function" && !watchedProviders.has(provider)) {
					watchedProviders.add(provider);
					this._sessionDisposables.add(provider.onDidChangeInlayHints(() => {
						if (!scheduler.isScheduled()) scheduler.schedule();
					}));
				}
				this._sessionDisposables.add(inlayHints);
				this._updateHintsDecorators(inlayHints.ranges, inlayHints.items);
				this._cacheHintsForFastRestore(model);
			} catch (err) {
				onUnexpectedError(err);
			} finally {
				cts.dispose();
				listener.dispose();
			}
		}), this._debounceInfo.get(model));
		this._sessionDisposables.add(scheduler);
		this._sessionDisposables.add(toDisposable(() => cts === null || cts === void 0 ? void 0 : cts.dispose(true)));
		scheduler.schedule(0);
		this._sessionDisposables.add(this._editor.onDidScrollChange((e) => {
			if (e.scrollTopChanged || !scheduler.isScheduled()) scheduler.schedule();
		}));
		this._sessionDisposables.add(this._editor.onDidChangeModelContent((e) => {
			const delay = Math.max(scheduler.delay, 1250);
			scheduler.schedule(delay);
		}));
		if (options.enabled === "on") this._activeRenderMode = 0;
		else {
			let defaultMode;
			let altMode;
			if (options.enabled === "onUnlessPressed") {
				defaultMode = 0;
				altMode = 1;
			} else {
				defaultMode = 1;
				altMode = 0;
			}
			this._activeRenderMode = defaultMode;
			this._sessionDisposables.add(ModifierKeyEmitter.getInstance().event((e) => {
				if (!this._editor.hasModel()) return;
				const newRenderMode = e.altKey && e.ctrlKey ? altMode : defaultMode;
				if (newRenderMode !== this._activeRenderMode) {
					this._activeRenderMode = newRenderMode;
					const model$1 = this._editor.getModel();
					const copies = this._copyInlayHintsWithCurrentAnchor(model$1);
					this._updateHintsDecorators([model$1.getFullModelRange()], copies);
					scheduler.schedule(0);
				}
			}));
		}
		this._sessionDisposables.add(this._installDblClickGesture(() => scheduler.schedule(0)));
		this._sessionDisposables.add(this._installLinkGesture());
		this._sessionDisposables.add(this._installContextMenu());
	}
	_installLinkGesture() {
		const store = new DisposableStore();
		const gesture = store.add(new ClickLinkGesture(this._editor));
		const sessionStore = new DisposableStore();
		store.add(sessionStore);
		store.add(gesture.onMouseMoveOrRelevantKeyDown((e) => {
			const [mouseEvent] = e;
			const labelPart = this._getInlayHintLabelPart(mouseEvent);
			const model = this._editor.getModel();
			if (!labelPart || !model) {
				sessionStore.clear();
				return;
			}
			const cts = new CancellationTokenSource$1();
			sessionStore.add(toDisposable(() => cts.dispose(true)));
			labelPart.item.resolve(cts.token);
			this._activeInlayHintPart = labelPart.part.command || labelPart.part.location ? new ActiveInlayHintInfo(labelPart, mouseEvent.hasTriggerModifier) : void 0;
			const lineNumber = labelPart.item.hint.position.lineNumber;
			const range = new Range$1(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber));
			const lineHints = this._getInlineHintsForRange(range);
			this._updateHintsDecorators([range], lineHints);
			sessionStore.add(toDisposable(() => {
				this._activeInlayHintPart = void 0;
				this._updateHintsDecorators([range], lineHints);
			}));
		}));
		store.add(gesture.onCancel(() => sessionStore.clear()));
		store.add(gesture.onExecute((e) => __awaiter$16(this, void 0, void 0, function* () {
			const label = this._getInlayHintLabelPart(e);
			if (label) {
				const part = label.part;
				if (part.location) this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, part.location);
				else if (Command.is(part.command)) yield this._invokeCommand(part.command, label.item);
			}
		})));
		return store;
	}
	_getInlineHintsForRange(range) {
		const lineHints = /* @__PURE__ */ new Set();
		for (const data of this._decorationsMetadata.values()) if (range.containsRange(data.item.anchor.range)) lineHints.add(data.item);
		return Array.from(lineHints);
	}
	_installDblClickGesture(updateInlayHints) {
		return this._editor.onMouseUp((e) => __awaiter$16(this, void 0, void 0, function* () {
			if (e.event.detail !== 2) return;
			const part = this._getInlayHintLabelPart(e);
			if (!part) return;
			e.event.preventDefault();
			yield part.item.resolve(CancellationToken.None);
			if (isNonEmptyArray(part.item.hint.textEdits)) {
				const edits = part.item.hint.textEdits.map((edit) => EditOperation.replace(Range$1.lift(edit.range), edit.text));
				this._editor.executeEdits("inlayHint.default", edits);
				updateInlayHints();
			}
		}));
	}
	_installContextMenu() {
		return this._editor.onContextMenu((e) => __awaiter$16(this, void 0, void 0, function* () {
			if (!(e.event.target instanceof HTMLElement)) return;
			const part = this._getInlayHintLabelPart(e);
			if (part) yield this._instaService.invokeFunction(showGoToContextMenu, this._editor, e.event.target, part);
		}));
	}
	_getInlayHintLabelPart(e) {
		var _a$5;
		if (e.target.type !== 6) return;
		const options = (_a$5 = e.target.detail.injectedText) === null || _a$5 === void 0 ? void 0 : _a$5.options;
		if (options instanceof ModelDecorationInjectedTextOptions && (options === null || options === void 0 ? void 0 : options.attachedData) instanceof RenderedInlayHintLabelPart) return options.attachedData;
	}
	_invokeCommand(command, item) {
		var _a$5;
		return __awaiter$16(this, void 0, void 0, function* () {
			try {
				yield this._commandService.executeCommand(command.id, ...(_a$5 = command.arguments) !== null && _a$5 !== void 0 ? _a$5 : []);
			} catch (err) {
				this._notificationService.notify({
					severity: Severity.Error,
					source: item.provider.displayName,
					message: err
				});
			}
		});
	}
	_cacheHintsForFastRestore(model) {
		const hints = this._copyInlayHintsWithCurrentAnchor(model);
		this._inlayHintsCache.set(model, hints);
	}
	_copyInlayHintsWithCurrentAnchor(model) {
		const items = /* @__PURE__ */ new Map();
		for (const [id, obj] of this._decorationsMetadata) {
			if (items.has(obj.item)) continue;
			const range = model.getDecorationRange(id);
			if (range) {
				const anchor = new InlayHintAnchor(range, obj.item.anchor.direction);
				const copy = obj.item.with({ anchor });
				items.set(obj.item, copy);
			}
		}
		return Array.from(items.values());
	}
	_getHintsRanges() {
		const extra = 30;
		const model = this._editor.getModel();
		const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
		const result = [];
		for (const range of visibleRanges.sort(Range$1.compareRangesUsingStarts)) {
			const extendedRange = model.validateRange(new Range$1(range.startLineNumber - extra, range.startColumn, range.endLineNumber + extra, range.endColumn));
			if (result.length === 0 || !Range$1.areIntersectingOrTouching(result[result.length - 1], extendedRange)) result.push(extendedRange);
			else result[result.length - 1] = Range$1.plusRange(result[result.length - 1], extendedRange);
		}
		return result;
	}
	_updateHintsDecorators(ranges, items) {
		var _a$5, _b$1;
		const newDecorationsData = [];
		const addInjectedText = (item, ref, content, cursorStops, attachedData) => {
			const opts = {
				content,
				inlineClassNameAffectsLetterSpacing: true,
				inlineClassName: ref.className,
				cursorStops,
				attachedData
			};
			newDecorationsData.push({
				item,
				classNameRef: ref,
				decoration: {
					range: item.anchor.range,
					options: {
						description: "InlayHint",
						showIfCollapsed: item.anchor.range.isEmpty(),
						collapseOnReplaceEdit: !item.anchor.range.isEmpty(),
						stickiness: 0,
						[item.anchor.direction]: this._activeRenderMode === 0 ? opts : void 0
					}
				}
			});
		};
		const addInjectedWhitespace = (item, isLast) => {
			addInjectedText(item, this._ruleFactory.createClassNameRef({
				width: `${fontSize / 3 | 0}px`,
				display: "inline-block"
			}), "", isLast ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None);
		};
		const { fontSize, fontFamily, padding, isUniform } = this._getLayoutInfo();
		const fontFamilyVar = "--code-editorInlayHintsFontFamily";
		this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily);
		for (const item of items) {
			if (item.hint.paddingLeft) addInjectedWhitespace(item, false);
			const parts = typeof item.hint.label === "string" ? [{ label: item.hint.label }] : item.hint.label;
			for (let i = 0; i < parts.length; i++) {
				const part = parts[i];
				const isFirst = i === 0;
				const isLast = i === parts.length - 1;
				const cssProperties = {
					fontSize: `${fontSize}px`,
					fontFamily: `var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}`,
					verticalAlign: isUniform ? "baseline" : "middle"
				};
				if (isNonEmptyArray(item.hint.textEdits)) cssProperties.cursor = "default";
				this._fillInColors(cssProperties, item.hint);
				if ((part.command || part.location) && ((_a$5 = this._activeInlayHintPart) === null || _a$5 === void 0 ? void 0 : _a$5.part.item) === item && this._activeInlayHintPart.part.index === i) {
					cssProperties.textDecoration = "underline";
					if (this._activeInlayHintPart.hasTriggerModifier) {
						cssProperties.color = themeColorFromId(editorActiveLinkForeground);
						cssProperties.cursor = "pointer";
					}
				}
				if (padding) if (isFirst && isLast) {
					cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px`;
					cssProperties.borderRadius = `${fontSize / 4 | 0}px`;
				} else if (isFirst) {
					cssProperties.padding = `1px 0 1px ${Math.max(1, fontSize / 4) | 0}px`;
					cssProperties.borderRadius = `${fontSize / 4 | 0}px 0 0 ${fontSize / 4 | 0}px`;
				} else if (isLast) {
					cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px 1px 0`;
					cssProperties.borderRadius = `0 ${fontSize / 4 | 0}px ${fontSize / 4 | 0}px 0`;
				} else cssProperties.padding = `1px 0 1px 0`;
				addInjectedText(item, this._ruleFactory.createClassNameRef(cssProperties), fixSpace(part.label), isLast && !item.hint.paddingRight ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None, new RenderedInlayHintLabelPart(item, i));
			}
			if (item.hint.paddingRight) addInjectedWhitespace(item, true);
			if (newDecorationsData.length > InlayHintsController$1._MAX_DECORATORS) break;
		}
		const decorationIdsToReplace = [];
		for (const range of ranges) for (const { id } of (_b$1 = this._editor.getDecorationsInRange(range)) !== null && _b$1 !== void 0 ? _b$1 : []) {
			const metadata = this._decorationsMetadata.get(id);
			if (metadata) {
				decorationIdsToReplace.push(id);
				metadata.classNameRef.dispose();
				this._decorationsMetadata.delete(id);
			}
		}
		this._editor.changeDecorations((accessor) => {
			const newDecorationIds = accessor.deltaDecorations(decorationIdsToReplace, newDecorationsData.map((d) => d.decoration));
			for (let i = 0; i < newDecorationIds.length; i++) {
				const data = newDecorationsData[i];
				this._decorationsMetadata.set(newDecorationIds[i], data);
			}
		});
	}
	_fillInColors(props, hint) {
		if (hint.kind === InlayHintKind.Parameter) {
			props.backgroundColor = themeColorFromId(editorInlayHintParameterBackground);
			props.color = themeColorFromId(editorInlayHintParameterForeground);
		} else if (hint.kind === InlayHintKind.Type) {
			props.backgroundColor = themeColorFromId(editorInlayHintTypeBackground);
			props.color = themeColorFromId(editorInlayHintTypeForeground);
		} else {
			props.backgroundColor = themeColorFromId(editorInlayHintBackground);
			props.color = themeColorFromId(editorInlayHintForeground);
		}
	}
	_getLayoutInfo() {
		const options = this._editor.getOption(129);
		const padding = options.padding;
		const editorFontSize = this._editor.getOption(48);
		const editorFontFamily = this._editor.getOption(45);
		let fontSize = options.fontSize;
		if (!fontSize || fontSize < 5 || fontSize > editorFontSize) fontSize = editorFontSize;
		const fontFamily = options.fontFamily || editorFontFamily;
		return {
			fontSize,
			fontFamily,
			padding,
			isUniform: !padding && fontFamily === editorFontFamily && fontSize === editorFontSize
		};
	}
	_removeAllDecorations() {
		this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
		for (const obj of this._decorationsMetadata.values()) obj.classNameRef.dispose();
		this._decorationsMetadata.clear();
	}
};
InlayHintsController.ID = "editor.contrib.InlayHints";
InlayHintsController._MAX_DECORATORS = 1500;
InlayHintsController = __decorate$28([
	__param$28(1, ILanguageFeaturesService),
	__param$28(2, ILanguageFeatureDebounceService),
	__param$28(3, IInlayHintsCache),
	__param$28(4, ICommandService),
	__param$28(5, INotificationService),
	__param$28(6, IInstantiationService)
], InlayHintsController);
function fixSpace(str) {
	return str.replace(/[ \t]/g, "\xA0");
}
CommandsRegistry.registerCommand("_executeInlayHintProvider", (accessor, ...args) => __awaiter$16(void 0, void 0, void 0, function* () {
	const [uri, range] = args;
	assertType(URI.isUri(uri));
	assertType(Range$1.isIRange(range));
	const { inlayHintsProvider } = accessor.get(ILanguageFeaturesService);
	const ref = yield accessor.get(ITextModelService).createModelReference(uri);
	try {
		const model = yield InlayHintsFragments.create(inlayHintsProvider, ref.object.textEditorModel, [Range$1.lift(range)], CancellationToken.None);
		const result = model.items.map((i) => i.hint);
		setTimeout(() => model.dispose(), 0);
		return result;
	} finally {
		ref.dispose();
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js
var __decorate$27 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$27 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$15 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var __asyncValues = void 0 && (void 0).__asyncValues || function(o) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m = o[Symbol.asyncIterator], i;
	return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
		return this;
	}, i);
	function verb(n) {
		i[n] = o[n] && function(v) {
			return new Promise(function(resolve, reject) {
				v = o[n](v), settle(resolve, reject, v.done, v.value);
			});
		};
	}
	function settle(resolve, reject, d, v) {
		Promise.resolve(v).then(function(v$1) {
			resolve({
				value: v$1,
				done: d
			});
		}, reject);
	}
};
var InlayHintsHoverAnchor = class extends HoverForeignElementAnchor {
	constructor(part, owner) {
		super(10, owner, part.item.anchor.range);
		this.part = part;
	}
};
var InlayHintsHover = class InlayHintsHover$1 extends MarkdownHoverParticipant {
	constructor(editor$1, languageService, openerService, configurationService, _resolverService, languageFeaturesService) {
		super(editor$1, languageService, openerService, configurationService, languageFeaturesService);
		this._resolverService = _resolverService;
		this.hoverOrdinal = 6;
	}
	suggestHoverAnchor(mouseEvent) {
		var _a$5;
		if (!InlayHintsController.get(this._editor)) return null;
		if (mouseEvent.target.type !== 6) return null;
		const options = (_a$5 = mouseEvent.target.detail.injectedText) === null || _a$5 === void 0 ? void 0 : _a$5.options;
		if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) return null;
		return new InlayHintsHoverAnchor(options.attachedData, this);
	}
	computeSync() {
		return [];
	}
	computeAsync(anchor, _lineDecorations, token) {
		if (!(anchor instanceof InlayHintsHoverAnchor)) return AsyncIterableObject.EMPTY;
		return new AsyncIterableObject((executor) => __awaiter$15(this, void 0, void 0, function* () {
			var e_1, _a$5;
			const { part } = anchor;
			yield part.item.resolve(token);
			if (token.isCancellationRequested) return;
			let itemTooltip;
			if (typeof part.item.hint.tooltip === "string") itemTooltip = new MarkdownString().appendText(part.item.hint.tooltip);
			else if (part.item.hint.tooltip) itemTooltip = part.item.hint.tooltip;
			if (itemTooltip) executor.emitOne(new MarkdownHover(this, anchor.range, [itemTooltip], 0));
			if (isNonEmptyArray(part.item.hint.textEdits)) executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("hint.dbl", "Double click to insert"))], 10001));
			let partTooltip;
			if (typeof part.part.tooltip === "string") partTooltip = new MarkdownString().appendText(part.part.tooltip);
			else if (part.part.tooltip) partTooltip = part.part.tooltip;
			if (partTooltip) executor.emitOne(new MarkdownHover(this, anchor.range, [partTooltip], 1));
			if (part.part.location || part.part.command) {
				let linkHint;
				const kb = this._editor.getOption(72) === "altKey" ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
				if (part.part.location && part.part.command) linkHint = new MarkdownString().appendText(localize("hint.defAndCommand", "Go to Definition ({0}), right click for more", kb));
				else if (part.part.location) linkHint = new MarkdownString().appendText(localize("hint.def", "Go to Definition ({0})", kb));
				else if (part.part.command) linkHint = new MarkdownString(`[${localize("hint.cmd", "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
				if (linkHint) executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], 1e4));
			}
			const iterable = yield this._resolveInlayHintLabelPartHover(part, token);
			try {
				for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done;) {
					const item = iterable_1_1.value;
					executor.emitOne(item);
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (iterable_1_1 && !iterable_1_1.done && (_a$5 = iterable_1.return)) yield _a$5.call(iterable_1);
				} finally {
					if (e_1) throw e_1.error;
				}
			}
		}));
	}
	_resolveInlayHintLabelPartHover(part, token) {
		return __awaiter$15(this, void 0, void 0, function* () {
			if (!part.part.location) return AsyncIterableObject.EMPTY;
			const { uri, range } = part.part.location;
			const ref = yield this._resolverService.createModelReference(uri);
			try {
				const model = ref.object.textEditorModel;
				if (!this._languageFeaturesService.hoverProvider.has(model)) return AsyncIterableObject.EMPTY;
				return getHover(this._languageFeaturesService.hoverProvider, model, new Position$1(range.startLineNumber, range.startColumn), token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, 2 + item.ordinal));
			} finally {
				ref.dispose();
			}
		});
	}
};
InlayHintsHover = __decorate$27([
	__param$27(1, ILanguageService),
	__param$27(2, IOpenerService),
	__param$27(3, IConfigurationService),
	__param$27(4, ITextModelService),
	__param$27(5, ILanguageFeaturesService)
], InlayHintsHover);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsContribution.js
registerEditorContribution(InlayHintsController.ID, InlayHintsController);
HoverParticipantRegistry.register(InlayHintsHover);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js
var InPlaceReplaceCommand = class {
	constructor(editRange, originalSelection, text) {
		this._editRange = editRange;
		this._originalSelection = originalSelection;
		this._text = text;
	}
	getEditOperations(model, builder) {
		builder.addTrackedEditOperation(this._editRange, this._text);
	}
	computeCursorState(model, helper) {
		const srcRange = helper.getInverseEditOperations()[0].range;
		if (!this._originalSelection.isEmpty()) return new Selection$1(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
		return new Selection$1(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js
var __decorate$26 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$26 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var InPlaceReplaceController = class InPlaceReplaceController$1 {
	constructor(editor$1, editorWorkerService) {
		this.editor = editor$1;
		this.editorWorkerService = editorWorkerService;
		this.decorations = this.editor.createDecorationsCollection();
	}
	static get(editor$1) {
		return editor$1.getContribution(InPlaceReplaceController$1.ID);
	}
	dispose() {}
	run(source, up) {
		if (this.currentRequest) this.currentRequest.cancel();
		const editorSelection = this.editor.getSelection();
		const model = this.editor.getModel();
		if (!model || !editorSelection) return;
		let selection = editorSelection;
		if (selection.startLineNumber !== selection.endLineNumber) return;
		const state = new EditorState(this.editor, 5);
		const modelURI = model.uri;
		if (!this.editorWorkerService.canNavigateValueSet(modelURI)) return Promise.resolve(void 0);
		this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
		return this.currentRequest.then((result) => {
			if (!result || !result.range || !result.value) return;
			if (!state.validate(this.editor)) return;
			const editRange = Range$1.lift(result.range);
			let highlightRange = result.range;
			const diff = result.value.length - (selection.endColumn - selection.startColumn);
			highlightRange = {
				startLineNumber: highlightRange.startLineNumber,
				startColumn: highlightRange.startColumn,
				endLineNumber: highlightRange.endLineNumber,
				endColumn: highlightRange.startColumn + result.value.length
			};
			if (diff > 1) selection = new Selection$1(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
			const command = new InPlaceReplaceCommand(editRange, selection, result.value);
			this.editor.pushUndoStop();
			this.editor.executeCommand(source, command);
			this.editor.pushUndoStop();
			this.decorations.set([{
				range: highlightRange,
				options: InPlaceReplaceController$1.DECORATION
			}]);
			if (this.decorationRemover) this.decorationRemover.cancel();
			this.decorationRemover = timeout(350);
			this.decorationRemover.then(() => this.decorations.clear()).catch(onUnexpectedError);
		}).catch(onUnexpectedError);
	}
};
InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
	description: "in-place-replace",
	className: "valueSetReplacement"
});
InPlaceReplaceController = __decorate$26([__param$26(1, IEditorWorkerService)], InPlaceReplaceController);
var InPlaceReplaceUp = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.inPlaceReplace.up",
			label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
			alias: "Replace with Previous Value",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3154,
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		const controller = InPlaceReplaceController.get(editor$1);
		if (!controller) return Promise.resolve(void 0);
		return controller.run(this.id, true);
	}
};
var InPlaceReplaceDown = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.inPlaceReplace.down",
			label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
			alias: "Replace with Next Value",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3156,
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		const controller = InPlaceReplaceController.get(editor$1);
		if (!controller) return Promise.resolve(void 0);
		return controller.run(this.id, false);
	}
};
registerEditorContribution(InPlaceReplaceController.ID, InPlaceReplaceController);
registerEditorAction(InPlaceReplaceUp);
registerEditorAction(InPlaceReplaceDown);
registerThemingParticipant((theme, collector) => {
	const border = theme.getColor(editorBracketMatchBorder);
	if (border) collector.addRule(`.monaco-editor.vs .valueSetReplacement { outline: solid 2px ${border}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/lineSelection/browser/lineSelection.js
var ExpandLineSelectionAction = class extends EditorAction {
	constructor() {
		super({
			id: "expandLineSelection",
			label: localize("expandLineSelection", "Expand Line Selection"),
			alias: "Expand Line Selection",
			precondition: void 0,
			kbOpts: {
				weight: 0,
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 2090
			}
		});
	}
	run(_accessor, editor$1, args) {
		args = args || {};
		if (!editor$1.hasModel()) return;
		const viewModel = editor$1._getViewModel();
		viewModel.model.pushStackElement();
		viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
		viewModel.revealPrimaryCursor(args.source, true);
	}
};
registerEditorAction(ExpandLineSelectionAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js
var TrimTrailingWhitespaceCommand = class {
	constructor(selection, cursors) {
		this._selection = selection;
		this._cursors = cursors;
		this._selectionId = null;
	}
	getEditOperations(model, builder) {
		const ops = trimTrailingWhitespace(model, this._cursors);
		for (let i = 0, len = ops.length; i < len; i++) {
			const op = ops[i];
			builder.addEditOperation(op.range, op.text);
		}
		this._selectionId = builder.trackSelection(this._selection);
	}
	computeCursorState(model, helper) {
		return helper.getTrackedSelection(this._selectionId);
	}
};
/**
* Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.
*/
function trimTrailingWhitespace(model, cursors) {
	cursors.sort((a, b) => {
		if (a.lineNumber === b.lineNumber) return a.column - b.column;
		return a.lineNumber - b.lineNumber;
	});
	for (let i = cursors.length - 2; i >= 0; i--) if (cursors[i].lineNumber === cursors[i + 1].lineNumber) cursors.splice(i, 1);
	const r = [];
	let rLen = 0;
	let cursorIndex = 0;
	const cursorLen = cursors.length;
	for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
		const lineContent = model.getLineContent(lineNumber);
		const maxLineColumn = lineContent.length + 1;
		let minEditColumn = 0;
		if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
			minEditColumn = cursors[cursorIndex].column;
			cursorIndex++;
			if (minEditColumn === maxLineColumn) continue;
		}
		if (lineContent.length === 0) continue;
		const lastNonWhitespaceIndex$1 = lastNonWhitespaceIndex(lineContent);
		let fromColumn = 0;
		if (lastNonWhitespaceIndex$1 === -1) fromColumn = 1;
		else if (lastNonWhitespaceIndex$1 !== lineContent.length - 1) fromColumn = lastNonWhitespaceIndex$1 + 2;
		else continue;
		fromColumn = Math.max(minEditColumn, fromColumn);
		r[rLen++] = EditOperation.delete(new Range$1(lineNumber, fromColumn, lineNumber, maxLineColumn));
	}
	return r;
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/copyLinesCommand.js
var CopyLinesCommand = class {
	constructor(selection, isCopyingDown, noop) {
		this._selection = selection;
		this._isCopyingDown = isCopyingDown;
		this._noop = noop || false;
		this._selectionDirection = 0;
		this._selectionId = null;
		this._startLineNumberDelta = 0;
		this._endLineNumberDelta = 0;
	}
	getEditOperations(model, builder) {
		let s = this._selection;
		this._startLineNumberDelta = 0;
		this._endLineNumberDelta = 0;
		if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
			this._endLineNumberDelta = 1;
			s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
		}
		const sourceLines = [];
		for (let i = s.startLineNumber; i <= s.endLineNumber; i++) sourceLines.push(model.getLineContent(i));
		const sourceText = sourceLines.join("\n");
		if (sourceText === "") {
			if (this._isCopyingDown) {
				this._startLineNumberDelta++;
				this._endLineNumberDelta++;
			}
		}
		if (this._noop) builder.addEditOperation(new Range$1(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
		else if (!this._isCopyingDown) builder.addEditOperation(new Range$1(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
		else builder.addEditOperation(new Range$1(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
		this._selectionId = builder.trackSelection(s);
		this._selectionDirection = this._selection.getDirection();
	}
	computeCursorState(model, helper) {
		let result = helper.getTrackedSelection(this._selectionId);
		if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
			let startLineNumber = result.startLineNumber;
			let startColumn = result.startColumn;
			let endLineNumber = result.endLineNumber;
			let endColumn = result.endColumn;
			if (this._startLineNumberDelta !== 0) {
				startLineNumber = startLineNumber + this._startLineNumberDelta;
				startColumn = 1;
			}
			if (this._endLineNumberDelta !== 0) {
				endLineNumber = endLineNumber + this._endLineNumberDelta;
				endColumn = 1;
			}
			result = Selection$1.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
		}
		return result;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js
var __decorate$25 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$25 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var MoveLinesCommand = class MoveLinesCommand$1 {
	constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {
		this._languageConfigurationService = _languageConfigurationService;
		this._selection = selection;
		this._isMovingDown = isMovingDown;
		this._autoIndent = autoIndent;
		this._selectionId = null;
		this._moveEndLineSelectionShrink = false;
	}
	getEditOperations(model, builder) {
		const modelLineCount = model.getLineCount();
		if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
			this._selectionId = builder.trackSelection(this._selection);
			return;
		}
		if (!this._isMovingDown && this._selection.startLineNumber === 1) {
			this._selectionId = builder.trackSelection(this._selection);
			return;
		}
		this._moveEndPositionDown = false;
		let s = this._selection;
		if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
			this._moveEndPositionDown = true;
			s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
		}
		const { tabSize, indentSize, insertSpaces } = model.getOptions();
		const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
		const virtualModel = {
			tokenization: {
				getLineTokens: (lineNumber) => {
					return model.tokenization.getLineTokens(lineNumber);
				},
				getLanguageId: () => {
					return model.getLanguageId();
				},
				getLanguageIdAtPosition: (lineNumber, column) => {
					return model.getLanguageIdAtPosition(lineNumber, column);
				}
			},
			getLineContent: null
		};
		if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
			const lineNumber = s.startLineNumber;
			const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
			if (model.getLineMaxColumn(otherLineNumber) === 1) builder.addEditOperation(new Range$1(1, 1, 1, 1), null);
			else {
				builder.addEditOperation(new Range$1(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
				builder.addEditOperation(new Range$1(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
			}
			s = new Selection$1(otherLineNumber, 1, otherLineNumber, 1);
		} else {
			let movingLineNumber;
			let movingLineText;
			if (this._isMovingDown) {
				movingLineNumber = s.endLineNumber + 1;
				movingLineText = model.getLineContent(movingLineNumber);
				builder.addEditOperation(new Range$1(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
				let insertingText = movingLineText;
				if (this.shouldAutoIndent(model, s)) {
					const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
					if (movingLineMatchResult !== null) {
						const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
						const newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
						insertingText = generateIndent(newSpaceCnt, tabSize, insertSpaces) + this.trimLeft(movingLineText);
					} else {
						virtualModel.getLineContent = (lineNumber) => {
							if (lineNumber === s.startLineNumber) return model.getLineContent(movingLineNumber);
							else return model.getLineContent(lineNumber);
						};
						const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);
						if (indentOfMovingLine !== null) {
							const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
							const newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
							if (newSpaceCnt !== getSpaceCnt(oldIndentation, tabSize)) insertingText = generateIndent(newSpaceCnt, tabSize, insertSpaces) + this.trimLeft(movingLineText);
						}
					}
					builder.addEditOperation(new Range$1(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
					const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
					if (ret !== null) {
						if (ret !== 0) this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
					} else {
						virtualModel.getLineContent = (lineNumber) => {
							if (lineNumber === s.startLineNumber) return insertingText;
							else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) return model.getLineContent(lineNumber - 1);
							else return model.getLineContent(lineNumber);
						};
						const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);
						if (newIndentatOfMovingBlock !== null) {
							const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
							const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
							const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
							if (newSpaceCnt !== oldSpaceCnt) {
								const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
								this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
							}
						}
					}
				} else builder.addEditOperation(new Range$1(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
			} else {
				movingLineNumber = s.startLineNumber - 1;
				movingLineText = model.getLineContent(movingLineNumber);
				builder.addEditOperation(new Range$1(movingLineNumber, 1, movingLineNumber + 1, 1), null);
				builder.addEditOperation(new Range$1(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
				if (this.shouldAutoIndent(model, s)) {
					virtualModel.getLineContent = (lineNumber) => {
						if (lineNumber === movingLineNumber) return model.getLineContent(s.startLineNumber);
						else return model.getLineContent(lineNumber);
					};
					const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
					if (ret !== null) {
						if (ret !== 0) this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
					} else {
						const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);
						if (indentOfFirstLine !== null) {
							const oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
							const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
							const oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
							if (newSpaceCnt !== oldSpaceCnt) {
								const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
								this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
							}
						}
					}
				}
			}
		}
		this._selectionId = builder.trackSelection(s);
	}
	buildIndentConverter(tabSize, indentSize, insertSpaces) {
		return {
			shiftIndent: (indentation) => {
				return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
			},
			unshiftIndent: (indentation) => {
				return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
			}
		};
	}
	parseEnterResult(model, indentConverter, tabSize, line, enter) {
		if (enter) {
			let enterPrefix = enter.indentation;
			if (enter.indentAction === IndentAction.None) enterPrefix = enter.indentation + enter.appendText;
			else if (enter.indentAction === IndentAction.Indent) enterPrefix = enter.indentation + enter.appendText;
			else if (enter.indentAction === IndentAction.IndentOutdent) enterPrefix = enter.indentation;
			else if (enter.indentAction === IndentAction.Outdent) enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
			const movingLineText = model.getLineContent(line);
			if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
				const oldIndentation = getLeadingWhitespace(model.getLineContent(line));
				let newIndentation = getLeadingWhitespace(enterPrefix);
				const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);
				if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) newIndentation = indentConverter.unshiftIndent(newIndentation);
				return getSpaceCnt(newIndentation, tabSize) - getSpaceCnt(oldIndentation, tabSize);
			}
		}
		return null;
	}
	/**
	*
	* @param model
	* @param indentConverter
	* @param tabSize
	* @param line the line moving down
	* @param futureAboveLineNumber the line which will be at the `line` position
	* @param futureAboveLineText
	*/
	matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
		if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
			const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
			const enter = getEnterAction(this._autoIndent, model, new Range$1(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);
			return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
		} else {
			let validPrecedingLine = line - 1;
			while (validPrecedingLine >= 1) {
				const lineContent = model.getLineContent(validPrecedingLine);
				if (lastNonWhitespaceIndex(lineContent) >= 0) break;
				validPrecedingLine--;
			}
			if (validPrecedingLine < 1 || line > model.getLineCount()) return null;
			const maxColumn = model.getLineMaxColumn(validPrecedingLine);
			const enter = getEnterAction(this._autoIndent, model, new Range$1(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
			return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
		}
	}
	matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
		let validPrecedingLine = oneLineAbove;
		while (validPrecedingLine >= 1) {
			let lineContent;
			if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) lineContent = previousLineText;
			else lineContent = model.getLineContent(validPrecedingLine);
			if (lastNonWhitespaceIndex(lineContent) >= 0) break;
			validPrecedingLine--;
		}
		if (validPrecedingLine < 1 || line > model.getLineCount()) return null;
		const maxColumn = model.getLineMaxColumn(validPrecedingLine);
		const enter = getEnterAction(this._autoIndent, model, new Range$1(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
		return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
	}
	trimLeft(str) {
		return str.replace(/^\s+/, "");
	}
	shouldAutoIndent(model, selection) {
		if (this._autoIndent < 4) return false;
		if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) return false;
		const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
		if (languageAtSelectionStart !== model.getLanguageIdAtPosition(selection.endLineNumber, 1)) return false;
		if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) return false;
		return true;
	}
	getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
		for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
			const lineContent = model.getLineContent(i);
			const originalIndent = getLeadingWhitespace(lineContent);
			const newSpacesCnt = getSpaceCnt(originalIndent, tabSize) + offset;
			const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
			if (newIndent !== originalIndent) {
				builder.addEditOperation(new Range$1(i, 1, i, originalIndent.length + 1), newIndent);
				if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") this._moveEndLineSelectionShrink = true;
			}
		}
	}
	computeCursorState(model, helper) {
		let result = helper.getTrackedSelection(this._selectionId);
		if (this._moveEndPositionDown) result = result.setEndPosition(result.endLineNumber + 1, 1);
		if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) result = result.setEndPosition(result.endLineNumber, 2);
		return result;
	}
};
MoveLinesCommand = __decorate$25([__param$25(3, ILanguageConfigurationService)], MoveLinesCommand);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/sortLinesCommand.js
var SortLinesCommand = class SortLinesCommand {
	constructor(selection, descending) {
		this.selection = selection;
		this.descending = descending;
		this.selectionId = null;
	}
	static getCollator() {
		if (!SortLinesCommand._COLLATOR) SortLinesCommand._COLLATOR = new Intl.Collator();
		return SortLinesCommand._COLLATOR;
	}
	getEditOperations(model, builder) {
		const op = sortLines(model, this.selection, this.descending);
		if (op) builder.addEditOperation(op.range, op.text);
		this.selectionId = builder.trackSelection(this.selection);
	}
	computeCursorState(model, helper) {
		return helper.getTrackedSelection(this.selectionId);
	}
	static canRun(model, selection, descending) {
		if (model === null) return false;
		const data = getSortData(model, selection, descending);
		if (!data) return false;
		for (let i = 0, len = data.before.length; i < len; i++) if (data.before[i] !== data.after[i]) return true;
		return false;
	}
};
SortLinesCommand._COLLATOR = null;
function getSortData(model, selection, descending) {
	const startLineNumber = selection.startLineNumber;
	let endLineNumber = selection.endLineNumber;
	if (selection.endColumn === 1) endLineNumber--;
	if (startLineNumber >= endLineNumber) return null;
	const linesToSort = [];
	for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) linesToSort.push(model.getLineContent(lineNumber));
	let sorted = linesToSort.slice(0);
	sorted.sort(SortLinesCommand.getCollator().compare);
	if (descending === true) sorted = sorted.reverse();
	return {
		startLineNumber,
		endLineNumber,
		before: linesToSort,
		after: sorted
	};
}
/**
* Generate commands for sorting lines on a model.
*/
function sortLines(model, selection, descending) {
	const data = getSortData(model, selection, descending);
	if (!data) return null;
	return EditOperation.replace(new Range$1(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
var AbstractCopyLinesAction = class extends EditorAction {
	constructor(down, opts) {
		super(opts);
		this.down = down;
	}
	run(_accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const selections = editor$1.getSelections().map((selection, index) => ({
			selection,
			index,
			ignore: false
		}));
		selections.sort((a, b) => Range$1.compareRangesUsingStarts(a.selection, b.selection));
		let prev = selections[0];
		for (let i = 1; i < selections.length; i++) {
			const curr = selections[i];
			if (prev.selection.endLineNumber === curr.selection.startLineNumber) if (prev.index < curr.index) curr.ignore = true;
			else {
				prev.ignore = true;
				prev = curr;
			}
		}
		const commands = [];
		for (const selection of selections) commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var CopyLinesUpAction = class extends AbstractCopyLinesAction {
	constructor() {
		super(false, {
			id: "editor.action.copyLinesUpAction",
			label: localize("lines.copyUp", "Copy Line Up"),
			alias: "Copy Line Up",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1552,
				linux: { primary: 3600 },
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "2_line",
				title: localize({
					key: "miCopyLinesUp",
					comment: ["&& denotes a mnemonic"]
				}, "&&Copy Line Up"),
				order: 1
			}
		});
	}
};
var CopyLinesDownAction = class extends AbstractCopyLinesAction {
	constructor() {
		super(true, {
			id: "editor.action.copyLinesDownAction",
			label: localize("lines.copyDown", "Copy Line Down"),
			alias: "Copy Line Down",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1554,
				linux: { primary: 3602 },
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "2_line",
				title: localize({
					key: "miCopyLinesDown",
					comment: ["&& denotes a mnemonic"]
				}, "Co&&py Line Down"),
				order: 2
			}
		});
	}
};
var DuplicateSelectionAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.duplicateSelection",
			label: localize("duplicateSelection", "Duplicate Selection"),
			alias: "Duplicate Selection",
			precondition: EditorContextKeys.writable,
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "2_line",
				title: localize({
					key: "miDuplicateSelection",
					comment: ["&& denotes a mnemonic"]
				}, "&&Duplicate Selection"),
				order: 5
			}
		});
	}
	run(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		const commands = [];
		const selections = editor$1.getSelections();
		const model = editor$1.getModel();
		for (const selection of selections) if (selection.isEmpty()) commands.push(new CopyLinesCommand(selection, true));
		else {
			const insertSelection = new Selection$1(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
			commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
		}
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var AbstractMoveLinesAction = class extends EditorAction {
	constructor(down, opts) {
		super(opts);
		this.down = down;
	}
	run(accessor, editor$1) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		const commands = [];
		const selections = editor$1.getSelections() || [];
		const autoIndent = editor$1.getOption(9);
		for (const selection of selections) commands.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var MoveLinesUpAction = class extends AbstractMoveLinesAction {
	constructor() {
		super(false, {
			id: "editor.action.moveLinesUpAction",
			label: localize("lines.moveUp", "Move Line Up"),
			alias: "Move Line Up",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 528,
				linux: { primary: 528 },
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "2_line",
				title: localize({
					key: "miMoveLinesUp",
					comment: ["&& denotes a mnemonic"]
				}, "Mo&&ve Line Up"),
				order: 3
			}
		});
	}
};
var MoveLinesDownAction = class extends AbstractMoveLinesAction {
	constructor() {
		super(true, {
			id: "editor.action.moveLinesDownAction",
			label: localize("lines.moveDown", "Move Line Down"),
			alias: "Move Line Down",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 530,
				linux: { primary: 530 },
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "2_line",
				title: localize({
					key: "miMoveLinesDown",
					comment: ["&& denotes a mnemonic"]
				}, "Move &&Line Down"),
				order: 4
			}
		});
	}
};
var AbstractSortLinesAction = class extends EditorAction {
	constructor(descending, opts) {
		super(opts);
		this.descending = descending;
	}
	run(_accessor, editor$1) {
		const selections = editor$1.getSelections() || [];
		for (const selection of selections) if (!SortLinesCommand.canRun(editor$1.getModel(), selection, this.descending)) return;
		const commands = [];
		for (let i = 0, len = selections.length; i < len; i++) commands[i] = new SortLinesCommand(selections[i], this.descending);
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var SortLinesAscendingAction = class extends AbstractSortLinesAction {
	constructor() {
		super(false, {
			id: "editor.action.sortLinesAscending",
			label: localize("lines.sortAscending", "Sort Lines Ascending"),
			alias: "Sort Lines Ascending",
			precondition: EditorContextKeys.writable
		});
	}
};
var SortLinesDescendingAction = class extends AbstractSortLinesAction {
	constructor() {
		super(true, {
			id: "editor.action.sortLinesDescending",
			label: localize("lines.sortDescending", "Sort Lines Descending"),
			alias: "Sort Lines Descending",
			precondition: EditorContextKeys.writable
		});
	}
};
var DeleteDuplicateLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.removeDuplicateLines",
			label: localize("lines.deleteDuplicates", "Delete Duplicate Lines"),
			alias: "Delete Duplicate Lines",
			precondition: EditorContextKeys.writable
		});
	}
	run(_accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const model = editor$1.getModel();
		if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) return;
		const edits = [];
		const endCursorState = [];
		let linesDeleted = 0;
		for (const selection of editor$1.getSelections()) {
			const uniqueLines = /* @__PURE__ */ new Set();
			const lines = [];
			for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {
				const line = model.getLineContent(i);
				if (uniqueLines.has(line)) continue;
				lines.push(line);
				uniqueLines.add(line);
			}
			const selectionToReplace = new Selection$1(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));
			const adjustedSelectionStart = selection.startLineNumber - linesDeleted;
			const finalSelection = new Selection$1(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);
			edits.push(EditOperation.replace(selectionToReplace, lines.join("\n")));
			endCursorState.push(finalSelection);
			linesDeleted += selection.endLineNumber - selection.startLineNumber + 1 - lines.length;
		}
		editor$1.pushUndoStop();
		editor$1.executeEdits(this.id, edits, endCursorState);
		editor$1.pushUndoStop();
	}
};
var TrimTrailingWhitespaceAction = class TrimTrailingWhitespaceAction extends EditorAction {
	constructor() {
		super({
			id: TrimTrailingWhitespaceAction.ID,
			label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
			alias: "Trim Trailing Whitespace",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: KeyChord(2089, 2102),
				weight: 100
			}
		});
	}
	run(_accessor, editor$1, args) {
		let cursors = [];
		if (args.reason === "auto-save") cursors = (editor$1.getSelections() || []).map((s) => new Position$1(s.positionLineNumber, s.positionColumn));
		const selection = editor$1.getSelection();
		if (selection === null) return;
		const command = new TrimTrailingWhitespaceCommand(selection, cursors);
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, [command]);
		editor$1.pushUndoStop();
	}
};
TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
var DeleteLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.deleteLines",
			label: localize("lines.delete", "Delete Line"),
			alias: "Delete Line",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 3113,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const ops = this._getLinesToRemove(editor$1);
		const model = editor$1.getModel();
		if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) return;
		let linesDeleted = 0;
		const edits = [];
		const cursorState = [];
		for (let i = 0, len = ops.length; i < len; i++) {
			const op = ops[i];
			let startLineNumber = op.startLineNumber;
			let endLineNumber = op.endLineNumber;
			let startColumn = 1;
			let endColumn = model.getLineMaxColumn(endLineNumber);
			if (endLineNumber < model.getLineCount()) {
				endLineNumber += 1;
				endColumn = 1;
			} else if (startLineNumber > 1) {
				startLineNumber -= 1;
				startColumn = model.getLineMaxColumn(startLineNumber);
			}
			edits.push(EditOperation.replace(new Selection$1(startLineNumber, startColumn, endLineNumber, endColumn), ""));
			cursorState.push(new Selection$1(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
			linesDeleted += op.endLineNumber - op.startLineNumber + 1;
		}
		editor$1.pushUndoStop();
		editor$1.executeEdits(this.id, edits, cursorState);
		editor$1.pushUndoStop();
	}
	_getLinesToRemove(editor$1) {
		const operations = editor$1.getSelections().map((s) => {
			let endLineNumber = s.endLineNumber;
			if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) endLineNumber -= 1;
			return {
				startLineNumber: s.startLineNumber,
				selectionStartColumn: s.selectionStartColumn,
				endLineNumber,
				positionColumn: s.positionColumn
			};
		});
		operations.sort((a, b) => {
			if (a.startLineNumber === b.startLineNumber) return a.endLineNumber - b.endLineNumber;
			return a.startLineNumber - b.startLineNumber;
		});
		const mergedOperations = [];
		let previousOperation = operations[0];
		for (let i = 1; i < operations.length; i++) if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) previousOperation.endLineNumber = operations[i].endLineNumber;
		else {
			mergedOperations.push(previousOperation);
			previousOperation = operations[i];
		}
		mergedOperations.push(previousOperation);
		return mergedOperations;
	}
};
var IndentLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.indentLines",
			label: localize("lines.indent", "Indent Line"),
			alias: "Indent Line",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2137,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		const viewModel = editor$1._getViewModel();
		if (!viewModel) return;
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor$1.getModel(), editor$1.getSelections()));
		editor$1.pushUndoStop();
	}
};
var OutdentLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.outdentLines",
			label: localize("lines.outdent", "Outdent Line"),
			alias: "Outdent Line",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2135,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor$1, null);
	}
};
var InsertLineBeforeAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.insertLineBefore",
			label: localize("lines.insertBefore", "Insert Line Above"),
			alias: "Insert Line Above",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3075,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		const viewModel = editor$1._getViewModel();
		if (!viewModel) return;
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor$1.getModel(), editor$1.getSelections()));
	}
};
var InsertLineAfterAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.insertLineAfter",
			label: localize("lines.insertAfter", "Insert Line Below"),
			alias: "Insert Line Below",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2051,
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		const viewModel = editor$1._getViewModel();
		if (!viewModel) return;
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor$1.getModel(), editor$1.getSelections()));
	}
};
var AbstractDeleteAllToBoundaryAction = class extends EditorAction {
	run(_accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const primaryCursor = editor$1.getSelection();
		const rangesToDelete = this._getRangesToDelete(editor$1);
		const effectiveRanges = [];
		for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
			const range = rangesToDelete[i];
			const nextRange = rangesToDelete[i + 1];
			if (Range$1.intersectRanges(range, nextRange) === null) effectiveRanges.push(range);
			else rangesToDelete[i + 1] = Range$1.plusRange(range, nextRange);
		}
		effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
		const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
		const edits = effectiveRanges.map((range) => {
			return EditOperation.replace(range, "");
		});
		editor$1.pushUndoStop();
		editor$1.executeEdits(this.id, edits, endCursorState);
		editor$1.pushUndoStop();
	}
};
var DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
	constructor() {
		super({
			id: "deleteAllLeft",
			label: localize("lines.deleteAllLeft", "Delete All Left"),
			alias: "Delete All Left",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 2049 },
				weight: 100
			}
		});
	}
	_getEndCursorState(primaryCursor, rangesToDelete) {
		let endPrimaryCursor = null;
		const endCursorState = [];
		let deletedLines = 0;
		rangesToDelete.forEach((range) => {
			let endCursor;
			if (range.endColumn === 1 && deletedLines > 0) {
				const newStartLine = range.startLineNumber - deletedLines;
				endCursor = new Selection$1(newStartLine, range.startColumn, newStartLine, range.startColumn);
			} else endCursor = new Selection$1(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
			deletedLines += range.endLineNumber - range.startLineNumber;
			if (range.intersectRanges(primaryCursor)) endPrimaryCursor = endCursor;
			else endCursorState.push(endCursor);
		});
		if (endPrimaryCursor) endCursorState.unshift(endPrimaryCursor);
		return endCursorState;
	}
	_getRangesToDelete(editor$1) {
		const selections = editor$1.getSelections();
		if (selections === null) return [];
		let rangesToDelete = selections;
		const model = editor$1.getModel();
		if (model === null) return [];
		rangesToDelete.sort(Range$1.compareRangesUsingStarts);
		rangesToDelete = rangesToDelete.map((selection) => {
			if (selection.isEmpty()) if (selection.startColumn === 1) {
				const deleteFromLine = Math.max(1, selection.startLineNumber - 1);
				return new Range$1(deleteFromLine, selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1, selection.startLineNumber, 1);
			} else return new Range$1(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
			else return new Range$1(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
		});
		return rangesToDelete;
	}
};
var DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
	constructor() {
		super({
			id: "deleteAllRight",
			label: localize("lines.deleteAllRight", "Delete All Right"),
			alias: "Delete All Right",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: {
					primary: 297,
					secondary: [2068]
				},
				weight: 100
			}
		});
	}
	_getEndCursorState(primaryCursor, rangesToDelete) {
		let endPrimaryCursor = null;
		const endCursorState = [];
		for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
			const range = rangesToDelete[i];
			const endCursor = new Selection$1(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
			if (range.intersectRanges(primaryCursor)) endPrimaryCursor = endCursor;
			else endCursorState.push(endCursor);
		}
		if (endPrimaryCursor) endCursorState.unshift(endPrimaryCursor);
		return endCursorState;
	}
	_getRangesToDelete(editor$1) {
		const model = editor$1.getModel();
		if (model === null) return [];
		const selections = editor$1.getSelections();
		if (selections === null) return [];
		const rangesToDelete = selections.map((sel) => {
			if (sel.isEmpty()) {
				const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
				if (sel.startColumn === maxColumn) return new Range$1(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
				else return new Range$1(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
			}
			return sel;
		});
		rangesToDelete.sort(Range$1.compareRangesUsingStarts);
		return rangesToDelete;
	}
};
var JoinLinesAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.joinLines",
			label: localize("lines.joinLines", "Join Lines"),
			alias: "Join Lines",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 0,
				mac: { primary: 296 },
				weight: 100
			}
		});
	}
	run(_accessor, editor$1) {
		const selections = editor$1.getSelections();
		if (selections === null) return;
		let primaryCursor = editor$1.getSelection();
		if (primaryCursor === null) return;
		selections.sort(Range$1.compareRangesUsingStarts);
		const reducedSelections = [];
		const lastSelection = selections.reduce((previousValue, currentValue) => {
			if (previousValue.isEmpty()) {
				if (previousValue.endLineNumber === currentValue.startLineNumber) {
					if (primaryCursor.equalsSelection(previousValue)) primaryCursor = currentValue;
					return currentValue;
				}
				if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
					reducedSelections.push(previousValue);
					return currentValue;
				} else return new Selection$1(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
			} else if (currentValue.startLineNumber > previousValue.endLineNumber) {
				reducedSelections.push(previousValue);
				return currentValue;
			} else return new Selection$1(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
		});
		reducedSelections.push(lastSelection);
		const model = editor$1.getModel();
		if (model === null) return;
		const edits = [];
		const endCursorState = [];
		let endPrimaryCursor = primaryCursor;
		let lineOffset = 0;
		for (let i = 0, len = reducedSelections.length; i < len; i++) {
			const selection = reducedSelections[i];
			const startLineNumber = selection.startLineNumber;
			const startColumn = 1;
			let columnDeltaOffset = 0;
			let endLineNumber, endColumn;
			const selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
			if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
				const position = selection.getStartPosition();
				if (position.lineNumber < model.getLineCount()) {
					endLineNumber = startLineNumber + 1;
					endColumn = model.getLineMaxColumn(endLineNumber);
				} else {
					endLineNumber = position.lineNumber;
					endColumn = model.getLineMaxColumn(position.lineNumber);
				}
			} else {
				endLineNumber = selection.endLineNumber;
				endColumn = model.getLineMaxColumn(endLineNumber);
			}
			let trimmedLinesContent = model.getLineContent(startLineNumber);
			for (let i$1 = startLineNumber + 1; i$1 <= endLineNumber; i$1++) {
				const lineText = model.getLineContent(i$1);
				const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i$1);
				if (firstNonWhitespaceIdx >= 1) {
					let insertSpace = true;
					if (trimmedLinesContent === "") insertSpace = false;
					if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
						insertSpace = false;
						trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
					}
					const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
					trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
					if (insertSpace) columnDeltaOffset = lineTextWithoutIndent.length + 1;
					else columnDeltaOffset = lineTextWithoutIndent.length;
				} else columnDeltaOffset = 0;
			}
			const deleteSelection = new Range$1(startLineNumber, startColumn, endLineNumber, endColumn);
			if (!deleteSelection.isEmpty()) {
				let resultSelection;
				if (selection.isEmpty()) {
					edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
					resultSelection = new Selection$1(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
				} else if (selection.startLineNumber === selection.endLineNumber) {
					edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
					resultSelection = new Selection$1(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
				} else {
					edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
					resultSelection = new Selection$1(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
				}
				if (Range$1.intersectRanges(deleteSelection, primaryCursor) !== null) endPrimaryCursor = resultSelection;
				else endCursorState.push(resultSelection);
			}
			lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
		}
		endCursorState.unshift(endPrimaryCursor);
		editor$1.pushUndoStop();
		editor$1.executeEdits(this.id, edits, endCursorState);
		editor$1.pushUndoStop();
	}
};
var TransposeAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.transpose",
			label: localize("editor.transpose", "Transpose characters around the cursor"),
			alias: "Transpose characters around the cursor",
			precondition: EditorContextKeys.writable
		});
	}
	run(_accessor, editor$1) {
		const selections = editor$1.getSelections();
		if (selections === null) return;
		const model = editor$1.getModel();
		if (model === null) return;
		const commands = [];
		for (let i = 0, len = selections.length; i < len; i++) {
			const selection = selections[i];
			if (!selection.isEmpty()) continue;
			const cursor = selection.getStartPosition();
			const maxColumn = model.getLineMaxColumn(cursor.lineNumber);
			if (cursor.column >= maxColumn) {
				if (cursor.lineNumber === model.getLineCount()) continue;
				const deleteSelection = new Range$1(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
				const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
				commands.push(new ReplaceCommand(new Selection$1(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
			} else {
				const deleteSelection = new Range$1(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
				const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
				commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection$1(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
			}
		}
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var AbstractCaseAction = class extends EditorAction {
	run(_accessor, editor$1) {
		const selections = editor$1.getSelections();
		if (selections === null) return;
		const model = editor$1.getModel();
		if (model === null) return;
		const wordSeparators = editor$1.getOption(119);
		const textEdits = [];
		for (const selection of selections) if (selection.isEmpty()) {
			const cursor = selection.getStartPosition();
			const word = editor$1.getConfiguredWordAtPosition(cursor);
			if (!word) continue;
			const wordRange = new Range$1(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
			const text = model.getValueInRange(wordRange);
			textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));
		} else {
			const text = model.getValueInRange(selection);
			textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));
		}
		editor$1.pushUndoStop();
		editor$1.executeEdits(this.id, textEdits);
		editor$1.pushUndoStop();
	}
};
var UpperCaseAction = class extends AbstractCaseAction {
	constructor() {
		super({
			id: "editor.action.transformToUppercase",
			label: localize("editor.transformToUppercase", "Transform to Uppercase"),
			alias: "Transform to Uppercase",
			precondition: EditorContextKeys.writable
		});
	}
	_modifyText(text, wordSeparators) {
		return text.toLocaleUpperCase();
	}
};
var LowerCaseAction = class extends AbstractCaseAction {
	constructor() {
		super({
			id: "editor.action.transformToLowercase",
			label: localize("editor.transformToLowercase", "Transform to Lowercase"),
			alias: "Transform to Lowercase",
			precondition: EditorContextKeys.writable
		});
	}
	_modifyText(text, wordSeparators) {
		return text.toLocaleLowerCase();
	}
};
var BackwardsCompatibleRegExp = class {
	constructor(_pattern, _flags) {
		this._pattern = _pattern;
		this._flags = _flags;
		this._actual = null;
		this._evaluated = false;
	}
	get() {
		if (!this._evaluated) {
			this._evaluated = true;
			try {
				this._actual = new RegExp(this._pattern, this._flags);
			} catch (err) {}
		}
		return this._actual;
	}
	isSupported() {
		return this.get() !== null;
	}
};
var TitleCaseAction = class TitleCaseAction extends AbstractCaseAction {
	constructor() {
		super({
			id: "editor.action.transformToTitlecase",
			label: localize("editor.transformToTitlecase", "Transform to Title Case"),
			alias: "Transform to Title Case",
			precondition: EditorContextKeys.writable
		});
	}
	_modifyText(text, wordSeparators) {
		const titleBoundary = TitleCaseAction.titleBoundary.get();
		if (!titleBoundary) return text;
		return text.toLocaleLowerCase().replace(titleBoundary, (b) => b.toLocaleUpperCase());
	}
};
TitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
var SnakeCaseAction = class SnakeCaseAction extends AbstractCaseAction {
	constructor() {
		super({
			id: "editor.action.transformToSnakecase",
			label: localize("editor.transformToSnakecase", "Transform to Snake Case"),
			alias: "Transform to Snake Case",
			precondition: EditorContextKeys.writable
		});
	}
	_modifyText(text, wordSeparators) {
		const caseBoundary = SnakeCaseAction.caseBoundary.get();
		const singleLetters = SnakeCaseAction.singleLetters.get();
		if (!caseBoundary || !singleLetters) return text;
		return text.replace(caseBoundary, "$1_$2").replace(singleLetters, "$1_$2$3").toLocaleLowerCase();
	}
};
SnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
SnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
var KebabCaseAction = class KebabCaseAction extends AbstractCaseAction {
	constructor() {
		super({
			id: "editor.action.transformToKebabcase",
			label: localize("editor.transformToKebabcase", "Transform to Kebab Case"),
			alias: "Transform to Kebab Case",
			precondition: EditorContextKeys.writable
		});
	}
	static isSupported() {
		return [
			this.caseBoundary,
			this.singleLetters,
			this.underscoreBoundary
		].every((regexp) => regexp.isSupported());
	}
	_modifyText(text, _) {
		const caseBoundary = KebabCaseAction.caseBoundary.get();
		const singleLetters = KebabCaseAction.singleLetters.get();
		const underscoreBoundary = KebabCaseAction.underscoreBoundary.get();
		if (!caseBoundary || !singleLetters || !underscoreBoundary) return text;
		return text.replace(underscoreBoundary, "$1-$3").replace(caseBoundary, "$1-$2").replace(singleLetters, "$1-$2").toLocaleLowerCase();
	}
};
KebabCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
KebabCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
KebabCaseAction.underscoreBoundary = new BackwardsCompatibleRegExp("(\\S)(_)(\\S)", "gm");
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(DeleteDuplicateLinesAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
if (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) registerEditorAction(SnakeCaseAction);
if (TitleCaseAction.titleBoundary.isSupported()) registerEditorAction(TitleCaseAction);
if (KebabCaseAction.isSupported()) registerEditorAction(KebabCaseAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.js
var __decorate$24 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$24 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$14 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
var DECORATION_CLASS_NAME = "linked-editing-decoration";
var LinkedEditingContribution = class LinkedEditingContribution$1 extends Disposable {
	constructor(editor$1, contextKeyService, languageFeaturesService, languageConfigurationService, languageFeatureDebounceService) {
		super();
		this.languageConfigurationService = languageConfigurationService;
		this._syncRangesToken = 0;
		this._localToDispose = this._register(new DisposableStore());
		this._editor = editor$1;
		this._providers = languageFeaturesService.linkedEditingRangeProvider;
		this._enabled = false;
		this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
		this._debounceInformation = languageFeatureDebounceService.for(this._providers, "Linked Editing", { min: 200 });
		this._currentDecorations = this._editor.createDecorationsCollection();
		this._languageWordPattern = null;
		this._currentWordPattern = null;
		this._ignoreChangeEvent = false;
		this._localToDispose = this._register(new DisposableStore());
		this._rangeUpdateTriggerPromise = null;
		this._rangeSyncTriggerPromise = null;
		this._currentRequest = null;
		this._currentRequestPosition = null;
		this._currentRequestModelVersion = null;
		this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(64) || e.hasChanged(84)) this.reinitialize(false);
		}));
		this._register(this._providers.onDidChange(() => this.reinitialize(false)));
		this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
		this.reinitialize(true);
	}
	static get(editor$1) {
		return editor$1.getContribution(LinkedEditingContribution$1.ID);
	}
	reinitialize(forceRefresh) {
		const model = this._editor.getModel();
		const isEnabled = model !== null && (this._editor.getOption(64) || this._editor.getOption(84)) && this._providers.has(model);
		if (isEnabled === this._enabled && !forceRefresh) return;
		this._enabled = isEnabled;
		this.clearRanges();
		this._localToDispose.clear();
		if (!isEnabled || model === null) return;
		this._localToDispose.add(Event.runAndSubscribe(model.onDidChangeLanguageConfiguration, () => {
			this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
		}));
		const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));
		const triggerRangeUpdate = () => {
			var _a$5;
			this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), (_a$5 = this._debounceDuration) !== null && _a$5 !== void 0 ? _a$5 : this._debounceInformation.get(model));
		};
		const rangeSyncScheduler = new Delayer(0);
		const triggerRangeSync = (token) => {
			this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(token));
		};
		this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
			triggerRangeUpdate();
		}));
		this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
			if (!this._ignoreChangeEvent) {
				if (this._currentDecorations.length > 0) {
					const referenceRange = this._currentDecorations.getRange(0);
					if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
						triggerRangeSync(this._syncRangesToken);
						return;
					}
				}
			}
			triggerRangeUpdate();
		}));
		this._localToDispose.add({ dispose: () => {
			rangeUpdateScheduler.dispose();
			rangeSyncScheduler.dispose();
		} });
		this.updateRanges();
	}
	_syncRanges(token) {
		if (!this._editor.hasModel() || token !== this._syncRangesToken || this._currentDecorations.length === 0) return;
		const model = this._editor.getModel();
		const referenceRange = this._currentDecorations.getRange(0);
		if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) return this.clearRanges();
		const referenceValue = model.getValueInRange(referenceRange);
		if (this._currentWordPattern) {
			const match = referenceValue.match(this._currentWordPattern);
			if ((match ? match[0].length : 0) !== referenceValue.length) return this.clearRanges();
		}
		const edits = [];
		for (let i = 1, len = this._currentDecorations.length; i < len; i++) {
			const mirrorRange = this._currentDecorations.getRange(i);
			if (!mirrorRange) continue;
			if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) edits.push({
				range: mirrorRange,
				text: referenceValue
			});
			else {
				let oldValue = model.getValueInRange(mirrorRange);
				let newValue = referenceValue;
				let rangeStartColumn = mirrorRange.startColumn;
				let rangeEndColumn = mirrorRange.endColumn;
				const commonPrefixLength$1 = commonPrefixLength(oldValue, newValue);
				rangeStartColumn += commonPrefixLength$1;
				oldValue = oldValue.substr(commonPrefixLength$1);
				newValue = newValue.substr(commonPrefixLength$1);
				const commonSuffixLength$1 = commonSuffixLength(oldValue, newValue);
				rangeEndColumn -= commonSuffixLength$1;
				oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength$1);
				newValue = newValue.substr(0, newValue.length - commonSuffixLength$1);
				if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) edits.push({
					range: new Range$1(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
					text: newValue
				});
			}
		}
		if (edits.length === 0) return;
		try {
			this._editor.popUndoStop();
			this._ignoreChangeEvent = true;
			const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
			this._editor.executeEdits("linkedEditing", edits);
			this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
		} finally {
			this._ignoreChangeEvent = false;
		}
	}
	dispose() {
		this.clearRanges();
		super.dispose();
	}
	clearRanges() {
		this._visibleContextKey.set(false);
		this._currentDecorations.clear();
		if (this._currentRequest) {
			this._currentRequest.cancel();
			this._currentRequest = null;
			this._currentRequestPosition = null;
		}
	}
	updateRanges(force = false) {
		return __awaiter$14(this, void 0, void 0, function* () {
			if (!this._editor.hasModel()) {
				this.clearRanges();
				return;
			}
			const position = this._editor.getPosition();
			if (!this._enabled && !force || this._editor.getSelections().length > 1) {
				this.clearRanges();
				return;
			}
			const model = this._editor.getModel();
			const modelVersionId = model.getVersionId();
			if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
				if (position.equals(this._currentRequestPosition)) return;
				if (this._currentDecorations.length > 0) {
					const range = this._currentDecorations.getRange(0);
					if (range && range.containsPosition(position)) return;
				}
			}
			this._currentRequestPosition = position;
			this._currentRequestModelVersion = modelVersionId;
			const request = createCancelablePromise((token) => __awaiter$14(this, void 0, void 0, function* () {
				try {
					const sw = new StopWatch(false);
					const response = yield getLinkedEditingRanges(this._providers, model, position, token);
					this._debounceInformation.update(model, sw.elapsed());
					if (request !== this._currentRequest) return;
					this._currentRequest = null;
					if (modelVersionId !== model.getVersionId()) return;
					let ranges = [];
					if (response === null || response === void 0 ? void 0 : response.ranges) ranges = response.ranges;
					this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
					let foundReferenceRange = false;
					for (let i = 0, len = ranges.length; i < len; i++) if (Range$1.containsPosition(ranges[i], position)) {
						foundReferenceRange = true;
						if (i !== 0) {
							const referenceRange = ranges[i];
							ranges.splice(i, 1);
							ranges.unshift(referenceRange);
						}
						break;
					}
					if (!foundReferenceRange) {
						this.clearRanges();
						return;
					}
					const decorations = ranges.map((range) => ({
						range,
						options: LinkedEditingContribution$1.DECORATION
					}));
					this._visibleContextKey.set(true);
					this._currentDecorations.set(decorations);
					this._syncRangesToken++;
				} catch (err) {
					if (!isCancellationError(err)) onUnexpectedError(err);
					if (this._currentRequest === request || !this._currentRequest) this.clearRanges();
				}
			}));
			this._currentRequest = request;
			return request;
		});
	}
};
LinkedEditingContribution.ID = "editor.contrib.linkedEditing";
LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
	description: "linked-editing",
	stickiness: 0,
	className: DECORATION_CLASS_NAME
});
LinkedEditingContribution = __decorate$24([
	__param$24(1, IContextKeyService),
	__param$24(2, ILanguageFeaturesService),
	__param$24(3, ILanguageConfigurationService),
	__param$24(4, ILanguageFeatureDebounceService)
], LinkedEditingContribution);
var LinkedEditingAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.linkedEditing",
			label: localize("linkedEditing.label", "Start Linked Editing"),
			alias: "Start Linked Editing",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3132,
				weight: 100
			}
		});
	}
	runCommand(accessor, args) {
		const editorService = accessor.get(ICodeEditorService);
		const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
		if (URI.isUri(uri) && Position$1.isIPosition(pos)) return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor$1) => {
			if (!editor$1) return;
			editor$1.setPosition(pos);
			editor$1.invokeWithinContext((accessor$1) => {
				this.reportTelemetry(accessor$1, editor$1);
				return this.run(accessor$1, editor$1);
			});
		}, onUnexpectedError);
		return super.runCommand(accessor, args);
	}
	run(_accessor, editor$1) {
		const controller = LinkedEditingContribution.get(editor$1);
		if (controller) return Promise.resolve(controller.updateRanges(true));
		return Promise.resolve();
	}
};
registerEditorCommand(new (EditorCommand.bindToContribution(LinkedEditingContribution.get))({
	id: "cancelLinkedEditingInput",
	precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
	handler: (x) => x.clearRanges(),
	kbOpts: {
		kbExpr: EditorContextKeys.editorTextFocus,
		weight: 199,
		primary: 9,
		secondary: [1033]
	}
}));
function getLinkedEditingRanges(providers, model, position, token) {
	return first(providers.ordered(model).map((provider) => () => __awaiter$14(this, void 0, void 0, function* () {
		try {
			return yield provider.provideLinkedEditingRanges(model, position, token);
		} catch (e) {
			onUnexpectedExternalError(e);
			return;
		}
	})), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
const editorLinkedEditingBackground = registerColor("editor.linkedEditingBackground", {
	dark: Color.fromHex("#f00").transparent(.3),
	light: Color.fromHex("#f00").transparent(.3),
	hcDark: Color.fromHex("#f00").transparent(.3),
	hcLight: Color.white
}, localize("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
registerThemingParticipant((theme, collector) => {
	const editorLinkedEditingBackgroundColor = theme.getColor(editorLinkedEditingBackground);
	if (editorLinkedEditingBackgroundColor) collector.addRule(`.monaco-editor .${DECORATION_CLASS_NAME} { background: ${editorLinkedEditingBackgroundColor}; border-left-color: ${editorLinkedEditingBackgroundColor}; }`);
});
registerModelAndPositionCommand("_executeLinkedEditingProvider", (_accessor, model, position) => {
	const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);
	return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);
});
registerEditorContribution(LinkedEditingContribution.ID, LinkedEditingContribution);
registerEditorAction(LinkedEditingAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/getLinks.js
var __awaiter$13 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var Link$1 = class {
	constructor(link, provider) {
		this._link = link;
		this._provider = provider;
	}
	toJSON() {
		return {
			range: this.range,
			url: this.url,
			tooltip: this.tooltip
		};
	}
	get range() {
		return this._link.range;
	}
	get url() {
		return this._link.url;
	}
	get tooltip() {
		return this._link.tooltip;
	}
	resolve(token) {
		return __awaiter$13(this, void 0, void 0, function* () {
			if (this._link.url) return this._link.url;
			if (typeof this._provider.resolveLink === "function") return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
				this._link = value || this._link;
				if (this._link.url) return this.resolve(token);
				return Promise.reject(/* @__PURE__ */ new Error("missing"));
			});
			return Promise.reject(/* @__PURE__ */ new Error("missing"));
		});
	}
};
var LinksList = class LinksList {
	constructor(tuples) {
		this._disposables = new DisposableStore();
		let links = [];
		for (const [list, provider] of tuples) {
			const newLinks = list.links.map((link) => new Link$1(link, provider));
			links = LinksList._union(links, newLinks);
			if (isDisposable(list)) this._disposables.add(list);
		}
		this.links = links;
	}
	dispose() {
		this._disposables.dispose();
		this.links.length = 0;
	}
	static _union(oldLinks, newLinks) {
		const result = [];
		let oldIndex;
		let oldLen;
		let newIndex;
		let newLen;
		for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen;) {
			const oldLink = oldLinks[oldIndex];
			const newLink = newLinks[newIndex];
			if (Range$1.areIntersectingOrTouching(oldLink.range, newLink.range)) {
				oldIndex++;
				continue;
			}
			if (Range$1.compareRangesUsingStarts(oldLink.range, newLink.range) < 0) {
				result.push(oldLink);
				oldIndex++;
			} else {
				result.push(newLink);
				newIndex++;
			}
		}
		for (; oldIndex < oldLen; oldIndex++) result.push(oldLinks[oldIndex]);
		for (; newIndex < newLen; newIndex++) result.push(newLinks[newIndex]);
		return result;
	}
};
function getLinks(providers, model, token) {
	const lists = [];
	const promises = providers.ordered(model).reverse().map((provider, i) => {
		return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
			if (result) lists[i] = [result, provider];
		}, onUnexpectedExternalError);
	});
	return Promise.all(promises).then(() => {
		const result = new LinksList(coalesce(lists));
		if (!token.isCancellationRequested) return result;
		result.dispose();
		return new LinksList([]);
	});
}
CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter$13(void 0, void 0, void 0, function* () {
	let [uri, resolveCount] = args;
	assertType(uri instanceof URI);
	if (typeof resolveCount !== "number") resolveCount = 0;
	const { linkProvider } = accessor.get(ILanguageFeaturesService);
	const model = accessor.get(IModelService).getModel(uri);
	if (!model) return [];
	const list = yield getLinks(linkProvider, model, CancellationToken.None);
	if (!list) return [];
	for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) yield list.links[i].resolve(CancellationToken.None);
	const result = list.links.slice(0);
	list.dispose();
	return result;
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
var __decorate$23 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$23 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$12 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var LinkDetector = class LinkDetector$1 extends Disposable {
	constructor(editor$1, openerService, notificationService, languageFeaturesService, languageFeatureDebounceService) {
		super();
		this.editor = editor$1;
		this.openerService = openerService;
		this.notificationService = notificationService;
		this.languageFeaturesService = languageFeaturesService;
		this.providers = this.languageFeaturesService.linkProvider;
		this.debounceInformation = languageFeatureDebounceService.for(this.providers, "Links", {
			min: 1e3,
			max: 4e3
		});
		this.computeLinks = this._register(new RunOnceScheduler(() => this.computeLinksNow(), 1e3));
		this.computePromise = null;
		this.activeLinksList = null;
		this.currentOccurrences = {};
		this.activeLinkDecorationId = null;
		const clickLinkGesture = this._register(new ClickLinkGesture(editor$1));
		this._register(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
			this._onEditorMouseMove(mouseEvent, keyboardEvent);
		}));
		this._register(clickLinkGesture.onExecute((e) => {
			this.onEditorMouseUp(e);
		}));
		this._register(clickLinkGesture.onCancel((e) => {
			this.cleanUpActiveLinkDecoration();
		}));
		this._register(editor$1.onDidChangeConfiguration((e) => {
			if (!e.hasChanged(65)) return;
			this.updateDecorations([]);
			this.stop();
			this.computeLinks.schedule(0);
		}));
		this._register(editor$1.onDidChangeModelContent((e) => {
			if (!this.editor.hasModel()) return;
			this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
		}));
		this._register(editor$1.onDidChangeModel((e) => {
			this.currentOccurrences = {};
			this.activeLinkDecorationId = null;
			this.stop();
			this.computeLinks.schedule(0);
		}));
		this._register(editor$1.onDidChangeModelLanguage((e) => {
			this.stop();
			this.computeLinks.schedule(0);
		}));
		this._register(this.providers.onDidChange((e) => {
			this.stop();
			this.computeLinks.schedule(0);
		}));
		this.computeLinks.schedule(0);
	}
	static get(editor$1) {
		return editor$1.getContribution(LinkDetector$1.ID);
	}
	computeLinksNow() {
		return __awaiter$12(this, void 0, void 0, function* () {
			if (!this.editor.hasModel() || !this.editor.getOption(65)) return;
			const model = this.editor.getModel();
			if (!this.providers.has(model)) return;
			if (this.activeLinksList) {
				this.activeLinksList.dispose();
				this.activeLinksList = null;
			}
			this.computePromise = createCancelablePromise((token) => getLinks(this.providers, model, token));
			try {
				const sw = new StopWatch(false);
				this.activeLinksList = yield this.computePromise;
				this.debounceInformation.update(model, sw.elapsed());
				if (model.isDisposed()) return;
				this.updateDecorations(this.activeLinksList.links);
			} catch (err) {
				onUnexpectedError(err);
			} finally {
				this.computePromise = null;
			}
		});
	}
	updateDecorations(links) {
		const useMetaKey = this.editor.getOption(72) === "altKey";
		const oldDecorations = [];
		const keys = Object.keys(this.currentOccurrences);
		for (const decorationId of keys) {
			const occurence = this.currentOccurrences[decorationId];
			oldDecorations.push(occurence.decorationId);
		}
		const newDecorations = [];
		if (links) for (const link of links) newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
		this.editor.changeDecorations((changeAccessor) => {
			const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
			this.currentOccurrences = {};
			this.activeLinkDecorationId = null;
			for (let i = 0, len = decorations.length; i < len; i++) {
				const occurence = new LinkOccurrence(links[i], decorations[i]);
				this.currentOccurrences[occurence.decorationId] = occurence;
			}
		});
	}
	_onEditorMouseMove(mouseEvent, withKey) {
		const useMetaKey = this.editor.getOption(72) === "altKey";
		if (this.isEnabled(mouseEvent, withKey)) {
			this.cleanUpActiveLinkDecoration();
			const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
			if (occurrence) this.editor.changeDecorations((changeAccessor) => {
				occurrence.activate(changeAccessor, useMetaKey);
				this.activeLinkDecorationId = occurrence.decorationId;
			});
		} else this.cleanUpActiveLinkDecoration();
	}
	cleanUpActiveLinkDecoration() {
		const useMetaKey = this.editor.getOption(72) === "altKey";
		if (this.activeLinkDecorationId) {
			const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
			if (occurrence) this.editor.changeDecorations((changeAccessor) => {
				occurrence.deactivate(changeAccessor, useMetaKey);
			});
			this.activeLinkDecorationId = null;
		}
	}
	onEditorMouseUp(mouseEvent) {
		if (!this.isEnabled(mouseEvent)) return;
		const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
		if (!occurrence) return;
		this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier, true);
	}
	openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
		if (!this.openerService) return;
		const { link } = occurrence;
		link.resolve(CancellationToken.None).then((uri) => {
			if (typeof uri === "string" && this.editor.hasModel()) {
				const modelUri = this.editor.getModel().uri;
				if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
					const parsedUri = URI.parse(uri);
					if (parsedUri.scheme === Schemas.file) {
						const fsPath = originalFSPath(parsedUri);
						let relativePath$1 = null;
						if (fsPath.startsWith("/./")) relativePath$1 = `.${fsPath.substr(1)}`;
						else if (fsPath.startsWith("//./")) relativePath$1 = `.${fsPath.substr(2)}`;
						if (relativePath$1) uri = joinPath(modelUri, relativePath$1);
					}
				}
			}
			return this.openerService.open(uri, {
				openToSide,
				fromUserGesture,
				allowContributedOpeners: true,
				allowCommands: true,
				fromWorkspace: true
			});
		}, (err) => {
			const messageOrError = err instanceof Error ? err.message : err;
			if (messageOrError === "invalid") this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
			else if (messageOrError === "missing") this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
			else onUnexpectedError(err);
		});
	}
	getLinkOccurrence(position) {
		if (!this.editor.hasModel() || !position) return null;
		const decorations = this.editor.getModel().getDecorationsInRange({
			startLineNumber: position.lineNumber,
			startColumn: position.column,
			endLineNumber: position.lineNumber,
			endColumn: position.column
		}, 0, true);
		for (const decoration$1 of decorations) {
			const currentOccurrence = this.currentOccurrences[decoration$1.id];
			if (currentOccurrence) return currentOccurrence;
		}
		return null;
	}
	isEnabled(mouseEvent, withKey) {
		return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
	}
	stop() {
		var _a$5;
		this.computeLinks.cancel();
		if (this.activeLinksList) {
			(_a$5 = this.activeLinksList) === null || _a$5 === void 0 || _a$5.dispose();
			this.activeLinksList = null;
		}
		if (this.computePromise) {
			this.computePromise.cancel();
			this.computePromise = null;
		}
	}
	dispose() {
		super.dispose();
		this.stop();
	}
};
LinkDetector.ID = "editor.linkDetector";
LinkDetector = __decorate$23([
	__param$23(1, IOpenerService),
	__param$23(2, INotificationService),
	__param$23(3, ILanguageFeaturesService),
	__param$23(4, ILanguageFeatureDebounceService)
], LinkDetector);
var decoration = {
	general: ModelDecorationOptions.register({
		description: "detected-link",
		stickiness: 1,
		collapseOnReplaceEdit: true,
		inlineClassName: "detected-link"
	}),
	active: ModelDecorationOptions.register({
		description: "detected-link-active",
		stickiness: 1,
		collapseOnReplaceEdit: true,
		inlineClassName: "detected-link-active"
	})
};
var LinkOccurrence = class LinkOccurrence {
	constructor(link, decorationId) {
		this.link = link;
		this.decorationId = decorationId;
	}
	static decoration(link, useMetaKey) {
		return {
			range: link.range,
			options: LinkOccurrence._getOptions(link, useMetaKey, false)
		};
	}
	static _getOptions(link, useMetaKey, isActive) {
		const options = Object.assign({}, isActive ? decoration.active : decoration.general);
		options.hoverMessage = getHoverMessage(link, useMetaKey);
		return options;
	}
	activate(changeAccessor, useMetaKey) {
		changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
	}
	deactivate(changeAccessor, useMetaKey) {
		changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
	}
};
function getHoverMessage(link, useMetaKey) {
	const executeCmd = link.url && /^command:/i.test(link.url.toString());
	const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
	const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
	if (link.url) {
		let nativeLabel = "";
		if (/^command:/i.test(link.url.toString())) {
			const match = link.url.toString().match(/^command:([^?#]+)/);
			if (match) {
				const commandId = match[1];
				nativeLabel = localize("tooltip.explanation", "Execute command {0}", commandId);
			}
		}
		return new MarkdownString("", true).appendLink(link.url.toString(true).replace(/ /g, "%20"), label, nativeLabel).appendMarkdown(` (${kb})`);
	} else return new MarkdownString().appendText(`${label} (${kb})`);
}
var OpenLinkAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.openLink",
			label: localize("label", "Open Link"),
			alias: "Open Link",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		const linkDetector = LinkDetector.get(editor$1);
		if (!linkDetector) return;
		if (!editor$1.hasModel()) return;
		const selections = editor$1.getSelections();
		for (const sel of selections) {
			const link = linkDetector.getLinkOccurrence(sel.getEndPosition());
			if (link) linkDetector.openLinkOccurrence(link, false);
		}
	}
};
registerEditorContribution(LinkDetector.ID, LinkDetector);
registerEditorAction(OpenLinkAction);
registerThemingParticipant((theme, collector) => {
	const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
	if (activeLinkForeground) collector.addRule(`.monaco-editor .detected-link-active { color: ${activeLinkForeground} !important; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
var __decorate$22 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$22 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
function announceCursorChange(previousCursorState, cursorState) {
	const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
	if (cursorDiff.length >= 1) {
		const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
		status(cursorDiff.length === 1 ? localize("cursorAdded", "Cursor added: {0}", cursorPositions) : localize("cursorsAdded", "Cursors added: {0}", cursorPositions));
	}
}
var InsertCursorAbove = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.insertCursorAbove",
			label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
			alias: "Add Cursor Above",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2576,
				linux: {
					primary: 1552,
					secondary: [3088]
				},
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "3_multi",
				title: localize({
					key: "miInsertCursorAbove",
					comment: ["&& denotes a mnemonic"]
				}, "&&Add Cursor Above"),
				order: 2
			}
		});
	}
	run(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		let useLogicalLine = true;
		if (args && args.logicalLine === false) useLogicalLine = false;
		const viewModel = editor$1._getViewModel();
		if (viewModel.cursorConfig.readOnly) return;
		viewModel.model.pushStackElement();
		const previousCursorState = viewModel.getCursorStates();
		viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
		viewModel.revealTopMostCursor(args.source);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
var InsertCursorBelow = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.insertCursorBelow",
			label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
			alias: "Add Cursor Below",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2578,
				linux: {
					primary: 1554,
					secondary: [3090]
				},
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "3_multi",
				title: localize({
					key: "miInsertCursorBelow",
					comment: ["&& denotes a mnemonic"]
				}, "A&&dd Cursor Below"),
				order: 3
			}
		});
	}
	run(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		let useLogicalLine = true;
		if (args && args.logicalLine === false) useLogicalLine = false;
		const viewModel = editor$1._getViewModel();
		if (viewModel.cursorConfig.readOnly) return;
		viewModel.model.pushStackElement();
		const previousCursorState = viewModel.getCursorStates();
		viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
		viewModel.revealBottomMostCursor(args.source);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
var InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.insertCursorAtEndOfEachLineSelected",
			label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
			alias: "Add Cursors to Line Ends",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1575,
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "3_multi",
				title: localize({
					key: "miInsertCursorAtEndOfEachLineSelected",
					comment: ["&& denotes a mnemonic"]
				}, "Add C&&ursors to Line Ends"),
				order: 4
			}
		});
	}
	getCursorsForSelection(selection, model, result) {
		if (selection.isEmpty()) return;
		for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
			const currentLineMaxColumn = model.getLineMaxColumn(i);
			result.push(new Selection$1(i, currentLineMaxColumn, i, currentLineMaxColumn));
		}
		if (selection.endColumn > 1) result.push(new Selection$1(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const model = editor$1.getModel();
		const selections = editor$1.getSelections();
		const viewModel = editor$1._getViewModel();
		const previousCursorState = viewModel.getCursorStates();
		const newSelections = [];
		selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
		if (newSelections.length > 0) editor$1.setSelections(newSelections);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
var InsertCursorAtEndOfLineSelected = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.addCursorsToBottom",
			label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
			alias: "Add Cursors To Bottom",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const selections = editor$1.getSelections();
		const lineCount = editor$1.getModel().getLineCount();
		const newSelections = [];
		for (let i = selections[0].startLineNumber; i <= lineCount; i++) newSelections.push(new Selection$1(i, selections[0].startColumn, i, selections[0].endColumn));
		const viewModel = editor$1._getViewModel();
		const previousCursorState = viewModel.getCursorStates();
		if (newSelections.length > 0) editor$1.setSelections(newSelections);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
var InsertCursorAtTopOfLineSelected = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.addCursorsToTop",
			label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
			alias: "Add Cursors To Top",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const selections = editor$1.getSelections();
		const newSelections = [];
		for (let i = selections[0].startLineNumber; i >= 1; i--) newSelections.push(new Selection$1(i, selections[0].startColumn, i, selections[0].endColumn));
		const viewModel = editor$1._getViewModel();
		const previousCursorState = viewModel.getCursorStates();
		if (newSelections.length > 0) editor$1.setSelections(newSelections);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
var MultiCursorSessionResult = class {
	constructor(selections, revealRange, revealScrollType) {
		this.selections = selections;
		this.revealRange = revealRange;
		this.revealScrollType = revealScrollType;
	}
};
var MultiCursorSession = class MultiCursorSession {
	constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
		this._editor = _editor;
		this.findController = findController;
		this.isDisconnectedFromFindController = isDisconnectedFromFindController;
		this.searchText = searchText;
		this.wholeWord = wholeWord;
		this.matchCase = matchCase;
		this.currentMatch = currentMatch;
	}
	static create(editor$1, findController) {
		if (!editor$1.hasModel()) return null;
		const findState = findController.getState();
		if (!editor$1.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) return new MultiCursorSession(editor$1, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
		let isDisconnectedFromFindController = false;
		let wholeWord;
		let matchCase;
		const selections = editor$1.getSelections();
		if (selections.length === 1 && selections[0].isEmpty()) {
			isDisconnectedFromFindController = true;
			wholeWord = true;
			matchCase = true;
		} else {
			wholeWord = findState.wholeWord;
			matchCase = findState.matchCase;
		}
		const s = editor$1.getSelection();
		let searchText;
		let currentMatch = null;
		if (s.isEmpty()) {
			const word = editor$1.getConfiguredWordAtPosition(s.getStartPosition());
			if (!word) return null;
			searchText = word.word;
			currentMatch = new Selection$1(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
		} else searchText = editor$1.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
		return new MultiCursorSession(editor$1, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
	}
	addSelectionToNextFindMatch() {
		if (!this._editor.hasModel()) return null;
		const nextMatch = this._getNextMatch();
		if (!nextMatch) return null;
		return new MultiCursorSessionResult(this._editor.getSelections().concat(nextMatch), nextMatch, 0);
	}
	moveSelectionToNextFindMatch() {
		if (!this._editor.hasModel()) return null;
		const nextMatch = this._getNextMatch();
		if (!nextMatch) return null;
		const allSelections = this._editor.getSelections();
		return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0);
	}
	_getNextMatch() {
		if (!this._editor.hasModel()) return null;
		if (this.currentMatch) {
			const result = this.currentMatch;
			this.currentMatch = null;
			return result;
		}
		this.findController.highlightFindOptions();
		const allSelections = this._editor.getSelections();
		const lastAddedSelection = allSelections[allSelections.length - 1];
		const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(119) : null, false);
		if (!nextMatch) return null;
		return new Selection$1(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
	}
	addSelectionToPreviousFindMatch() {
		if (!this._editor.hasModel()) return null;
		const previousMatch = this._getPreviousMatch();
		if (!previousMatch) return null;
		return new MultiCursorSessionResult(this._editor.getSelections().concat(previousMatch), previousMatch, 0);
	}
	moveSelectionToPreviousFindMatch() {
		if (!this._editor.hasModel()) return null;
		const previousMatch = this._getPreviousMatch();
		if (!previousMatch) return null;
		const allSelections = this._editor.getSelections();
		return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0);
	}
	_getPreviousMatch() {
		if (!this._editor.hasModel()) return null;
		if (this.currentMatch) {
			const result = this.currentMatch;
			this.currentMatch = null;
			return result;
		}
		this.findController.highlightFindOptions();
		const allSelections = this._editor.getSelections();
		const lastAddedSelection = allSelections[allSelections.length - 1];
		const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(119) : null, false);
		if (!previousMatch) return null;
		return new Selection$1(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
	}
	selectAll(searchScope) {
		if (!this._editor.hasModel()) return [];
		this.findController.highlightFindOptions();
		const editorModel = this._editor.getModel();
		if (searchScope) return editorModel.findMatches(this.searchText, searchScope, false, this.matchCase, this.wholeWord ? this._editor.getOption(119) : null, false, 1073741824);
		return editorModel.findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getOption(119) : null, false, 1073741824);
	}
};
var MultiCursorSelectionController = class MultiCursorSelectionController extends Disposable {
	constructor(editor$1) {
		super();
		this._sessionDispose = this._register(new DisposableStore());
		this._editor = editor$1;
		this._ignoreSelectionChange = false;
		this._session = null;
	}
	static get(editor$1) {
		return editor$1.getContribution(MultiCursorSelectionController.ID);
	}
	dispose() {
		this._endSession();
		super.dispose();
	}
	_beginSessionIfNeeded(findController) {
		if (!this._session) {
			const session = MultiCursorSession.create(this._editor, findController);
			if (!session) return;
			this._session = session;
			const newState = { searchString: this._session.searchText };
			if (this._session.isDisconnectedFromFindController) {
				newState.wholeWordOverride = 1;
				newState.matchCaseOverride = 1;
				newState.isRegexOverride = 2;
			}
			findController.getState().change(newState, false);
			this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
				if (this._ignoreSelectionChange) return;
				this._endSession();
			}));
			this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
				this._endSession();
			}));
			this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
				if (e.matchCase || e.wholeWord) this._endSession();
			}));
		}
	}
	_endSession() {
		this._sessionDispose.clear();
		if (this._session && this._session.isDisconnectedFromFindController) this._session.findController.getState().change({
			wholeWordOverride: 0,
			matchCaseOverride: 0,
			isRegexOverride: 0
		}, false);
		this._session = null;
	}
	_setSelections(selections) {
		this._ignoreSelectionChange = true;
		this._editor.setSelections(selections);
		this._ignoreSelectionChange = false;
	}
	_expandEmptyToWord(model, selection) {
		if (!selection.isEmpty()) return selection;
		const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
		if (!word) return selection;
		return new Selection$1(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
	}
	_applySessionResult(result) {
		if (!result) return;
		this._setSelections(result.selections);
		if (result.revealRange) this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
	}
	getSession(findController) {
		return this._session;
	}
	addSelectionToNextFindMatch(findController) {
		if (!this._editor.hasModel()) return;
		if (!this._session) {
			const allSelections = this._editor.getSelections();
			if (allSelections.length > 1) {
				const matchCase = findController.getState().matchCase;
				if (!modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase)) {
					const model = this._editor.getModel();
					const resultingSelections = [];
					for (let i = 0, len = allSelections.length; i < len; i++) resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
					this._editor.setSelections(resultingSelections);
					return;
				}
			}
		}
		this._beginSessionIfNeeded(findController);
		if (this._session) this._applySessionResult(this._session.addSelectionToNextFindMatch());
	}
	addSelectionToPreviousFindMatch(findController) {
		this._beginSessionIfNeeded(findController);
		if (this._session) this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
	}
	moveSelectionToNextFindMatch(findController) {
		this._beginSessionIfNeeded(findController);
		if (this._session) this._applySessionResult(this._session.moveSelectionToNextFindMatch());
	}
	moveSelectionToPreviousFindMatch(findController) {
		this._beginSessionIfNeeded(findController);
		if (this._session) this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
	}
	selectAll(findController) {
		if (!this._editor.hasModel()) return;
		let matches = null;
		const findState = findController.getState();
		if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
			const editorModel = this._editor.getModel();
			if (findState.searchScope) matches = editorModel.findMatches(findState.searchString, findState.searchScope, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(119) : null, false, 1073741824);
			else matches = editorModel.findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(119) : null, false, 1073741824);
		} else {
			this._beginSessionIfNeeded(findController);
			if (!this._session) return;
			matches = this._session.selectAll(findState.searchScope);
		}
		if (matches.length > 0) {
			const editorSelection = this._editor.getSelection();
			for (let i = 0, len = matches.length; i < len; i++) {
				const match = matches[i];
				if (match.range.intersectRanges(editorSelection)) {
					matches[i] = matches[0];
					matches[0] = match;
					break;
				}
			}
			this._setSelections(matches.map((m) => new Selection$1(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
		}
	}
};
MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
var MultiCursorSelectionControllerAction = class extends EditorAction {
	run(accessor, editor$1) {
		const multiCursorController = MultiCursorSelectionController.get(editor$1);
		if (!multiCursorController) return;
		const findController = CommonFindController.get(editor$1);
		if (!findController) return;
		const viewModel = editor$1._getViewModel();
		if (viewModel) {
			const previousCursorState = viewModel.getCursorStates();
			this._run(multiCursorController, findController);
			announceCursorChange(previousCursorState, viewModel.getCursorStates());
		}
	}
};
var AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
	constructor() {
		super({
			id: "editor.action.addSelectionToNextFindMatch",
			label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
			alias: "Add Selection To Next Find Match",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 2082,
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "3_multi",
				title: localize({
					key: "miAddSelectionToNextFindMatch",
					comment: ["&& denotes a mnemonic"]
				}, "Add &&Next Occurrence"),
				order: 5
			}
		});
	}
	_run(multiCursorController, findController) {
		multiCursorController.addSelectionToNextFindMatch(findController);
	}
};
var AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
	constructor() {
		super({
			id: "editor.action.addSelectionToPreviousFindMatch",
			label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
			alias: "Add Selection To Previous Find Match",
			precondition: void 0,
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "3_multi",
				title: localize({
					key: "miAddSelectionToPreviousFindMatch",
					comment: ["&& denotes a mnemonic"]
				}, "Add P&&revious Occurrence"),
				order: 6
			}
		});
	}
	_run(multiCursorController, findController) {
		multiCursorController.addSelectionToPreviousFindMatch(findController);
	}
};
var MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
	constructor() {
		super({
			id: "editor.action.moveSelectionToNextFindMatch",
			label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
			alias: "Move Last Selection To Next Find Match",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: KeyChord(2089, 2082),
				weight: 100
			}
		});
	}
	_run(multiCursorController, findController) {
		multiCursorController.moveSelectionToNextFindMatch(findController);
	}
};
var MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
	constructor() {
		super({
			id: "editor.action.moveSelectionToPreviousFindMatch",
			label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
			alias: "Move Last Selection To Previous Find Match",
			precondition: void 0
		});
	}
	_run(multiCursorController, findController) {
		multiCursorController.moveSelectionToPreviousFindMatch(findController);
	}
};
var SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
	constructor() {
		super({
			id: "editor.action.selectHighlights",
			label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
			alias: "Select All Occurrences of Find Match",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 3114,
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "3_multi",
				title: localize({
					key: "miSelectHighlights",
					comment: ["&& denotes a mnemonic"]
				}, "Select All &&Occurrences"),
				order: 7
			}
		});
	}
	_run(multiCursorController, findController) {
		multiCursorController.selectAll(findController);
	}
};
var CompatChangeAll = class extends MultiCursorSelectionControllerAction {
	constructor() {
		super({
			id: "editor.action.changeAll",
			label: localize("changeAll.label", "Change All Occurrences"),
			alias: "Change All Occurrences",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 2108,
				weight: 100
			},
			contextMenuOpts: {
				group: "1_modification",
				order: 1.2
			}
		});
	}
	_run(multiCursorController, findController) {
		multiCursorController.selectAll(findController);
	}
};
var SelectionHighlighterState = class {
	constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {
		this._model = _model;
		this._searchText = _searchText;
		this._matchCase = _matchCase;
		this._wordSeparators = _wordSeparators;
		this._modelVersionId = this._model.getVersionId();
		this._cachedFindMatches = null;
		if (prevState && this._model === prevState._model && this._searchText === prevState._searchText && this._matchCase === prevState._matchCase && this._wordSeparators === prevState._wordSeparators && this._modelVersionId === prevState._modelVersionId) this._cachedFindMatches = prevState._cachedFindMatches;
	}
	findMatches() {
		if (this._cachedFindMatches === null) {
			this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map((m) => m.range);
			this._cachedFindMatches.sort(Range$1.compareRangesUsingStarts);
		}
		return this._cachedFindMatches;
	}
};
var SelectionHighlighter = class SelectionHighlighter$1 extends Disposable {
	constructor(editor$1, _languageFeaturesService) {
		super();
		this._languageFeaturesService = _languageFeaturesService;
		this.editor = editor$1;
		this._isEnabled = editor$1.getOption(99);
		this._decorations = editor$1.createDecorationsCollection();
		this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
		this.state = null;
		this._register(editor$1.onDidChangeConfiguration((e) => {
			this._isEnabled = editor$1.getOption(99);
		}));
		this._register(editor$1.onDidChangeCursorSelection((e) => {
			if (!this._isEnabled) return;
			if (e.selection.isEmpty()) if (e.reason === 3) {
				if (this.state) this._setState(null);
				this.updateSoon.schedule();
			} else this._setState(null);
			else this._update();
		}));
		this._register(editor$1.onDidChangeModel((e) => {
			this._setState(null);
		}));
		this._register(editor$1.onDidChangeModelContent((e) => {
			if (this._isEnabled) this.updateSoon.schedule();
		}));
		const findController = CommonFindController.get(editor$1);
		if (findController) this._register(findController.getState().onFindReplaceStateChange((e) => {
			this._update();
		}));
	}
	_update() {
		this._setState(SelectionHighlighter$1._createState(this.state, this._isEnabled, this.editor));
	}
	static _createState(oldState, isEnabled, editor$1) {
		if (!isEnabled) return null;
		if (!editor$1.hasModel()) return null;
		const s = editor$1.getSelection();
		if (s.startLineNumber !== s.endLineNumber) return null;
		const multiCursorController = MultiCursorSelectionController.get(editor$1);
		if (!multiCursorController) return null;
		const findController = CommonFindController.get(editor$1);
		if (!findController) return null;
		let r = multiCursorController.getSession(findController);
		if (!r) {
			const allSelections = editor$1.getSelections();
			if (allSelections.length > 1) {
				const matchCase = findController.getState().matchCase;
				if (!modelRangesContainSameText(editor$1.getModel(), allSelections, matchCase)) return null;
			}
			r = MultiCursorSession.create(editor$1, findController);
		}
		if (!r) return null;
		if (r.currentMatch) return null;
		if (/^[ \t]+$/.test(r.searchText)) return null;
		if (r.searchText.length > 200) return null;
		const findState = findController.getState();
		const caseSensitive = findState.matchCase;
		if (findState.isRevealed) {
			let findStateSearchString = findState.searchString;
			if (!caseSensitive) findStateSearchString = findStateSearchString.toLowerCase();
			let mySearchString = r.searchText;
			if (!caseSensitive) mySearchString = mySearchString.toLowerCase();
			if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) return null;
		}
		return new SelectionHighlighterState(editor$1.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor$1.getOption(119) : null, oldState);
	}
	_setState(newState) {
		this.state = newState;
		if (!this.state) {
			this._decorations.clear();
			return;
		}
		if (!this.editor.hasModel()) return;
		const model = this.editor.getModel();
		if (model.isTooLargeForTokenization()) return;
		const allMatches = this.state.findMatches();
		const selections = this.editor.getSelections();
		selections.sort(Range$1.compareRangesUsingStarts);
		const matches = [];
		for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {
			const match = allMatches[i];
			if (j >= lenJ) {
				matches.push(match);
				i++;
			} else {
				const cmp = Range$1.compareRangesUsingStarts(match, selections[j]);
				if (cmp < 0) {
					if (selections[j].isEmpty() || !Range$1.areIntersecting(match, selections[j])) matches.push(match);
					i++;
				} else if (cmp > 0) j++;
				else {
					i++;
					j++;
				}
			}
		}
		const hasFindOccurrences = this._languageFeaturesService.documentHighlightProvider.has(model) && this.editor.getOption(74);
		const decorations = matches.map((r) => {
			return {
				range: r,
				options: hasFindOccurrences ? SelectionHighlighter$1._SELECTION_HIGHLIGHT : SelectionHighlighter$1._SELECTION_HIGHLIGHT_OVERVIEW
			};
		});
		this._decorations.set(decorations);
	}
	dispose() {
		this._setState(null);
		super.dispose();
	}
};
SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = ModelDecorationOptions.register({
	description: "selection-highlight-overview",
	stickiness: 1,
	className: "selectionHighlight",
	minimap: {
		color: themeColorFromId(minimapSelectionOccurrenceHighlight),
		position: MinimapPosition.Inline
	},
	overviewRuler: {
		color: themeColorFromId(overviewRulerSelectionHighlightForeground),
		position: OverviewRulerLane.Center
	}
});
SelectionHighlighter._SELECTION_HIGHLIGHT = ModelDecorationOptions.register({
	description: "selection-highlight",
	stickiness: 1,
	className: "selectionHighlight"
});
SelectionHighlighter = __decorate$22([__param$22(1, ILanguageFeaturesService)], SelectionHighlighter);
function modelRangesContainSameText(model, ranges, matchCase) {
	const selectedText = getValueInRange(model, ranges[0], !matchCase);
	for (let i = 1, len = ranges.length; i < len; i++) {
		const range = ranges[i];
		if (range.isEmpty()) return false;
		if (selectedText !== getValueInRange(model, range, !matchCase)) return false;
	}
	return true;
}
function getValueInRange(model, range, toLowerCase) {
	const text = model.getValueInRange(range);
	return toLowerCase ? text.toLowerCase() : text;
}
var FocusNextCursor = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.focusNextCursor",
			label: localize("mutlicursor.focusNextCursor", "Focus Next Cursor"),
			description: {
				description: localize("mutlicursor.focusNextCursor.description", "Focuses the next cursor"),
				args: []
			},
			alias: "Focus Next Cursor",
			precondition: void 0
		});
	}
	run(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		const viewModel = editor$1._getViewModel();
		if (viewModel.cursorConfig.readOnly) return;
		viewModel.model.pushStackElement();
		const previousCursorState = Array.from(viewModel.getCursorStates());
		const firstCursor = previousCursorState.shift();
		if (!firstCursor) return;
		previousCursorState.push(firstCursor);
		viewModel.setCursorStates(args.source, 3, previousCursorState);
		viewModel.revealPrimaryCursor(args.source, true);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
var FocusPreviousCursor = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.focusPreviousCursor",
			label: localize("mutlicursor.focusPreviousCursor", "Focus Previous Cursor"),
			description: {
				description: localize("mutlicursor.focusPreviousCursor.description", "Focuses the previous cursor"),
				args: []
			},
			alias: "Focus Previous Cursor",
			precondition: void 0
		});
	}
	run(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		const viewModel = editor$1._getViewModel();
		if (viewModel.cursorConfig.readOnly) return;
		viewModel.model.pushStackElement();
		const previousCursorState = Array.from(viewModel.getCursorStates());
		const firstCursor = previousCursorState.pop();
		if (!firstCursor) return;
		previousCursorState.unshift(firstCursor);
		viewModel.setCursorStates(args.source, 3, previousCursorState);
		viewModel.revealPrimaryCursor(args.source, true);
		announceCursorChange(previousCursorState, viewModel.getCursorStates());
	}
};
registerEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController);
registerEditorContribution(SelectionHighlighter.ID, SelectionHighlighter);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);
registerEditorAction(FocusNextCursor);
registerEditorAction(FocusPreviousCursor);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js
var __awaiter$11 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const Context = {
	Visible: new RawContextKey("parameterHintsVisible", false),
	MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
function provideSignatureHelp(registry, model, position, context, token) {
	return __awaiter$11(this, void 0, void 0, function* () {
		const supports = registry.ordered(model);
		for (const support of supports) try {
			const result = yield support.provideSignatureHelp(model, position, token, context);
			if (result) return result;
		} catch (err) {
			onUnexpectedExternalError(err);
		}
	});
}
CommandsRegistry.registerCommand("_executeSignatureHelpProvider", (accessor, ...args) => __awaiter$11(void 0, void 0, void 0, function* () {
	const [uri, position, triggerCharacter] = args;
	assertType(URI.isUri(uri));
	assertType(Position$1.isIPosition(position));
	assertType(typeof triggerCharacter === "string" || !triggerCharacter);
	const languageFeaturesService = accessor.get(ILanguageFeaturesService);
	const ref = yield accessor.get(ITextModelService).createModelReference(uri);
	try {
		const result = yield provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position$1.lift(position), {
			triggerKind: SignatureHelpTriggerKind.Invoke,
			isRetrigger: false,
			triggerCharacter
		}, CancellationToken.None);
		if (!result) return;
		setTimeout(() => result.dispose(), 0);
		return result.value;
	} finally {
		ref.dispose();
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
var __awaiter$10 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var ParameterHintState;
(function(ParameterHintState$1) {
	ParameterHintState$1.Default = { type: 0 };
	class Pending {
		constructor(request, previouslyActiveHints) {
			this.request = request;
			this.previouslyActiveHints = previouslyActiveHints;
			this.type = 2;
		}
	}
	ParameterHintState$1.Pending = Pending;
	class Active {
		constructor(hints) {
			this.hints = hints;
			this.type = 1;
		}
	}
	ParameterHintState$1.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
var ParameterHintsModel = class ParameterHintsModel extends Disposable {
	constructor(editor$1, providers, delay = ParameterHintsModel.DEFAULT_DELAY) {
		super();
		this._onChangedHints = this._register(new Emitter$1());
		this.onChangedHints = this._onChangedHints.event;
		this.triggerOnType = false;
		this._state = ParameterHintState.Default;
		this._pendingTriggers = [];
		this._lastSignatureHelpResult = this._register(new MutableDisposable());
		this.triggerChars = new CharacterSet();
		this.retriggerChars = new CharacterSet();
		this.triggerId = 0;
		this.editor = editor$1;
		this.providers = providers;
		this.throttledDelayer = new Delayer(delay);
		this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
		this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
		this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
		this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
		this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
		this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
		this._register(this.providers.onDidChange(this.onModelChanged, this));
		this._register(this.editor.onDidType((text) => this.onDidType(text)));
		this.onEditorConfigurationChange();
		this.onModelChanged();
	}
	get state() {
		return this._state;
	}
	set state(value) {
		if (this._state.type === 2) this._state.request.cancel();
		this._state = value;
	}
	cancel(silent = false) {
		this.state = ParameterHintState.Default;
		this.throttledDelayer.cancel();
		if (!silent) this._onChangedHints.fire(void 0);
	}
	trigger(context, delay) {
		const model = this.editor.getModel();
		if (!model || !this.providers.has(model)) return;
		const triggerId = ++this.triggerId;
		this._pendingTriggers.push(context);
		this.throttledDelayer.trigger(() => {
			return this.doTrigger(triggerId);
		}, delay).catch(onUnexpectedError);
	}
	next() {
		if (this.state.type !== 1) return;
		const length = this.state.hints.signatures.length;
		const activeSignature = this.state.hints.activeSignature;
		const last = activeSignature % length === length - 1;
		const cycle = this.editor.getOption(78).cycle;
		if ((length < 2 || last) && !cycle) {
			this.cancel();
			return;
		}
		this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
	}
	previous() {
		if (this.state.type !== 1) return;
		const length = this.state.hints.signatures.length;
		const activeSignature = this.state.hints.activeSignature;
		const first$1 = activeSignature === 0;
		const cycle = this.editor.getOption(78).cycle;
		if ((length < 2 || first$1) && !cycle) {
			this.cancel();
			return;
		}
		this.updateActiveSignature(first$1 && cycle ? length - 1 : activeSignature - 1);
	}
	updateActiveSignature(activeSignature) {
		if (this.state.type !== 1) return;
		this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
		this._onChangedHints.fire(this.state.hints);
	}
	doTrigger(triggerId) {
		return __awaiter$10(this, void 0, void 0, function* () {
			const isRetrigger = this.state.type === 1 || this.state.type === 2;
			const activeSignatureHelp = this.getLastActiveHints();
			this.cancel(true);
			if (this._pendingTriggers.length === 0) return false;
			const context = this._pendingTriggers.reduce(mergeTriggerContexts);
			this._pendingTriggers = [];
			const triggerContext = {
				triggerKind: context.triggerKind,
				triggerCharacter: context.triggerCharacter,
				isRetrigger,
				activeSignatureHelp
			};
			if (!this.editor.hasModel()) return false;
			const model = this.editor.getModel();
			const position = this.editor.getPosition();
			this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
			try {
				const result = yield this.state.request;
				if (triggerId !== this.triggerId) {
					result === null || result === void 0 || result.dispose();
					return false;
				}
				if (!result || !result.value.signatures || result.value.signatures.length === 0) {
					result === null || result === void 0 || result.dispose();
					this._lastSignatureHelpResult.clear();
					this.cancel();
					return false;
				} else {
					this.state = new ParameterHintState.Active(result.value);
					this._lastSignatureHelpResult.value = result;
					this._onChangedHints.fire(this.state.hints);
					return true;
				}
			} catch (error) {
				if (triggerId === this.triggerId) this.state = ParameterHintState.Default;
				onUnexpectedError(error);
				return false;
			}
		});
	}
	getLastActiveHints() {
		switch (this.state.type) {
			case 1: return this.state.hints;
			case 2: return this.state.previouslyActiveHints;
			default: return;
		}
	}
	get isTriggered() {
		return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
	}
	onModelChanged() {
		this.cancel();
		this.triggerChars = new CharacterSet();
		this.retriggerChars = new CharacterSet();
		const model = this.editor.getModel();
		if (!model) return;
		for (const support of this.providers.ordered(model)) {
			for (const ch of support.signatureHelpTriggerCharacters || []) {
				this.triggerChars.add(ch.charCodeAt(0));
				this.retriggerChars.add(ch.charCodeAt(0));
			}
			for (const ch of support.signatureHelpRetriggerCharacters || []) this.retriggerChars.add(ch.charCodeAt(0));
		}
	}
	onDidType(text) {
		if (!this.triggerOnType) return;
		const lastCharIndex = text.length - 1;
		const triggerCharCode = text.charCodeAt(lastCharIndex);
		if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) this.trigger({
			triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
			triggerCharacter: text.charAt(lastCharIndex)
		});
	}
	onCursorChange(e) {
		if (e.source === "mouse") this.cancel();
		else if (this.isTriggered) this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
	}
	onModelContentChange() {
		if (this.isTriggered) this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
	}
	onEditorConfigurationChange() {
		this.triggerOnType = this.editor.getOption(78).enabled;
		if (!this.triggerOnType) this.cancel();
	}
	dispose() {
		this.cancel(true);
		super.dispose();
	}
};
ParameterHintsModel.DEFAULT_DELAY = 120;
function mergeTriggerContexts(previous, current) {
	switch (current.triggerKind) {
		case SignatureHelpTriggerKind.Invoke: return current;
		case SignatureHelpTriggerKind.ContentChange: return previous;
		case SignatureHelpTriggerKind.TriggerCharacter:
		default: return current;
	}
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js
var __decorate$21 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$21 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var $$1 = $;
var parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
var parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var ParameterHintsWidget = class ParameterHintsWidget$1 extends Disposable {
	constructor(editor$1, contextKeyService, openerService, languageService, languageFeaturesService) {
		super();
		this.editor = editor$1;
		this.renderDisposeables = this._register(new DisposableStore());
		this.visible = false;
		this.announcedLabel = null;
		this.allowEditorOverflow = true;
		this.markdownRenderer = this._register(new MarkdownRenderer({ editor: editor$1 }, languageService, openerService));
		this.model = this._register(new ParameterHintsModel(editor$1, languageFeaturesService.signatureHelpProvider));
		this.keyVisible = Context.Visible.bindTo(contextKeyService);
		this.keyMultipleSignatures = Context.MultipleSignatures.bindTo(contextKeyService);
		this._register(this.model.onChangedHints((newParameterHints) => {
			if (newParameterHints) {
				this.show();
				this.render(newParameterHints);
			} else this.hide();
		}));
	}
	createParameterHintDOMNodes() {
		const element = $$1(".editor-widget.parameter-hints-widget");
		const wrapper = append(element, $$1(".phwrapper"));
		wrapper.tabIndex = -1;
		const controls = append(wrapper, $$1(".controls"));
		const previous = append(controls, $$1(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
		const overloads = append(controls, $$1(".overloads"));
		const next = append(controls, $$1(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
		this._register(addDisposableListener(previous, "click", (e) => {
			EventHelper.stop(e);
			this.previous();
		}));
		this._register(addDisposableListener(next, "click", (e) => {
			EventHelper.stop(e);
			this.next();
		}));
		const body = $$1(".body");
		const scrollbar = new DomScrollableElement(body, { alwaysConsumeMouseWheel: true });
		this._register(scrollbar);
		wrapper.appendChild(scrollbar.getDomNode());
		const signature = append(body, $$1(".signature"));
		const docs = append(body, $$1(".docs"));
		element.style.userSelect = "text";
		this.domNodes = {
			element,
			signature,
			overloads,
			docs,
			scrollbar
		};
		this.editor.addContentWidget(this);
		this.hide();
		this._register(this.editor.onDidChangeCursorSelection((e) => {
			if (this.visible) this.editor.layoutContentWidget(this);
		}));
		const updateFont = () => {
			if (!this.domNodes) return;
			const fontInfo = this.editor.getOption(46);
			this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
			this.domNodes.element.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
		};
		updateFont();
		this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(46)).on(updateFont, null));
		this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
		this.updateMaxHeight();
	}
	show() {
		if (this.visible) return;
		if (!this.domNodes) this.createParameterHintDOMNodes();
		this.keyVisible.set(true);
		this.visible = true;
		setTimeout(() => {
			var _a$5;
			(_a$5 = this.domNodes) === null || _a$5 === void 0 || _a$5.element.classList.add("visible");
		}, 100);
		this.editor.layoutContentWidget(this);
	}
	hide() {
		var _a$5;
		this.renderDisposeables.clear();
		if (!this.visible) return;
		this.keyVisible.reset();
		this.visible = false;
		this.announcedLabel = null;
		(_a$5 = this.domNodes) === null || _a$5 === void 0 || _a$5.element.classList.remove("visible");
		this.editor.layoutContentWidget(this);
	}
	getPosition() {
		if (this.visible) return {
			position: this.editor.getPosition(),
			preference: [1, 2]
		};
		return null;
	}
	render(hints) {
		var _a$5;
		this.renderDisposeables.clear();
		if (!this.domNodes) return;
		const multiple = hints.signatures.length > 1;
		this.domNodes.element.classList.toggle("multiple", multiple);
		this.keyMultipleSignatures.set(multiple);
		this.domNodes.signature.innerText = "";
		this.domNodes.docs.innerText = "";
		const signature = hints.signatures[hints.activeSignature];
		if (!signature) return;
		const code = append(this.domNodes.signature, $$1(".code"));
		const fontInfo = this.editor.getOption(46);
		code.style.fontSize = `${fontInfo.fontSize}px`;
		code.style.fontFamily = fontInfo.fontFamily;
		const hasParameters = signature.parameters.length > 0;
		const activeParameterIndex = (_a$5 = signature.activeParameter) !== null && _a$5 !== void 0 ? _a$5 : hints.activeParameter;
		if (!hasParameters) {
			const label = append(code, $$1("span"));
			label.textContent = signature.label;
		} else this.renderParameters(code, signature, activeParameterIndex);
		const activeParameter = signature.parameters[activeParameterIndex];
		if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
			const documentation = $$1("span.documentation");
			if (typeof activeParameter.documentation === "string") documentation.textContent = activeParameter.documentation;
			else {
				const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
				documentation.appendChild(renderedContents.element);
			}
			append(this.domNodes.docs, $$1("p", {}, documentation));
		}
		if (signature.documentation === void 0) {} else if (typeof signature.documentation === "string") append(this.domNodes.docs, $$1("p", {}, signature.documentation));
		else {
			const renderedContents = this.renderMarkdownDocs(signature.documentation);
			append(this.domNodes.docs, renderedContents.element);
		}
		const hasDocs = this.hasDocs(signature, activeParameter);
		this.domNodes.signature.classList.toggle("has-docs", hasDocs);
		this.domNodes.docs.classList.toggle("empty", !hasDocs);
		this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
		if (activeParameter) {
			let labelToAnnounce = "";
			const param = signature.parameters[activeParameterIndex];
			if (Array.isArray(param.label)) labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
			else labelToAnnounce = param.label;
			if (param.documentation) labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
			if (signature.documentation) labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
			if (this.announcedLabel !== labelToAnnounce) {
				alert(localize("hint", "{0}, hint", labelToAnnounce));
				this.announcedLabel = labelToAnnounce;
			}
		}
		this.editor.layoutContentWidget(this);
		this.domNodes.scrollbar.scanDomNode();
	}
	renderMarkdownDocs(markdown) {
		const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, { asyncRenderCallback: () => {
			var _a$5;
			(_a$5 = this.domNodes) === null || _a$5 === void 0 || _a$5.scrollbar.scanDomNode();
		} }));
		renderedContents.element.classList.add("markdown-docs");
		return renderedContents;
	}
	hasDocs(signature, activeParameter) {
		if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) return true;
		if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) return true;
		if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) return true;
		if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) return true;
		return false;
	}
	renderParameters(parent, signature, activeParameterIndex) {
		const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
		const beforeSpan = document.createElement("span");
		beforeSpan.textContent = signature.label.substring(0, start);
		const paramSpan = document.createElement("span");
		paramSpan.textContent = signature.label.substring(start, end);
		paramSpan.className = "parameter active";
		const afterSpan = document.createElement("span");
		afterSpan.textContent = signature.label.substring(end);
		append(parent, beforeSpan, paramSpan, afterSpan);
	}
	getParameterLabelOffsets(signature, paramIdx) {
		const param = signature.parameters[paramIdx];
		if (!param) return [0, 0];
		else if (Array.isArray(param.label)) return param.label;
		else if (!param.label.length) return [0, 0];
		else {
			const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
			regex.test(signature.label);
			const idx = regex.lastIndex - param.label.length;
			return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
		}
	}
	next() {
		this.editor.focus();
		this.model.next();
	}
	previous() {
		this.editor.focus();
		this.model.previous();
	}
	cancel() {
		this.model.cancel();
	}
	getDomNode() {
		if (!this.domNodes) this.createParameterHintDOMNodes();
		return this.domNodes.element;
	}
	getId() {
		return ParameterHintsWidget$1.ID;
	}
	trigger(context) {
		this.model.trigger(context, 0);
	}
	updateMaxHeight() {
		if (!this.domNodes) return;
		const maxHeight = `${Math.max(this.editor.getLayoutInfo().height / 4, 250)}px`;
		this.domNodes.element.style.maxHeight = maxHeight;
		const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
		if (wrapper.length) wrapper[0].style.maxHeight = maxHeight;
	}
};
ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
ParameterHintsWidget = __decorate$21([
	__param$21(1, IContextKeyService),
	__param$21(2, IOpenerService),
	__param$21(3, ILanguageService),
	__param$21(4, ILanguageFeaturesService)
], ParameterHintsWidget);
const editorHoverWidgetHighlightForeground = registerColor("editorHoverWidget.highlightForeground", {
	dark: listHighlightForeground,
	light: listHighlightForeground,
	hcDark: listHighlightForeground,
	hcLight: listHighlightForeground
}, localize("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
registerThemingParticipant((theme, collector) => {
	const border = theme.getColor(editorHoverBorder);
	if (border) {
		const borderWidth = isHighContrast(theme.type) ? 2 : 1;
		collector.addRule(`.monaco-editor .parameter-hints-widget { border: ${borderWidth}px solid ${border}; }`);
		collector.addRule(`.monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid ${border.transparent(.5)}; }`);
		collector.addRule(`.monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid ${border.transparent(.5)}; }`);
	}
	const background = theme.getColor(editorHoverBackground);
	if (background) collector.addRule(`.monaco-editor .parameter-hints-widget { background-color: ${background}; }`);
	const link = theme.getColor(textLinkForeground);
	if (link) collector.addRule(`.monaco-editor .parameter-hints-widget a { color: ${link}; }`);
	const linkHover = theme.getColor(textLinkActiveForeground);
	if (linkHover) collector.addRule(`.monaco-editor .parameter-hints-widget a:hover { color: ${linkHover}; }`);
	const foreground$1 = theme.getColor(editorHoverForeground);
	if (foreground$1) collector.addRule(`.monaco-editor .parameter-hints-widget { color: ${foreground$1}; }`);
	const codeBackground = theme.getColor(textCodeBlockBackground);
	if (codeBackground) collector.addRule(`.monaco-editor .parameter-hints-widget code { background-color: ${codeBackground}; }`);
	const parameterHighlightColor = theme.getColor(editorHoverWidgetHighlightForeground);
	if (parameterHighlightColor) collector.addRule(`.monaco-editor .parameter-hints-widget .parameter.active { color: ${parameterHighlightColor}}`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
var __decorate$20 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$20 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var ParameterHintsController = class ParameterHintsController$1 extends Disposable {
	constructor(editor$1, instantiationService) {
		super();
		this.editor = editor$1;
		this.widget = this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor));
	}
	static get(editor$1) {
		return editor$1.getContribution(ParameterHintsController$1.ID);
	}
	cancel() {
		this.widget.cancel();
	}
	previous() {
		this.widget.previous();
	}
	next() {
		this.widget.next();
	}
	trigger(context) {
		this.widget.trigger(context);
	}
};
ParameterHintsController.ID = "editor.controller.parameterHints";
ParameterHintsController = __decorate$20([__param$20(1, IInstantiationService)], ParameterHintsController);
var TriggerParameterHintsAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.triggerParameterHints",
			label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
			alias: "Trigger Parameter Hints",
			precondition: EditorContextKeys.hasSignatureHelpProvider,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 3082,
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		const controller = ParameterHintsController.get(editor$1);
		if (controller) controller.trigger({ triggerKind: SignatureHelpTriggerKind.Invoke });
	}
};
registerEditorContribution(ParameterHintsController.ID, ParameterHintsController);
registerEditorAction(TriggerParameterHintsAction);
var weight = 175;
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
	id: "closeParameterHints",
	precondition: Context.Visible,
	handler: (x) => x.cancel(),
	kbOpts: {
		weight,
		kbExpr: EditorContextKeys.focus,
		primary: 9,
		secondary: [1033]
	}
}));
registerEditorCommand(new ParameterHintsCommand({
	id: "showPrevParameterHint",
	precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
	handler: (x) => x.previous(),
	kbOpts: {
		weight,
		kbExpr: EditorContextKeys.focus,
		primary: 16,
		secondary: [528],
		mac: {
			primary: 16,
			secondary: [528, 302]
		}
	}
}));
registerEditorCommand(new ParameterHintsCommand({
	id: "showNextParameterHint",
	precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSignatures),
	handler: (x) => x.next(),
	kbOpts: {
		weight,
		kbExpr: EditorContextKeys.focus,
		primary: 18,
		secondary: [530],
		mac: {
			primary: 18,
			secondary: [530, 300]
		}
	}
}));

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameInputField.js
var __decorate$19 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$19 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
const CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize("renameInputVisible", "Whether the rename input widget is visible"));
var RenameInputField = class RenameInputField$1 {
	constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
		this._editor = _editor;
		this._acceptKeybindings = _acceptKeybindings;
		this._themeService = _themeService;
		this._keybindingService = _keybindingService;
		this._disposables = new DisposableStore();
		this.allowEditorOverflow = true;
		this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
		this._editor.addContentWidget(this);
		this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(46)) this._updateFont();
		}));
		this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
	}
	dispose() {
		this._disposables.dispose();
		this._editor.removeContentWidget(this);
	}
	getId() {
		return "__renameInputWidget";
	}
	getDomNode() {
		if (!this._domNode) {
			this._domNode = document.createElement("div");
			this._domNode.className = "monaco-editor rename-box";
			this._input = document.createElement("input");
			this._input.className = "rename-input";
			this._input.type = "text";
			this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
			this._domNode.appendChild(this._input);
			this._label = document.createElement("div");
			this._label.className = "rename-label";
			this._domNode.appendChild(this._label);
			const updateLabel = () => {
				var _a$5, _b$1;
				const [accept, preview] = this._acceptKeybindings;
				this._keybindingService.lookupKeybinding(accept);
				this._label.innerText = localize({
					key: "label",
					comment: ["placeholders are keybindings, e.g \"F2 to Rename, Shift+F2 to Preview\""]
				}, "{0} to Rename, {1} to Preview", (_a$5 = this._keybindingService.lookupKeybinding(accept)) === null || _a$5 === void 0 ? void 0 : _a$5.getLabel(), (_b$1 = this._keybindingService.lookupKeybinding(preview)) === null || _b$1 === void 0 ? void 0 : _b$1.getLabel());
			};
			updateLabel();
			this._disposables.add(this._keybindingService.onDidUpdateKeybindings(updateLabel));
			this._updateFont();
			this._updateStyles(this._themeService.getColorTheme());
		}
		return this._domNode;
	}
	_updateStyles(theme) {
		var _a$5, _b$1, _c$1, _d$1;
		if (!this._input || !this._domNode) return;
		const widgetShadowColor = theme.getColor(widgetShadow);
		this._domNode.style.backgroundColor = String((_a$5 = theme.getColor(editorWidgetBackground)) !== null && _a$5 !== void 0 ? _a$5 : "");
		this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
		this._domNode.style.color = String((_b$1 = theme.getColor(inputForeground)) !== null && _b$1 !== void 0 ? _b$1 : "");
		this._input.style.backgroundColor = String((_c$1 = theme.getColor(inputBackground)) !== null && _c$1 !== void 0 ? _c$1 : "");
		const border = theme.getColor(inputBorder);
		this._input.style.borderWidth = border ? "1px" : "0px";
		this._input.style.borderStyle = border ? "solid" : "none";
		this._input.style.borderColor = (_d$1 = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d$1 !== void 0 ? _d$1 : "none";
	}
	_updateFont() {
		if (!this._input || !this._label) return;
		const fontInfo = this._editor.getOption(46);
		this._input.style.fontFamily = fontInfo.fontFamily;
		this._input.style.fontWeight = fontInfo.fontWeight;
		this._input.style.fontSize = `${fontInfo.fontSize}px`;
		this._label.style.fontSize = `${fontInfo.fontSize * .8}px`;
	}
	getPosition() {
		if (!this._visible) return null;
		return {
			position: this._position,
			preference: [2, 1]
		};
	}
	afterRender(position) {
		if (!position) this.cancelInput(true);
	}
	acceptInput(wantsPreview) {
		var _a$5;
		(_a$5 = this._currentAcceptInput) === null || _a$5 === void 0 || _a$5.call(this, wantsPreview);
	}
	cancelInput(focusEditor) {
		var _a$5;
		(_a$5 = this._currentCancelInput) === null || _a$5 === void 0 || _a$5.call(this, focusEditor);
	}
	getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
		this._domNode.classList.toggle("preview", supportPreview);
		this._position = new Position$1(where.startLineNumber, where.startColumn);
		this._input.value = value;
		this._input.setAttribute("selectionStart", selectionStart.toString());
		this._input.setAttribute("selectionEnd", selectionEnd.toString());
		this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
		const disposeOnDone = new DisposableStore();
		return new Promise((resolve) => {
			this._currentCancelInput = (focusEditor) => {
				this._currentAcceptInput = void 0;
				this._currentCancelInput = void 0;
				resolve(focusEditor);
				return true;
			};
			this._currentAcceptInput = (wantsPreview) => {
				if (this._input.value.trim().length === 0 || this._input.value === value) {
					this.cancelInput(true);
					return;
				}
				this._currentAcceptInput = void 0;
				this._currentCancelInput = void 0;
				resolve({
					newName: this._input.value,
					wantsPreview: supportPreview && wantsPreview
				});
			};
			disposeOnDone.add(token.onCancellationRequested(() => this.cancelInput(true)));
			disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(false)));
			this._show();
		}).finally(() => {
			disposeOnDone.dispose();
			this._hide();
		});
	}
	_show() {
		this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, 0);
		this._visible = true;
		this._visibleContextKey.set(true);
		this._editor.layoutContentWidget(this);
		setTimeout(() => {
			this._input.focus();
			this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
		}, 100);
	}
	_hide() {
		this._visible = false;
		this._visibleContextKey.reset();
		this._editor.layoutContentWidget(this);
	}
};
RenameInputField = __decorate$19([
	__param$19(2, IThemeService),
	__param$19(3, IKeybindingService),
	__param$19(4, IContextKeyService)
], RenameInputField);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
var __decorate$18 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$18 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$9 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var RenameSkeleton = class {
	constructor(model, position, registry) {
		this.model = model;
		this.position = position;
		this._providerRenameIdx = 0;
		this._providers = registry.ordered(model);
	}
	hasProvider() {
		return this._providers.length > 0;
	}
	resolveRenameLocation(token) {
		return __awaiter$9(this, void 0, void 0, function* () {
			const rejects = [];
			for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
				const provider = this._providers[this._providerRenameIdx];
				if (!provider.resolveRenameLocation) break;
				const res = yield provider.resolveRenameLocation(this.model, this.position, token);
				if (!res) continue;
				if (res.rejectReason) {
					rejects.push(res.rejectReason);
					continue;
				}
				return res;
			}
			const word = this.model.getWordAtPosition(this.position);
			if (!word) return {
				range: Range$1.fromPositions(this.position),
				text: "",
				rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
			};
			return {
				range: new Range$1(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
				text: word.word,
				rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
			};
		});
	}
	provideRenameEdits(newName, token) {
		return __awaiter$9(this, void 0, void 0, function* () {
			return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
		});
	}
	_provideRenameEdits(newName, i, rejects, token) {
		return __awaiter$9(this, void 0, void 0, function* () {
			const provider = this._providers[i];
			if (!provider) return {
				edits: [],
				rejectReason: rejects.join("\n")
			};
			const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
			if (!result) return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
			else if (result.rejectReason) return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
			return result;
		});
	}
};
function rename(registry, model, position, newName) {
	return __awaiter$9(this, void 0, void 0, function* () {
		const skeleton = new RenameSkeleton(model, position, registry);
		const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
		if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) return {
			edits: [],
			rejectReason: loc.rejectReason
		};
		return skeleton.provideRenameEdits(newName, CancellationToken.None);
	});
}
var RenameController = class RenameController$1 {
	constructor(editor$1, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService) {
		this.editor = editor$1;
		this._instaService = _instaService;
		this._notificationService = _notificationService;
		this._bulkEditService = _bulkEditService;
		this._progressService = _progressService;
		this._logService = _logService;
		this._configService = _configService;
		this._languageFeaturesService = _languageFeaturesService;
		this._disposableStore = new DisposableStore();
		this._cts = new CancellationTokenSource$1();
		this._renameInputField = this._disposableStore.add(new IdleValue(() => this._disposableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]))));
	}
	static get(editor$1) {
		return editor$1.getContribution(RenameController$1.ID);
	}
	dispose() {
		this._disposableStore.dispose();
		this._cts.dispose(true);
	}
	run() {
		var _a$5, _b$1;
		return __awaiter$9(this, void 0, void 0, function* () {
			this._cts.dispose(true);
			if (!this.editor.hasModel()) return;
			const position = this.editor.getPosition();
			const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
			if (!skeleton.hasProvider()) return;
			this._cts = new EditorStateCancellationTokenSource(this.editor, 5);
			let loc;
			try {
				const resolveLocationOperation = skeleton.resolveRenameLocation(this._cts.token);
				this._progressService.showWhile(resolveLocationOperation, 250);
				loc = yield resolveLocationOperation;
			} catch (e) {
				(_a$5 = MessageController.get(this.editor)) === null || _a$5 === void 0 || _a$5.showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
				return;
			}
			if (!loc) return;
			if (loc.rejectReason) {
				(_b$1 = MessageController.get(this.editor)) === null || _b$1 === void 0 || _b$1.showMessage(loc.rejectReason, position);
				return;
			}
			if (this._cts.token.isCancellationRequested) return;
			this._cts.dispose();
			this._cts = new EditorStateCancellationTokenSource(this.editor, 5, loc.range);
			const selection = this.editor.getSelection();
			let selectionStart = 0;
			let selectionEnd = loc.text.length;
			if (!Range$1.isEmpty(selection) && !Range$1.spansMultipleLines(selection) && Range$1.containsRange(loc.range, selection)) {
				selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
				selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
			}
			const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
			const inputFieldResult = yield this._renameInputField.value.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, this._cts.token);
			if (typeof inputFieldResult === "boolean") {
				if (inputFieldResult) this.editor.focus();
				return;
			}
			this.editor.focus();
			const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, this._cts.token), this._cts.token).then((renameResult) => __awaiter$9(this, void 0, void 0, function* () {
				if (!renameResult || !this.editor.hasModel()) return;
				if (renameResult.rejectReason) {
					this._notificationService.info(renameResult.rejectReason);
					return;
				}
				this.editor.setSelection(Range$1.fromPositions(this.editor.getSelection().getPosition()));
				this._bulkEditService.apply(ResourceEdit.convert(renameResult), {
					editor: this.editor,
					showPreview: inputFieldResult.wantsPreview,
					label: localize("label", "Renaming '{0}' to '{1}'", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
					code: "undoredo.rename",
					quotableLabel: localize("quotableLabel", "Renaming {0} to {1}", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
					respectAutoSaveConfig: true
				}).then((result) => {
					if (result.ariaSummary) alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
				}).catch((err) => {
					this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
					this._logService.error(err);
				});
			}), (err) => {
				this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
				this._logService.error(err);
			});
			this._progressService.showWhile(renameOperation, 250);
			return renameOperation;
		});
	}
	acceptRenameInput(wantsPreview) {
		this._renameInputField.value.acceptInput(wantsPreview);
	}
	cancelRenameInput() {
		this._renameInputField.value.cancelInput(true);
	}
};
RenameController.ID = "editor.contrib.renameController";
RenameController = __decorate$18([
	__param$18(1, IInstantiationService),
	__param$18(2, INotificationService),
	__param$18(3, IBulkEditService),
	__param$18(4, IEditorProgressService),
	__param$18(5, ILogService),
	__param$18(6, ITextResourceConfigurationService),
	__param$18(7, ILanguageFeaturesService)
], RenameController);
var RenameAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.rename",
			label: localize("rename.label", "Rename Symbol"),
			alias: "Rename Symbol",
			precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 60,
				weight: 100
			},
			contextMenuOpts: {
				group: "1_modification",
				order: 1.1
			}
		});
	}
	runCommand(accessor, args) {
		const editorService = accessor.get(ICodeEditorService);
		const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
		if (URI.isUri(uri) && Position$1.isIPosition(pos)) return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor$1) => {
			if (!editor$1) return;
			editor$1.setPosition(pos);
			editor$1.invokeWithinContext((accessor$1) => {
				this.reportTelemetry(accessor$1, editor$1);
				return this.run(accessor$1, editor$1);
			});
		}, onUnexpectedError);
		return super.runCommand(accessor, args);
	}
	run(accessor, editor$1) {
		const controller = RenameController.get(editor$1);
		if (controller) return controller.run();
		return Promise.resolve();
	}
};
registerEditorContribution(RenameController.ID, RenameController);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
	id: "acceptRenameInput",
	precondition: CONTEXT_RENAME_INPUT_VISIBLE,
	handler: (x) => x.acceptRenameInput(false),
	kbOpts: {
		weight: 199,
		kbExpr: EditorContextKeys.focus,
		primary: 3
	}
}));
registerEditorCommand(new RenameCommand({
	id: "acceptRenameInputWithPreview",
	precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
	handler: (x) => x.acceptRenameInput(true),
	kbOpts: {
		weight: 199,
		kbExpr: EditorContextKeys.focus,
		primary: 1027
	}
}));
registerEditorCommand(new RenameCommand({
	id: "cancelRenameInput",
	precondition: CONTEXT_RENAME_INPUT_VISIBLE,
	handler: (x) => x.cancelRenameInput(),
	kbOpts: {
		weight: 199,
		kbExpr: EditorContextKeys.focus,
		primary: 9,
		secondary: [1033]
	}
}));
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(accessor, model, position, ...args) {
	const [newName] = args;
	assertType(typeof newName === "string");
	const { renameProvider } = accessor.get(ILanguageFeaturesService);
	return rename(renameProvider, model, position, newName);
});
registerModelAndPositionCommand("_executePrepareRename", function(accessor, model, position) {
	return __awaiter$9(this, void 0, void 0, function* () {
		const { renameProvider } = accessor.get(ILanguageFeaturesService);
		const loc = yield new RenameSkeleton(model, position, renameProvider).resolveRenameLocation(CancellationToken.None);
		if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) throw new Error(loc.rejectReason);
		return loc;
	});
});
Registry.as(Extensions$1.Configuration).registerConfiguration({
	id: "editor",
	properties: { "editor.rename.enablePreview": {
		scope: 5,
		description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
		default: true,
		type: "boolean"
	} }
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScroll.js
var __decorate$17 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$17 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$8 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var _a;
var StickyScrollController = class StickyScrollController$1 extends Disposable {
	constructor(editor$1, _languageFeaturesService) {
		super();
		this._sessionStore = new DisposableStore();
		this._ranges = [];
		this._rangesVersionId = 0;
		this._editor = editor$1;
		this._languageFeaturesService = _languageFeaturesService;
		this.stickyScrollWidget = new StickyScrollWidget(this._editor);
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(34)) this.onConfigurationChange();
		}));
		this._updateSoon = this._register(new RunOnceScheduler(() => this._update(true), 50));
		this.onConfigurationChange();
	}
	onConfigurationChange() {
		if (this._editor.getOption(34).stickyScroll.enabled === false) {
			this.stickyScrollWidget.emptyRootNode();
			this._editor.removeOverlayWidget(this.stickyScrollWidget);
			this._sessionStore.clear();
			return;
		} else {
			this._editor.addOverlayWidget(this.stickyScrollWidget);
			this._sessionStore.add(this._editor.onDidChangeModel(() => this._update(true)));
			this._sessionStore.add(this._editor.onDidScrollChange(() => this._update(false)));
			this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this._update(true)));
			this._sessionStore.add(this._editor.onDidChangeModelTokens((e) => this._onTokensChange(e)));
			this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));
			this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => this._update(true)));
			this._update(true);
		}
	}
	_needsUpdate(event) {
		const stickyLineNumbers = this.stickyScrollWidget.getCurrentLines();
		for (const stickyLineNumber of stickyLineNumbers) for (const range of event.ranges) if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) return true;
		return false;
	}
	_onTokensChange(event) {
		if (this._needsUpdate(event)) this._update(false);
	}
	_update(updateOutline = false) {
		var _a$5, _b$1;
		return __awaiter$8(this, void 0, void 0, function* () {
			if (updateOutline) {
				(_a$5 = this._cts) === null || _a$5 === void 0 || _a$5.dispose(true);
				this._cts = new CancellationTokenSource$1();
				yield this._updateOutlineModel(this._cts.token);
			}
			const hiddenRanges = (_b$1 = this._editor._getViewModel()) === null || _b$1 === void 0 ? void 0 : _b$1.getHiddenAreas();
			if (hiddenRanges) for (const hiddenRange of hiddenRanges) this._ranges = this._ranges.filter((range) => {
				return !(range[0] >= hiddenRange.startLineNumber && range[1] <= hiddenRange.endLineNumber + 1);
			});
			this._renderStickyScroll();
		});
	}
	_findLineRanges(outlineElement, depth) {
		if (outlineElement === null || outlineElement === void 0 ? void 0 : outlineElement.children.size) {
			let didRecursion = false;
			for (const outline of outlineElement === null || outlineElement === void 0 ? void 0 : outlineElement.children.values()) {
				const kind = outline.symbol.kind;
				if (kind === 4 || kind === 8 || kind === 11 || kind === 10 || kind === 5 || kind === 1) {
					didRecursion = true;
					this._findLineRanges(outline, depth + 1);
				}
			}
			if (!didRecursion) this._addOutlineRanges(outlineElement, depth);
		} else this._addOutlineRanges(outlineElement, depth);
	}
	_addOutlineRanges(outlineElement, depth) {
		let currentStartLine = 0;
		let currentEndLine = 0;
		while (outlineElement) {
			const kind = outlineElement.symbol.kind;
			if (kind === 4 || kind === 8 || kind === 11 || kind === 10 || kind === 5 || kind === 1) {
				currentStartLine = outlineElement === null || outlineElement === void 0 ? void 0 : outlineElement.symbol.range.startLineNumber;
				currentEndLine = outlineElement === null || outlineElement === void 0 ? void 0 : outlineElement.symbol.range.endLineNumber;
				this._ranges.push([
					currentStartLine,
					currentEndLine,
					depth
				]);
				depth--;
			}
			if (outlineElement.parent instanceof OutlineElement) outlineElement = outlineElement.parent;
			else break;
		}
	}
	_updateOutlineModel(token) {
		return __awaiter$8(this, void 0, void 0, function* () {
			if (this._editor.hasModel()) {
				const model = this._editor.getModel();
				const modelVersionId = model.getVersionId();
				const outlineModel = yield OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, model, token);
				if (token.isCancellationRequested) return;
				this._ranges = [];
				this._rangesVersionId = modelVersionId;
				for (const outline of outlineModel.children.values()) {
					if (outline instanceof OutlineElement) {
						const kind = outline.symbol.kind;
						if (kind === 4 || kind === 8 || kind === 11 || kind === 10 || kind === 5 || kind === 1) this._findLineRanges(outline, 1);
						else this._findLineRanges(outline, 0);
					}
					this._ranges = this._ranges.sort(function(a, b) {
						if (a[0] !== b[0]) return a[0] - b[0];
						else if (a[1] !== b[1]) return b[1] - a[1];
						else return a[2] - b[2];
					});
					let previous = [];
					for (const [index, arr] of this._ranges.entries()) {
						const [start, end, _depth] = arr;
						if (previous[0] === start && previous[1] === end) this._ranges.splice(index, 1);
						else previous = arr;
					}
				}
			}
		});
	}
	_renderStickyScroll() {
		if (!this._editor.hasModel()) return;
		const lineHeight = this._editor.getOption(61);
		const model = this._editor.getModel();
		if (this._rangesVersionId !== model.getVersionId()) return;
		const scrollTop = this._editor.getScrollTop();
		this.stickyScrollWidget.emptyRootNode();
		const beginningLinesConsidered = /* @__PURE__ */ new Set();
		for (const [index, arr] of this._ranges.entries()) {
			const [start, end, depth] = arr;
			if (end - start > 0 && model.getLineContent(start) !== "") {
				const topOfElementAtDepth = (depth - 1) * lineHeight;
				const bottomOfElementAtDepth = depth * lineHeight;
				const bottomOfBeginningLine = this._editor.getBottomForLineNumber(start) - scrollTop;
				const topOfEndLine = this._editor.getTopForLineNumber(end) - scrollTop;
				const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;
				if (!beginningLinesConsidered.has(start)) {
					if (topOfElementAtDepth >= topOfEndLine - 1 && topOfElementAtDepth < bottomOfEndLine - 2) {
						beginningLinesConsidered.add(start);
						this.stickyScrollWidget.pushCodeLine(new StickyScrollCodeLine(start, depth, this._editor, -1, bottomOfEndLine - bottomOfElementAtDepth));
						break;
					} else if (bottomOfElementAtDepth > bottomOfBeginningLine && bottomOfElementAtDepth < bottomOfEndLine - 1) {
						beginningLinesConsidered.add(start);
						this.stickyScrollWidget.pushCodeLine(new StickyScrollCodeLine(start, depth, this._editor, 0, 0));
					}
				} else this._ranges.splice(index, 1);
			}
		}
		this.stickyScrollWidget.updateRootNode();
	}
	dispose() {
		super.dispose();
		this._sessionStore.dispose();
	}
};
StickyScrollController.ID = "store.contrib.stickyScrollController";
StickyScrollController = __decorate$17([__param$17(1, ILanguageFeaturesService)], StickyScrollController);
var _ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy("stickyScrollViewLayer", { createHTML: (value) => value });
var StickyScrollCodeLine = class {
	constructor(_lineNumber, _depth, _editor, _zIndex, _relativePosition) {
		this._lineNumber = _lineNumber;
		this._depth = _depth;
		this._editor = _editor;
		this._zIndex = _zIndex;
		this._relativePosition = _relativePosition;
		this.effectiveLineHeight = 0;
		this.effectiveLineHeight = this._editor.getOption(61) + this._relativePosition;
	}
	get lineNumber() {
		return this._lineNumber;
	}
	getDomNode() {
		const root = document.createElement("div");
		const viewModel = this._editor._getViewModel();
		const viewLineNumber = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position$1(this._lineNumber, 1)).lineNumber;
		const lineRenderingData = viewModel.getViewLineRenderingData(viewLineNumber);
		let actualInlineDecorations;
		try {
			actualInlineDecorations = LineDecoration.filter(lineRenderingData.inlineDecorations, viewLineNumber, lineRenderingData.minColumn, lineRenderingData.maxColumn);
		} catch (err) {
			actualInlineDecorations = [];
		}
		const renderLineInput = new RenderLineInput(true, true, lineRenderingData.content, lineRenderingData.continuesWithWrappedLine, lineRenderingData.isBasicASCII, lineRenderingData.containsRTL, 0, lineRenderingData.tokens, actualInlineDecorations, lineRenderingData.tabSize, lineRenderingData.startVisibleColumn, 1, 1, 1, 100, "none", true, true, null);
		const sb = createStringBuilder(400);
		renderViewLine(renderLineInput, sb);
		let newLine;
		if (_ttPolicy) newLine = _ttPolicy.createHTML(sb.build());
		else newLine = sb.build();
		const lineHTMLNode = document.createElement("span");
		lineHTMLNode.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
		lineHTMLNode.style.overflow = "hidden";
		lineHTMLNode.style.whiteSpace = "nowrap";
		lineHTMLNode.style.display = "inline-block";
		lineHTMLNode.style.lineHeight = this._editor.getOption(61).toString() + "px";
		lineHTMLNode.innerHTML = newLine;
		const lineNumberHTMLNode = document.createElement("span");
		lineNumberHTMLNode.style.width = this._editor.getLayoutInfo().contentLeft.toString() + "px";
		lineNumberHTMLNode.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
		lineNumberHTMLNode.style.color = "var(--vscode-editorLineNumber-foreground)";
		lineNumberHTMLNode.style.display = "inline-block";
		lineNumberHTMLNode.style.lineHeight = this._editor.getOption(61).toString() + "px";
		const innerLineNumberHTML = document.createElement("span");
		innerLineNumberHTML.innerText = this._lineNumber.toString();
		innerLineNumberHTML.style.paddingLeft = this._editor.getLayoutInfo().lineNumbersLeft.toString() + "px";
		innerLineNumberHTML.style.width = this._editor.getLayoutInfo().lineNumbersWidth.toString() + "px";
		innerLineNumberHTML.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
		innerLineNumberHTML.style.textAlign = "right";
		innerLineNumberHTML.style.float = "left";
		innerLineNumberHTML.style.lineHeight = this._editor.getOption(61).toString() + "px";
		lineNumberHTMLNode.appendChild(innerLineNumberHTML);
		root.onclick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			this._editor.revealPosition({
				lineNumber: this._lineNumber - this._depth + 1,
				column: 1
			});
		};
		root.onmouseover = (e) => {
			innerLineNumberHTML.style.background = `var(--vscode-editorStickyScrollHover-background)`;
			lineHTMLNode.style.backgroundColor = `var(--vscode-editorStickyScrollHover-background)`;
			lineNumberHTMLNode.style.backgroundColor = `var(--vscode-editorStickyScrollHover-background)`;
			root.style.backgroundColor = `var(--vscode-editorStickyScrollHover-background)`;
			innerLineNumberHTML.style.cursor = `pointer`;
			lineHTMLNode.style.cursor = `pointer`;
			root.style.cursor = `pointer`;
			lineNumberHTMLNode.style.cursor = `pointer`;
		};
		root.onmouseleave = (e) => {
			innerLineNumberHTML.style.background = `var(--vscode-editorStickyScroll-background)`;
			lineHTMLNode.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
			lineNumberHTMLNode.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
			root.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
		};
		this._editor.applyFontInfo(lineHTMLNode);
		this._editor.applyFontInfo(innerLineNumberHTML);
		root.appendChild(lineNumberHTMLNode);
		root.appendChild(lineHTMLNode);
		root.style.zIndex = this._zIndex.toString();
		root.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
		root.style.overflow = "hidden";
		root.style.whiteSpace = "nowrap";
		root.style.width = "100%";
		root.style.lineHeight = this._editor.getOption(61).toString() + "px";
		root.style.height = this._editor.getOption(61).toString() + "px";
		if (this._relativePosition) {
			root.style.position = "relative";
			root.style.top = this._relativePosition + "px";
			root.style.width = "100%";
		}
		return root;
	}
};
var StickyScrollWidget = class {
	constructor(_editor) {
		this._editor = _editor;
		this.arrayOfCodeLines = [];
		this.rootDomNode = document.createElement("div");
		this.rootDomNode = document.createElement("div");
		this.rootDomNode.style.width = "100%";
		this.rootDomNode.style.boxShadow = `var(--vscode-scrollbar-shadow) 0 6px 6px -6px`;
	}
	getCurrentLines() {
		const widgetLineRange = [];
		for (const codeLine of this.arrayOfCodeLines) widgetLineRange.push(codeLine.lineNumber);
		return widgetLineRange;
	}
	pushCodeLine(codeLine) {
		this.arrayOfCodeLines.push(codeLine);
	}
	updateRootNode() {
		let widgetHeight = 0;
		for (const line of this.arrayOfCodeLines) {
			widgetHeight += line.effectiveLineHeight;
			this.rootDomNode.appendChild(line.getDomNode());
		}
		this.rootDomNode.style.height = widgetHeight.toString() + "px";
	}
	emptyRootNode() {
		this.arrayOfCodeLines.length = 0;
		clearNode(this.rootDomNode);
	}
	getId() {
		return "editor.contrib.stickyScrollWidget";
	}
	getDomNode() {
		this.rootDomNode.style.zIndex = "2";
		this.rootDomNode.style.backgroundColor = `var(--vscode-editorStickyScroll-background)`;
		return this.rootDomNode;
	}
	getPosition() {
		return { preference: null };
	}
};
registerEditorContribution(StickyScrollController.ID, StickyScrollController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/wordSelections.js
var WordSelectionRangeProvider = class {
	provideSelectionRanges(model, positions) {
		const result = [];
		for (const position of positions) {
			const bucket = [];
			result.push(bucket);
			this._addInWordRanges(bucket, model, position);
			this._addWordRanges(bucket, model, position);
			this._addWhitespaceLine(bucket, model, position);
			bucket.push({ range: model.getFullModelRange() });
		}
		return result;
	}
	_addInWordRanges(bucket, model, pos) {
		const obj = model.getWordAtPosition(pos);
		if (!obj) return;
		const { word, startColumn } = obj;
		const offset = pos.column - startColumn;
		let start = offset;
		let end = offset;
		let lastCh = 0;
		for (; start >= 0; start--) {
			const ch = word.charCodeAt(start);
			if (start !== offset && (ch === 95 || ch === 45)) break;
			else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) break;
			lastCh = ch;
		}
		start += 1;
		for (; end < word.length; end++) {
			const ch = word.charCodeAt(end);
			if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) break;
			else if (ch === 95 || ch === 45) break;
			lastCh = ch;
		}
		if (start < end) bucket.push({ range: new Range$1(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
	}
	_addWordRanges(bucket, model, pos) {
		const word = model.getWordAtPosition(pos);
		if (word) bucket.push({ range: new Range$1(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
	}
	_addWhitespaceLine(bucket, model, pos) {
		if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) bucket.push({ range: new Range$1(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
var __decorate$16 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$16 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$7 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var SelectionRanges = class SelectionRanges {
	constructor(index, ranges) {
		this.index = index;
		this.ranges = ranges;
	}
	mov(fwd) {
		const index = this.index + (fwd ? 1 : -1);
		if (index < 0 || index >= this.ranges.length) return this;
		const res = new SelectionRanges(index, this.ranges);
		if (res.ranges[index].equalsRange(this.ranges[this.index])) return res.mov(fwd);
		return res;
	}
};
var SmartSelectController = class SmartSelectController$1 {
	constructor(_editor, _languageFeaturesService) {
		this._editor = _editor;
		this._languageFeaturesService = _languageFeaturesService;
		this._ignoreSelection = false;
	}
	static get(editor$1) {
		return editor$1.getContribution(SmartSelectController$1.ID);
	}
	dispose() {
		var _a$5;
		(_a$5 = this._selectionListener) === null || _a$5 === void 0 || _a$5.dispose();
	}
	run(forward) {
		return __awaiter$7(this, void 0, void 0, function* () {
			if (!this._editor.hasModel()) return;
			const selections = this._editor.getSelections();
			const model = this._editor.getModel();
			if (!this._state) yield provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map((s) => s.getPosition()), this._editor.getOption(104), CancellationToken.None).then((ranges) => {
				var _a$5;
				if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) return;
				if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) return;
				for (let i = 0; i < ranges.length; i++) {
					ranges[i] = ranges[i].filter((range) => {
						return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
					});
					ranges[i].unshift(selections[i]);
				}
				this._state = ranges.map((ranges$1) => new SelectionRanges(0, ranges$1));
				(_a$5 = this._selectionListener) === null || _a$5 === void 0 || _a$5.dispose();
				this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
					var _a$6;
					if (!this._ignoreSelection) {
						(_a$6 = this._selectionListener) === null || _a$6 === void 0 || _a$6.dispose();
						this._state = void 0;
					}
				});
			});
			if (!this._state) return;
			this._state = this._state.map((state) => state.mov(forward));
			const newSelections = this._state.map((state) => Selection$1.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
			this._ignoreSelection = true;
			try {
				this._editor.setSelections(newSelections);
			} finally {
				this._ignoreSelection = false;
			}
		});
	}
};
SmartSelectController.ID = "editor.contrib.smartSelectController";
SmartSelectController = __decorate$16([__param$16(1, ILanguageFeaturesService)], SmartSelectController);
var AbstractSmartSelect = class extends EditorAction {
	constructor(forward, opts) {
		super(opts);
		this._forward = forward;
	}
	run(_accessor, editor$1) {
		return __awaiter$7(this, void 0, void 0, function* () {
			const controller = SmartSelectController.get(editor$1);
			if (controller) yield controller.run(this._forward);
		});
	}
};
var GrowSelectionAction = class extends AbstractSmartSelect {
	constructor() {
		super(true, {
			id: "editor.action.smartSelect.expand",
			label: localize("smartSelect.expand", "Expand Selection"),
			alias: "Expand Selection",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1553,
				mac: {
					primary: 3345,
					secondary: [1297]
				},
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "1_basic",
				title: localize({
					key: "miSmartSelectGrow",
					comment: ["&& denotes a mnemonic"]
				}, "&&Expand Selection"),
				order: 2
			}
		});
	}
};
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
var ShrinkSelectionAction = class extends AbstractSmartSelect {
	constructor() {
		super(false, {
			id: "editor.action.smartSelect.shrink",
			label: localize("smartSelect.shrink", "Shrink Selection"),
			alias: "Shrink Selection",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1551,
				mac: {
					primary: 3343,
					secondary: [1295]
				},
				weight: 100
			},
			menuOpts: {
				menuId: MenuId.MenubarSelectionMenu,
				group: "1_basic",
				title: localize({
					key: "miSmartSelectShrink",
					comment: ["&& denotes a mnemonic"]
				}, "&&Shrink Selection"),
				order: 3
			}
		});
	}
};
registerEditorContribution(SmartSelectController.ID, SmartSelectController);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
function provideSelectionRanges(registry, model, positions, options, token) {
	return __awaiter$7(this, void 0, void 0, function* () {
		const providers = registry.all(model).concat(new WordSelectionRangeProvider());
		if (providers.length === 1) providers.unshift(new BracketSelectionRangeProvider());
		const work = [];
		const allRawRanges = [];
		for (const provider of providers) work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
			if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) for (let i = 0; i < positions.length; i++) {
				if (!allRawRanges[i]) allRawRanges[i] = [];
				for (const oneProviderRanges of allProviderRanges[i]) if (Range$1.isIRange(oneProviderRanges.range) && Range$1.containsPosition(oneProviderRanges.range, positions[i])) allRawRanges[i].push(Range$1.lift(oneProviderRanges.range));
			}
		}, onUnexpectedExternalError));
		yield Promise.all(work);
		return allRawRanges.map((oneRawRanges) => {
			if (oneRawRanges.length === 0) return [];
			oneRawRanges.sort((a, b) => {
				if (Position$1.isBefore(a.getStartPosition(), b.getStartPosition())) return 1;
				else if (Position$1.isBefore(b.getStartPosition(), a.getStartPosition())) return -1;
				else if (Position$1.isBefore(a.getEndPosition(), b.getEndPosition())) return -1;
				else if (Position$1.isBefore(b.getEndPosition(), a.getEndPosition())) return 1;
				else return 0;
			});
			const oneRanges = [];
			let last;
			for (const range of oneRawRanges) if (!last || Range$1.containsRange(range, last) && !Range$1.equalsRange(range, last)) {
				oneRanges.push(range);
				last = range;
			}
			if (!options.selectLeadingAndTrailingWhitespace) return oneRanges;
			const oneRangesWithTrivia = [oneRanges[0]];
			for (let i = 1; i < oneRanges.length; i++) {
				const prev = oneRanges[i - 1];
				const cur = oneRanges[i];
				if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
					const rangeNoWhitespace = new Range$1(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
					if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) oneRangesWithTrivia.push(rangeNoWhitespace);
					const rangeFull = new Range$1(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
					if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) oneRangesWithTrivia.push(rangeFull);
				}
				oneRangesWithTrivia.push(cur);
			}
			return oneRangesWithTrivia;
		});
	});
}
CommandsRegistry.registerCommand("_executeSelectionRangeProvider", function(accessor, ...args) {
	return __awaiter$7(this, void 0, void 0, function* () {
		const [resource, positions] = args;
		assertType(URI.isUri(resource));
		const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
		const reference = yield accessor.get(ITextModelService).createModelReference(resource);
		try {
			return provideSelectionRanges(registry, reference.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true }, CancellationToken.None);
		} finally {
			reference.dispose();
		}
	});
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js
var __decorate$15 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$15 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$6 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var SuggestInlineCompletion = class {
	constructor(range, insertText, filterText, additionalTextEdits, command, completion) {
		this.range = range;
		this.insertText = insertText;
		this.filterText = filterText;
		this.additionalTextEdits = additionalTextEdits;
		this.command = command;
		this.completion = completion;
	}
};
var InlineCompletionResults = class InlineCompletionResults$1 extends RefCountedDisposable {
	constructor(model, line, word, completionModel, completions, _suggestMemoryService) {
		super(completions.disposable);
		this.model = model;
		this.line = line;
		this.word = word;
		this.completionModel = completionModel;
		this._suggestMemoryService = _suggestMemoryService;
	}
	canBeReused(model, line, word) {
		return this.model === model && this.line === line && this.word.word.length > 0 && this.word.startColumn === word.startColumn && this.word.endColumn < word.endColumn && this.completionModel.incomplete.size === 0;
	}
	get items() {
		var _a$5;
		const result = [];
		const { items } = this.completionModel;
		const selectedIndex = this._suggestMemoryService.select(this.model, {
			lineNumber: this.line,
			column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta
		}, items);
		const first$1 = Iterable.slice(items, selectedIndex);
		const second = Iterable.slice(items, 0, selectedIndex);
		let resolveCount = 5;
		for (const item of Iterable.concat(first$1, second)) {
			if (item.score === FuzzyScore.Default) continue;
			const range = new Range$1(item.editStart.lineNumber, item.editStart.column, item.editInsertEnd.lineNumber, item.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta);
			const insertText = item.completion.insertTextRules && item.completion.insertTextRules & CompletionItemInsertTextRule.InsertAsSnippet ? { snippet: item.completion.insertText } : item.completion.insertText;
			result.push(new SuggestInlineCompletion(range, insertText, (_a$5 = item.filterTextLow) !== null && _a$5 !== void 0 ? _a$5 : item.labelLow, item.completion.additionalTextEdits, item.completion.command, item));
			if (resolveCount-- >= 0) item.resolve(CancellationToken.None);
		}
		return result;
	}
};
InlineCompletionResults = __decorate$15([__param$15(5, ISuggestMemoryService)], InlineCompletionResults);
var SuggestInlineCompletions = class SuggestInlineCompletions$1 {
	constructor(_getEditorOption, _languageFeatureService, _clipboardService, _suggestMemoryService) {
		this._getEditorOption = _getEditorOption;
		this._languageFeatureService = _languageFeatureService;
		this._clipboardService = _clipboardService;
		this._suggestMemoryService = _suggestMemoryService;
	}
	provideInlineCompletions(model, position, context, token) {
		var _a$5;
		return __awaiter$6(this, void 0, void 0, function* () {
			if (context.selectedSuggestionInfo) return;
			const config = this._getEditorOption(81, model);
			if (QuickSuggestionsOptions.isAllOff(config)) return;
			model.tokenization.tokenizeIfCheap(position.lineNumber);
			const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
			const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
			if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "inline") return;
			let wordInfo = model.getWordAtPosition(position);
			let triggerCharacterInfo;
			if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word)) triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
			if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word) && !triggerCharacterInfo) return;
			if (!wordInfo) wordInfo = model.getWordUntilPosition(position);
			if (wordInfo.endColumn !== position.column) return;
			let result;
			const leadingLineContents = model.getValueInRange(new Range$1(position.lineNumber, 1, position.lineNumber, position.column));
			if (!triggerCharacterInfo && ((_a$5 = this._lastResult) === null || _a$5 === void 0 ? void 0 : _a$5.canBeReused(model, position.lineNumber, wordInfo))) {
				const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
				this._lastResult.completionModel.lineContext = newLineContext;
				this._lastResult.acquire();
				result = this._lastResult;
			} else {
				const completions = yield provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(void 0, void 0, triggerCharacterInfo === null || triggerCharacterInfo === void 0 ? void 0 : triggerCharacterInfo.providers), triggerCharacterInfo && {
					triggerKind: 1,
					triggerCharacter: triggerCharacterInfo.ch
				}, token);
				let clipboardText;
				if (completions.needsClipboard) clipboardText = yield this._clipboardService.readText();
				const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, this._getEditorOption(108, model), this._getEditorOption(103, model), {
					boostFullMatch: false,
					firstMatchCanBeWeak: false
				}, clipboardText);
				result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
			}
			this._lastResult = result;
			return result;
		});
	}
	handleItemDidShow(_completions, item) {
		item.completion.resolve(CancellationToken.None);
	}
	freeInlineCompletions(result) {
		result.release();
	}
	_getTriggerCharacterInfo(model, position) {
		var _a$5;
		const ch = model.getValueInRange(Range$1.fromPositions({
			lineNumber: position.lineNumber,
			column: position.column - 1
		}, position));
		const providers = /* @__PURE__ */ new Set();
		for (const provider of this._languageFeatureService.completionProvider.all(model)) if ((_a$5 = provider.triggerCharacters) === null || _a$5 === void 0 ? void 0 : _a$5.includes(ch)) providers.add(provider);
		if (providers.size === 0) return;
		return {
			providers,
			ch
		};
	}
};
SuggestInlineCompletions = __decorate$15([
	__param$15(1, ILanguageFeaturesService),
	__param$15(2, IClipboardService),
	__param$15(3, ISuggestMemoryService)
], SuggestInlineCompletions);
var EditorContribution = class EditorContribution$1 {
	constructor(_editor, languageFeatureService, editorService, instaService) {
		if (++EditorContribution$1._counter === 1) {
			const provider = instaService.createInstance(SuggestInlineCompletions, (id, model) => {
				var _a$5;
				return ((_a$5 = editorService.listCodeEditors().find((editor$1) => editor$1.getModel() === model)) !== null && _a$5 !== void 0 ? _a$5 : _editor).getOption(id);
			});
			EditorContribution$1._disposable = languageFeatureService.inlineCompletionsProvider.register("*", provider);
		}
	}
	dispose() {
		var _a$5;
		if (--EditorContribution$1._counter === 0) {
			(_a$5 = EditorContribution$1._disposable) === null || _a$5 === void 0 || _a$5.dispose();
			EditorContribution$1._disposable = void 0;
		}
	}
};
EditorContribution._counter = 0;
EditorContribution = __decorate$15([
	__param$15(1, ILanguageFeaturesService),
	__param$15(2, ICodeEditorService),
	__param$15(3, IInstantiationService)
], EditorContribution);
registerEditorContribution("suggest.inlineCompletionsProvider", EditorContribution);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/browser/tokenization.js
var ForceRetokenizeAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.forceRetokenize",
			label: localize("forceRetokenize", "Developer: Force Retokenize"),
			alias: "Developer: Force Retokenize",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		if (!editor$1.hasModel()) return;
		const model = editor$1.getModel();
		model.tokenization.resetTokenization();
		const sw = new StopWatch(true);
		model.tokenization.forceTokenization(model.getLineCount());
		sw.stop();
		console.log(`tokenization took ${sw.elapsed()}`);
	}
};
registerEditorAction(ForceRetokenizeAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js
var ToggleTabFocusModeAction = class ToggleTabFocusModeAction extends EditorAction {
	constructor() {
		super({
			id: ToggleTabFocusModeAction.ID,
			label: localize({
				key: "toggle.tabMovesFocus",
				comment: ["Turn on/off use of tab key for moving focus around VS Code"]
			}, "Toggle Tab Key Moves Focus"),
			alias: "Toggle Tab Key Moves Focus",
			precondition: void 0,
			kbOpts: {
				kbExpr: null,
				primary: 2091,
				mac: { primary: 1323 },
				weight: 100
			}
		});
	}
	run(accessor, editor$1) {
		const newValue = !TabFocus.getTabFocusMode();
		TabFocus.setTabFocusMode(newValue);
		if (newValue) alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
		else alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
	}
};
ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
registerEditorAction(ToggleTabFocusModeAction);

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/opener/browser/link.js
var __decorate$14 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$14 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var Link = class Link$2 extends Disposable {
	constructor(container, _link, options = {}, openerService) {
		var _a$5;
		super();
		this._link = _link;
		this._enabled = true;
		this.el = append(container, $("a.monaco-link", {
			tabIndex: (_a$5 = _link.tabIndex) !== null && _a$5 !== void 0 ? _a$5 : 0,
			href: _link.href,
			title: _link.title
		}, _link.label));
		this.el.setAttribute("role", "button");
		const onClickEmitter = this._register(new DomEmitter(this.el, "click"));
		const onKeyPress = this._register(new DomEmitter(this.el, "keypress"));
		const onEnterPress = Event.chain(onKeyPress.event).map((e) => new StandardKeyboardEvent(e)).filter((e) => e.keyCode === 3).event;
		const onTap = this._register(new DomEmitter(this.el, EventType.Tap)).event;
		this._register(Gesture.addTarget(this.el));
		const onOpen = Event.any(onClickEmitter.event, onEnterPress, onTap);
		this._register(onOpen((e) => {
			if (!this.enabled) return;
			EventHelper.stop(e, true);
			if (options === null || options === void 0 ? void 0 : options.opener) options.opener(this._link.href);
			else openerService.open(this._link.href, { allowCommands: true });
		}));
		this.enabled = true;
	}
	get enabled() {
		return this._enabled;
	}
	set enabled(enabled) {
		if (enabled) {
			this.el.setAttribute("aria-disabled", "false");
			this.el.tabIndex = 0;
			this.el.style.pointerEvents = "auto";
			this.el.style.opacity = "1";
			this.el.style.cursor = "pointer";
			this._enabled = false;
		} else {
			this.el.setAttribute("aria-disabled", "true");
			this.el.tabIndex = -1;
			this.el.style.pointerEvents = "none";
			this.el.style.opacity = "0.4";
			this.el.style.cursor = "default";
			this._enabled = true;
		}
		this._enabled = enabled;
	}
};
Link = __decorate$14([__param$14(3, IOpenerService)], Link);
registerThemingParticipant((theme, collector) => {
	const textLinkForegroundColor = theme.getColor(textLinkForeground);
	if (textLinkForegroundColor) collector.addRule(`.monaco-link { color: ${textLinkForegroundColor}; }`);
	const textLinkActiveForegroundColor = theme.getColor(textLinkActiveForeground);
	if (textLinkActiveForegroundColor) collector.addRule(`.monaco-link:hover { color: ${textLinkActiveForegroundColor}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
var __decorate$13 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$13 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var BANNER_ELEMENT_HEIGHT = 26;
var BannerController = class BannerController$1 extends Disposable {
	constructor(_editor, instantiationService) {
		super();
		this._editor = _editor;
		this.instantiationService = instantiationService;
		this.banner = this._register(this.instantiationService.createInstance(Banner));
	}
	hide() {
		this._editor.setBanner(null, 0);
		this.banner.clear();
	}
	show(item) {
		this.banner.show(Object.assign(Object.assign({}, item), { onClose: () => {
			var _a$5;
			this.hide();
			(_a$5 = item.onClose) === null || _a$5 === void 0 || _a$5.call(item);
		} }));
		this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
	}
};
BannerController = __decorate$13([__param$13(1, IInstantiationService)], BannerController);
var Banner = class Banner$1 extends Disposable {
	constructor(instantiationService) {
		super();
		this.instantiationService = instantiationService;
		this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
		this.element = $("div.editor-banner");
		this.element.tabIndex = 0;
	}
	getAriaLabel(item) {
		if (item.ariaLabel) return item.ariaLabel;
		if (typeof item.message === "string") return item.message;
	}
	getBannerMessage(message) {
		if (typeof message === "string") {
			const element = $("span");
			element.innerText = message;
			return element;
		}
		return this.markdownRenderer.render(message).element;
	}
	clear() {
		clearNode(this.element);
	}
	show(item) {
		clearNode(this.element);
		const ariaLabel = this.getAriaLabel(item);
		if (ariaLabel) this.element.setAttribute("aria-label", ariaLabel);
		const iconContainer = append(this.element, $("div.icon-container"));
		iconContainer.setAttribute("aria-hidden", "true");
		if (item.icon) iconContainer.appendChild($(`div${ThemeIcon.asCSSSelector(item.icon)}`));
		const messageContainer = append(this.element, $("div.message-container"));
		messageContainer.setAttribute("aria-hidden", "true");
		messageContainer.appendChild(this.getBannerMessage(item.message));
		this.messageActionsContainer = append(this.element, $("div.message-actions-container"));
		if (item.actions) for (const action of item.actions) this._register(this.instantiationService.createInstance(Link, this.messageActionsContainer, Object.assign(Object.assign({}, action), { tabIndex: -1 }), {}));
		const actionBarContainer = append(this.element, $("div.action-container"));
		this.actionBar = this._register(new ActionBar(actionBarContainer));
		this.actionBar.push(this._register(new Action("banner.close", "Close Banner", ThemeIcon.asClassName(widgetClose), true, () => {
			if (typeof item.onClose === "function") item.onClose();
		})), {
			icon: true,
			label: false
		});
		this.actionBar.setFocusable(false);
	}
};
Banner = __decorate$13([__param$13(0, IInstantiationService)], Banner);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
var __decorate$12 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$12 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$5 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
const warningIcon = registerIcon("extensions-warning-message", Codicon.warning, localize("warningIcon", "Icon shown with a warning message in the extensions editor."));
var UnicodeHighlighter = class UnicodeHighlighter$1 extends Disposable {
	constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
		super();
		this._editor = _editor;
		this._editorWorkerService = _editorWorkerService;
		this._workspaceTrustService = _workspaceTrustService;
		this._highlighter = null;
		this._bannerClosed = false;
		this._updateState = (state) => {
			if (state && state.hasMore) {
				if (this._bannerClosed) return;
				const max = Math.max(state.ambiguousCharacterCount, state.nonBasicAsciiCharacterCount, state.invisibleCharacterCount);
				let data;
				if (state.nonBasicAsciiCharacterCount >= max) data = {
					message: localize("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
					command: new DisableHighlightingOfNonBasicAsciiCharactersAction()
				};
				else if (state.ambiguousCharacterCount >= max) data = {
					message: localize("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
					command: new DisableHighlightingOfAmbiguousCharactersAction()
				};
				else if (state.invisibleCharacterCount >= max) data = {
					message: localize("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
					command: new DisableHighlightingOfInvisibleCharactersAction()
				};
				else throw new Error("Unreachable");
				this._bannerController.show({
					id: "unicodeHighlightBanner",
					message: data.message,
					icon: warningIcon,
					actions: [{
						label: data.command.shortLabel,
						href: `command:${data.command.id}`
					}],
					onClose: () => {
						this._bannerClosed = true;
					}
				});
			} else this._bannerController.hide();
		};
		this._bannerController = this._register(instantiationService.createInstance(BannerController, _editor));
		this._register(this._editor.onDidChangeModel(() => {
			this._bannerClosed = false;
			this._updateHighlighter();
		}));
		this._options = _editor.getOption(115);
		this._register(_workspaceTrustService.onDidChangeTrust((e) => {
			this._updateHighlighter();
		}));
		this._register(_editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(115)) {
				this._options = _editor.getOption(115);
				this._updateHighlighter();
			}
		}));
		this._updateHighlighter();
	}
	dispose() {
		if (this._highlighter) {
			this._highlighter.dispose();
			this._highlighter = null;
		}
		super.dispose();
	}
	_updateHighlighter() {
		this._updateState(null);
		if (this._highlighter) {
			this._highlighter.dispose();
			this._highlighter = null;
		}
		if (!this._editor.hasModel()) return;
		const options = resolveOptions(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
		if ([
			options.nonBasicASCII,
			options.ambiguousCharacters,
			options.invisibleCharacters
		].every((option) => option === false)) return;
		const highlightOptions = {
			nonBasicASCII: options.nonBasicASCII,
			ambiguousCharacters: options.ambiguousCharacters,
			invisibleCharacters: options.invisibleCharacters,
			includeComments: options.includeComments,
			includeStrings: options.includeStrings,
			allowedCodePoints: Object.keys(options.allowedCharacters).map((c) => c.codePointAt(0)),
			allowedLocales: Object.keys(options.allowedLocales).map((locale) => {
				if (locale === "_os") return new Intl.NumberFormat().resolvedOptions().locale;
				else if (locale === "_vscode") return language;
				return locale;
			})
		};
		if (this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri)) this._highlighter = new DocumentUnicodeHighlighter(this._editor, highlightOptions, this._updateState, this._editorWorkerService);
		else this._highlighter = new ViewportUnicodeHighlighter(this._editor, highlightOptions, this._updateState);
	}
	getDecorationInfo(decoration$1) {
		if (this._highlighter) return this._highlighter.getDecorationInfo(decoration$1);
		return null;
	}
};
UnicodeHighlighter.ID = "editor.contrib.unicodeHighlighter";
UnicodeHighlighter = __decorate$12([
	__param$12(1, IEditorWorkerService),
	__param$12(2, IWorkspaceTrustManagementService),
	__param$12(3, IInstantiationService)
], UnicodeHighlighter);
function resolveOptions(trusted, options) {
	return {
		nonBasicASCII: options.nonBasicASCII === inUntrustedWorkspace ? !trusted : options.nonBasicASCII,
		ambiguousCharacters: options.ambiguousCharacters,
		invisibleCharacters: options.invisibleCharacters,
		includeComments: options.includeComments === inUntrustedWorkspace ? !trusted : options.includeComments,
		includeStrings: options.includeStrings === inUntrustedWorkspace ? !trusted : options.includeStrings,
		allowedCharacters: options.allowedCharacters,
		allowedLocales: options.allowedLocales
	};
}
var DocumentUnicodeHighlighter = class DocumentUnicodeHighlighter$1 extends Disposable {
	constructor(_editor, _options, _updateState, _editorWorkerService) {
		super();
		this._editor = _editor;
		this._options = _options;
		this._updateState = _updateState;
		this._editorWorkerService = _editorWorkerService;
		this._model = this._editor.getModel();
		this._decorations = this._editor.createDecorationsCollection();
		this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
		this._register(this._editor.onDidChangeModelContent(() => {
			this._updateSoon.schedule();
		}));
		this._updateSoon.schedule();
	}
	dispose() {
		this._decorations.clear();
		super.dispose();
	}
	_update() {
		if (this._model.isDisposed()) return;
		if (!this._model.mightContainNonBasicASCII()) {
			this._decorations.clear();
			return;
		}
		const modelVersionId = this._model.getVersionId();
		this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((info) => {
			if (this._model.isDisposed()) return;
			if (this._model.getVersionId() !== modelVersionId) return;
			this._updateState(info);
			const decorations = [];
			if (!info.hasMore) for (const range of info.ranges) decorations.push({
				range,
				options: Decorations.instance.getDecorationFromOptions(this._options)
			});
			this._decorations.set(decorations);
		});
	}
	getDecorationInfo(decoration$1) {
		if (!this._decorations.has(decoration$1)) return null;
		const model = this._editor.getModel();
		if (!isModelDecorationVisible(model, decoration$1)) return null;
		return {
			reason: computeReason(model.getValueInRange(decoration$1.range), this._options),
			inComment: isModelDecorationInComment(model, decoration$1),
			inString: isModelDecorationInString(model, decoration$1)
		};
	}
};
DocumentUnicodeHighlighter = __decorate$12([__param$12(3, IEditorWorkerService)], DocumentUnicodeHighlighter);
var ViewportUnicodeHighlighter = class extends Disposable {
	constructor(_editor, _options, _updateState) {
		super();
		this._editor = _editor;
		this._options = _options;
		this._updateState = _updateState;
		this._model = this._editor.getModel();
		this._decorations = this._editor.createDecorationsCollection();
		this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
		this._register(this._editor.onDidLayoutChange(() => {
			this._updateSoon.schedule();
		}));
		this._register(this._editor.onDidScrollChange(() => {
			this._updateSoon.schedule();
		}));
		this._register(this._editor.onDidChangeHiddenAreas(() => {
			this._updateSoon.schedule();
		}));
		this._register(this._editor.onDidChangeModelContent(() => {
			this._updateSoon.schedule();
		}));
		this._updateSoon.schedule();
	}
	dispose() {
		this._decorations.clear();
		super.dispose();
	}
	_update() {
		if (this._model.isDisposed()) return;
		if (!this._model.mightContainNonBasicASCII()) {
			this._decorations.clear();
			return;
		}
		const ranges = this._editor.getVisibleRanges();
		const decorations = [];
		const totalResult = {
			ranges: [],
			ambiguousCharacterCount: 0,
			invisibleCharacterCount: 0,
			nonBasicAsciiCharacterCount: 0,
			hasMore: false
		};
		for (const range of ranges) {
			const result = UnicodeTextModelHighlighter.computeUnicodeHighlights(this._model, this._options, range);
			for (const r of result.ranges) totalResult.ranges.push(r);
			totalResult.ambiguousCharacterCount += totalResult.ambiguousCharacterCount;
			totalResult.invisibleCharacterCount += totalResult.invisibleCharacterCount;
			totalResult.nonBasicAsciiCharacterCount += totalResult.nonBasicAsciiCharacterCount;
			totalResult.hasMore = totalResult.hasMore || result.hasMore;
		}
		if (!totalResult.hasMore) for (const range of totalResult.ranges) decorations.push({
			range,
			options: Decorations.instance.getDecorationFromOptions(this._options)
		});
		this._updateState(totalResult);
		this._decorations.set(decorations);
	}
	getDecorationInfo(decoration$1) {
		if (!this._decorations.has(decoration$1)) return null;
		const model = this._editor.getModel();
		const text = model.getValueInRange(decoration$1.range);
		if (!isModelDecorationVisible(model, decoration$1)) return null;
		return {
			reason: computeReason(text, this._options),
			inComment: isModelDecorationInComment(model, decoration$1),
			inString: isModelDecorationInString(model, decoration$1)
		};
	}
};
var UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant$1 {
	constructor(_editor, _languageService, _openerService) {
		this._editor = _editor;
		this._languageService = _languageService;
		this._openerService = _openerService;
		this.hoverOrdinal = 4;
	}
	computeSync(anchor, lineDecorations) {
		if (!this._editor.hasModel() || anchor.type !== 1) return [];
		const model = this._editor.getModel();
		const unicodeHighlighter = this._editor.getContribution(UnicodeHighlighter.ID);
		if (!unicodeHighlighter) return [];
		const result = [];
		let index = 300;
		for (const d of lineDecorations) {
			const highlightInfo = unicodeHighlighter.getDecorationInfo(d);
			if (!highlightInfo) continue;
			const codePoint = model.getValueInRange(d.range).codePointAt(0);
			const codePointStr = formatCodePointMarkdown(codePoint);
			let reason;
			switch (highlightInfo.reason.kind) {
				case 0:
					reason = localize("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
					break;
				case 1:
					reason = localize("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", codePointStr);
					break;
				case 2:
					reason = localize("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", codePointStr);
					break;
			}
			const adjustSettingsArgs = {
				codePoint,
				reason: highlightInfo.reason,
				inComment: highlightInfo.inComment,
				inString: highlightInfo.inString
			};
			const adjustSettings = localize("unicodeHighlight.adjustSettings", "Adjust settings");
			const uri = `command:${ShowExcludeOptions.ID}?${encodeURIComponent(JSON.stringify(adjustSettingsArgs))}`;
			const markdown = new MarkdownString("", true).appendMarkdown(reason).appendText(" ").appendLink(uri, adjustSettings);
			result.push(new MarkdownHover(this, d.range, [markdown], index++));
		}
		return result;
	}
	renderHoverParts(context, hoverParts) {
		return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
	}
};
UnicodeHighlighterHoverParticipant = __decorate$12([__param$12(1, ILanguageService), __param$12(2, IOpenerService)], UnicodeHighlighterHoverParticipant);
function codePointToHex(codePoint) {
	return `U+${codePoint.toString(16).padStart(4, "0")}`;
}
function formatCodePointMarkdown(codePoint) {
	let value = `\`${codePointToHex(codePoint)}\``;
	if (!InvisibleCharacters.isInvisibleCharacter(codePoint)) value += ` "${`${renderCodePointAsInlineCode(codePoint)}`}"`;
	return value;
}
function renderCodePointAsInlineCode(codePoint) {
	if (codePoint === 96) return "`` ` ``";
	return "`" + String.fromCodePoint(codePoint) + "`";
}
function computeReason(char, options) {
	return UnicodeTextModelHighlighter.computeUnicodeHighlightReason(char, options);
}
var Decorations = class {
	constructor() {
		this.map = /* @__PURE__ */ new Map();
	}
	getDecorationFromOptions(options) {
		return this.getDecoration(!options.includeComments, !options.includeStrings);
	}
	getDecoration(hideInComments, hideInStrings) {
		const key = `${hideInComments}${hideInStrings}`;
		let options = this.map.get(key);
		if (!options) {
			options = ModelDecorationOptions.createDynamic({
				description: "unicode-highlight",
				stickiness: 1,
				className: "unicode-highlight",
				showIfCollapsed: true,
				overviewRuler: null,
				minimap: null,
				hideInCommentTokens: hideInComments,
				hideInStringTokens: hideInStrings
			});
			this.map.set(key, options);
		}
		return options;
	}
};
Decorations.instance = new Decorations();
var DisableHighlightingInCommentsAction = class extends EditorAction {
	constructor() {
		super({
			id: DisableHighlightingOfAmbiguousCharactersAction.ID,
			label: localize("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
			alias: "Disable highlighting of characters in comments",
			precondition: void 0
		});
		this.shortLabel = localize("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
	}
	run(accessor, editor$1, args) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
			if (configurationService) this.runAction(configurationService);
		});
	}
	runAction(configurationService) {
		return __awaiter$5(this, void 0, void 0, function* () {
			yield configurationService.updateValue(unicodeHighlightConfigKeys.includeComments, false, 2);
		});
	}
};
var DisableHighlightingInStringsAction = class extends EditorAction {
	constructor() {
		super({
			id: DisableHighlightingOfAmbiguousCharactersAction.ID,
			label: localize("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
			alias: "Disable highlighting of characters in strings",
			precondition: void 0
		});
		this.shortLabel = localize("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
	}
	run(accessor, editor$1, args) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
			if (configurationService) this.runAction(configurationService);
		});
	}
	runAction(configurationService) {
		return __awaiter$5(this, void 0, void 0, function* () {
			yield configurationService.updateValue(unicodeHighlightConfigKeys.includeStrings, false, 2);
		});
	}
};
var DisableHighlightingOfAmbiguousCharactersAction = class DisableHighlightingOfAmbiguousCharactersAction extends EditorAction {
	constructor() {
		super({
			id: DisableHighlightingOfAmbiguousCharactersAction.ID,
			label: localize("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
			alias: "Disable highlighting of ambiguous characters",
			precondition: void 0
		});
		this.shortLabel = localize("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
	}
	run(accessor, editor$1, args) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
			if (configurationService) this.runAction(configurationService);
		});
	}
	runAction(configurationService) {
		return __awaiter$5(this, void 0, void 0, function* () {
			yield configurationService.updateValue(unicodeHighlightConfigKeys.ambiguousCharacters, false, 2);
		});
	}
};
DisableHighlightingOfAmbiguousCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
var DisableHighlightingOfInvisibleCharactersAction = class DisableHighlightingOfInvisibleCharactersAction extends EditorAction {
	constructor() {
		super({
			id: DisableHighlightingOfInvisibleCharactersAction.ID,
			label: localize("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
			alias: "Disable highlighting of invisible characters",
			precondition: void 0
		});
		this.shortLabel = localize("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
	}
	run(accessor, editor$1, args) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
			if (configurationService) this.runAction(configurationService);
		});
	}
	runAction(configurationService) {
		return __awaiter$5(this, void 0, void 0, function* () {
			yield configurationService.updateValue(unicodeHighlightConfigKeys.invisibleCharacters, false, 2);
		});
	}
};
DisableHighlightingOfInvisibleCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
var DisableHighlightingOfNonBasicAsciiCharactersAction = class DisableHighlightingOfNonBasicAsciiCharactersAction extends EditorAction {
	constructor() {
		super({
			id: DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
			label: localize("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
			alias: "Disable highlighting of non basic ASCII characters",
			precondition: void 0
		});
		this.shortLabel = localize("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
	}
	run(accessor, editor$1, args) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
			if (configurationService) this.runAction(configurationService);
		});
	}
	runAction(configurationService) {
		return __awaiter$5(this, void 0, void 0, function* () {
			yield configurationService.updateValue(unicodeHighlightConfigKeys.nonBasicASCII, false, 2);
		});
	}
};
DisableHighlightingOfNonBasicAsciiCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
var ShowExcludeOptions = class ShowExcludeOptions extends EditorAction {
	constructor() {
		super({
			id: ShowExcludeOptions.ID,
			label: localize("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
			alias: "Show Exclude Options",
			precondition: void 0
		});
	}
	run(accessor, editor$1, args) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const { codePoint, reason, inString, inComment } = args;
			const char = String.fromCodePoint(codePoint);
			const quickPickService = accessor.get(IQuickInputService);
			const configurationService = accessor.get(IConfigurationService);
			function getExcludeCharFromBeingHighlightedLabel(codePoint$1) {
				if (InvisibleCharacters.isInvisibleCharacter(codePoint$1)) return localize("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", codePointToHex(codePoint$1));
				return localize("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${codePointToHex(codePoint$1)} "${char}"`);
			}
			const options = [];
			if (reason.kind === 0) for (const locale of reason.notAmbiguousInLocales) options.push({
				label: localize("unicodeHighlight.allowCommonCharactersInLanguage", "Allow unicode characters that are more common in the language \"{0}\".", locale),
				run: () => __awaiter$5(this, void 0, void 0, function* () {
					excludeLocaleFromBeingHighlighted(configurationService, [locale]);
				})
			});
			options.push({
				label: getExcludeCharFromBeingHighlightedLabel(codePoint),
				run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
			});
			if (inComment) {
				const action = new DisableHighlightingInCommentsAction();
				options.push({
					label: action.label,
					run: () => __awaiter$5(this, void 0, void 0, function* () {
						return action.runAction(configurationService);
					})
				});
			} else if (inString) {
				const action = new DisableHighlightingInStringsAction();
				options.push({
					label: action.label,
					run: () => __awaiter$5(this, void 0, void 0, function* () {
						return action.runAction(configurationService);
					})
				});
			}
			if (reason.kind === 0) {
				const action = new DisableHighlightingOfAmbiguousCharactersAction();
				options.push({
					label: action.label,
					run: () => __awaiter$5(this, void 0, void 0, function* () {
						return action.runAction(configurationService);
					})
				});
			} else if (reason.kind === 1) {
				const action = new DisableHighlightingOfInvisibleCharactersAction();
				options.push({
					label: action.label,
					run: () => __awaiter$5(this, void 0, void 0, function* () {
						return action.runAction(configurationService);
					})
				});
			} else if (reason.kind === 2) {
				const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
				options.push({
					label: action.label,
					run: () => __awaiter$5(this, void 0, void 0, function* () {
						return action.runAction(configurationService);
					})
				});
			} else expectNever(reason);
			const result = yield quickPickService.pick(options, { title: localize("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options") });
			if (result) yield result.run();
		});
	}
};
ShowExcludeOptions.ID = "editor.action.unicodeHighlight.showExcludeOptions";
function excludeCharFromBeingHighlighted(configurationService, charCodes) {
	return __awaiter$5(this, void 0, void 0, function* () {
		const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
		let value;
		if (typeof existingValue === "object" && existingValue) value = existingValue;
		else value = {};
		for (const charCode of charCodes) value[String.fromCodePoint(charCode)] = true;
		yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedCharacters, value, 2);
	});
}
function excludeLocaleFromBeingHighlighted(configurationService, locales) {
	var _a$5;
	return __awaiter$5(this, void 0, void 0, function* () {
		const existingValue = (_a$5 = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user) === null || _a$5 === void 0 ? void 0 : _a$5.value;
		let value;
		if (typeof existingValue === "object" && existingValue) value = Object.assign({}, existingValue);
		else value = {};
		for (const locale of locales) value[locale] = true;
		yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedLocales, value, 2);
	});
}
function expectNever(value) {
	throw new Error(`Unexpected value: ${value}`);
}
registerEditorAction(DisableHighlightingOfAmbiguousCharactersAction);
registerEditorAction(DisableHighlightingOfInvisibleCharactersAction);
registerEditorAction(DisableHighlightingOfNonBasicAsciiCharactersAction);
registerEditorAction(ShowExcludeOptions);
registerEditorContribution(UnicodeHighlighter.ID, UnicodeHighlighter);
HoverParticipantRegistry.register(UnicodeHighlighterHoverParticipant);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js
var __decorate$11 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$11 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$4 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
	codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
	return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
var UnusualLineTerminatorsDetector = class UnusualLineTerminatorsDetector$1 extends Disposable {
	constructor(_editor, _dialogService, _codeEditorService) {
		super();
		this._editor = _editor;
		this._dialogService = _dialogService;
		this._codeEditorService = _codeEditorService;
		this._config = this._editor.getOption(116);
		this._register(this._editor.onDidChangeConfiguration((e) => {
			if (e.hasChanged(116)) {
				this._config = this._editor.getOption(116);
				this._checkForUnusualLineTerminators();
			}
		}));
		this._register(this._editor.onDidChangeModel(() => {
			this._checkForUnusualLineTerminators();
		}));
		this._register(this._editor.onDidChangeModelContent((e) => {
			if (e.isUndoing) return;
			this._checkForUnusualLineTerminators();
		}));
	}
	_checkForUnusualLineTerminators() {
		return __awaiter$4(this, void 0, void 0, function* () {
			if (this._config === "off") return;
			if (!this._editor.hasModel()) return;
			const model = this._editor.getModel();
			if (!model.mightContainUnusualLineTerminators()) return;
			if (readIgnoreState(this._codeEditorService, model) === true) return;
			if (this._editor.getOption(83)) return;
			if (this._config === "auto") {
				model.removeUnusualLineTerminators(this._editor.getSelections());
				return;
			}
			if (!(yield this._dialogService.confirm({
				title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
				message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
				detail: localize("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename(model.uri)),
				primaryButton: localize("unusualLineTerminators.fix", "Remove Unusual Line Terminators"),
				secondaryButton: localize("unusualLineTerminators.ignore", "Ignore")
			})).confirmed) {
				writeIgnoreState(this._codeEditorService, model, true);
				return;
			}
			model.removeUnusualLineTerminators(this._editor.getSelections());
		});
	}
};
UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
UnusualLineTerminatorsDetector = __decorate$11([__param$11(1, IDialogService), __param$11(2, ICodeEditorService)], UnusualLineTerminatorsDetector);
registerEditorContribution(UnusualLineTerminatorsDetector.ID, UnusualLineTerminatorsDetector);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/browser/viewportSemanticTokens.js
var __decorate$10 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$10 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution$1 extends Disposable {
	constructor(editor$1, _modelService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
		super();
		this._modelService = _modelService;
		this._themeService = _themeService;
		this._configurationService = _configurationService;
		this._editor = editor$1;
		this._provider = languageFeaturesService.documentRangeSemanticTokensProvider;
		this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentRangeSemanticTokens", {
			min: 100,
			max: 500
		});
		this._tokenizeViewport = this._register(new RunOnceScheduler(() => this._tokenizeViewportNow(), 100));
		this._outstandingRequests = [];
		const scheduleTokenizeViewport = () => {
			if (this._editor.hasModel()) this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
		};
		this._register(this._editor.onDidScrollChange(() => {
			scheduleTokenizeViewport();
		}));
		this._register(this._editor.onDidChangeModel(() => {
			this._cancelAll();
			scheduleTokenizeViewport();
		}));
		this._register(this._editor.onDidChangeModelContent((e) => {
			this._cancelAll();
			scheduleTokenizeViewport();
		}));
		this._register(this._provider.onDidChange(() => {
			this._cancelAll();
			scheduleTokenizeViewport();
		}));
		this._register(this._configurationService.onDidChangeConfiguration((e) => {
			if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
				this._cancelAll();
				scheduleTokenizeViewport();
			}
		}));
		this._register(this._themeService.onDidColorThemeChange(() => {
			this._cancelAll();
			scheduleTokenizeViewport();
		}));
	}
	_cancelAll() {
		for (const request of this._outstandingRequests) request.cancel();
		this._outstandingRequests = [];
	}
	_removeOutstandingRequest(req) {
		for (let i = 0, len = this._outstandingRequests.length; i < len; i++) if (this._outstandingRequests[i] === req) {
			this._outstandingRequests.splice(i, 1);
			return;
		}
	}
	_tokenizeViewportNow() {
		if (!this._editor.hasModel()) return;
		const model = this._editor.getModel();
		if (model.tokenization.hasCompleteSemanticTokens()) return;
		if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
			if (model.tokenization.hasSomeSemanticTokens()) model.tokenization.setSemanticTokens(null, false);
			return;
		}
		if (!hasDocumentRangeSemanticTokensProvider(this._provider, model)) {
			if (model.tokenization.hasSomeSemanticTokens()) model.tokenization.setSemanticTokens(null, false);
			return;
		}
		const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
		this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range)));
	}
	_requestRange(model, range) {
		const requestVersionId = model.getVersionId();
		const request = createCancelablePromise((token) => Promise.resolve(getDocumentRangeSemanticTokens(this._provider, model, range, token)));
		const sw = new StopWatch(false);
		request.then((r) => {
			this._debounceInformation.update(model, sw.elapsed());
			if (!r || !r.tokens || model.isDisposed() || model.getVersionId() !== requestVersionId) return;
			const { provider, tokens: result } = r;
			const styling = this._modelService.getSemanticTokensProviderStyling(provider);
			model.tokenization.setPartialSemanticTokens(range, toMultilineTokens2(result, styling, model.getLanguageId()));
		}).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
		return request;
	}
};
ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
ViewportSemanticTokensContribution = __decorate$10([
	__param$10(1, IModelService),
	__param$10(2, IThemeService),
	__param$10(3, IConfigurationService),
	__param$10(4, ILanguageFeatureDebounceService),
	__param$10(5, ILanguageFeaturesService)
], ViewportSemanticTokensContribution);
registerEditorContribution(ViewportSemanticTokensContribution.ID, ViewportSemanticTokensContribution);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
var __decorate$9 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$9 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var editorWordHighlight = registerColor("editor.wordHighlightBackground", {
	dark: "#575757B8",
	light: "#57575740",
	hcDark: null,
	hcLight: null
}, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWordHighlightStrong = registerColor("editor.wordHighlightStrongBackground", {
	dark: "#004972B8",
	light: "#0e639c40",
	hcDark: null,
	hcLight: null
}, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWordHighlightBorder = registerColor("editor.wordHighlightBorder", {
	light: null,
	dark: null,
	hcDark: activeContrastBorder,
	hcLight: activeContrastBorder
}, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
var editorWordHighlightStrongBorder = registerColor("editor.wordHighlightStrongBorder", {
	light: null,
	dark: null,
	hcDark: activeContrastBorder,
	hcLight: activeContrastBorder
}, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
var overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", {
	dark: "#A0A0A0CC",
	light: "#A0A0A0CC",
	hcDark: "#A0A0A0CC",
	hcLight: "#A0A0A0CC"
}, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", {
	dark: "#C0A0C0CC",
	light: "#C0A0C0CC",
	hcDark: "#C0A0C0CC",
	hcLight: "#C0A0C0CC"
}, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(registry, model, position, token) {
	return first(registry.ordered(model).map((provider) => () => {
		return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
	}), isNonEmptyArray);
}
var OccurenceAtPositionRequest = class {
	constructor(_model, _selection, _wordSeparators) {
		this._model = _model;
		this._selection = _selection;
		this._wordSeparators = _wordSeparators;
		this._wordRange = this._getCurrentWordRange(_model, _selection);
		this._result = null;
	}
	get result() {
		if (!this._result) this._result = createCancelablePromise((token) => this._compute(this._model, this._selection, this._wordSeparators, token));
		return this._result;
	}
	_getCurrentWordRange(model, selection) {
		const word = model.getWordAtPosition(selection.getPosition());
		if (word) return new Range$1(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
		return null;
	}
	isValid(model, selection, decorations) {
		const lineNumber = selection.startLineNumber;
		const startColumn = selection.startColumn;
		const endColumn = selection.endColumn;
		const currentWordRange = this._getCurrentWordRange(model, selection);
		let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
		for (let i = 0, len = decorations.length; !requestIsValid && i < len; i++) {
			const range = decorations.getRange(i);
			if (range && range.startLineNumber === lineNumber) {
				if (range.startColumn <= startColumn && range.endColumn >= endColumn) requestIsValid = true;
			}
		}
		return requestIsValid;
	}
	cancel() {
		this.result.cancel();
	}
};
var SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
	constructor(model, selection, wordSeparators, providers) {
		super(model, selection, wordSeparators);
		this._providers = providers;
	}
	_compute(model, selection, wordSeparators, token) {
		return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then((value) => value || []);
	}
};
var TextualOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
	constructor(model, selection, wordSeparators) {
		super(model, selection, wordSeparators);
		this._selectionIsEmpty = selection.isEmpty();
	}
	_compute(model, selection, wordSeparators, token) {
		return timeout(250, token).then(() => {
			if (!selection.isEmpty()) return [];
			const word = model.getWordAtPosition(selection.getPosition());
			if (!word || word.word.length > 1e3) return [];
			return model.findMatches(word.word, true, false, true, wordSeparators, false).map((m) => {
				return {
					range: m.range,
					kind: DocumentHighlightKind.Text
				};
			});
		});
	}
	isValid(model, selection, decorations) {
		const currentSelectionIsEmpty = selection.isEmpty();
		if (this._selectionIsEmpty !== currentSelectionIsEmpty) return false;
		return super.isValid(model, selection, decorations);
	}
};
function computeOccurencesAtPosition(registry, model, selection, wordSeparators) {
	if (registry.has(model)) return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);
	return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);
}
registerModelAndPositionCommand("_executeDocumentHighlights", (accessor, model, position) => {
	return getOccurrencesAtPosition(accessor.get(ILanguageFeaturesService).documentHighlightProvider, model, position, CancellationToken.None);
});
var WordHighlighter = class WordHighlighter {
	constructor(editor$1, providers, contextKeyService) {
		this.toUnhook = new DisposableStore();
		this.workerRequestTokenId = 0;
		this.workerRequestCompleted = false;
		this.workerRequestValue = [];
		this.lastCursorPositionChangeTime = 0;
		this.renderDecorationsTimer = -1;
		this.editor = editor$1;
		this.providers = providers;
		this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
		this._ignorePositionChangeEvent = false;
		this.occurrencesHighlight = this.editor.getOption(74);
		this.model = this.editor.getModel();
		this.toUnhook.add(editor$1.onDidChangeCursorPosition((e) => {
			if (this._ignorePositionChangeEvent) return;
			if (!this.occurrencesHighlight) return;
			this._onPositionChanged(e);
		}));
		this.toUnhook.add(editor$1.onDidChangeModelContent((e) => {
			this._stopAll();
		}));
		this.toUnhook.add(editor$1.onDidChangeConfiguration((e) => {
			const newValue = this.editor.getOption(74);
			if (this.occurrencesHighlight !== newValue) {
				this.occurrencesHighlight = newValue;
				this._stopAll();
			}
		}));
		this.decorations = this.editor.createDecorationsCollection();
		this.workerRequestTokenId = 0;
		this.workerRequest = null;
		this.workerRequestCompleted = false;
		this.lastCursorPositionChangeTime = 0;
		this.renderDecorationsTimer = -1;
	}
	hasDecorations() {
		return this.decorations.length > 0;
	}
	restore() {
		if (!this.occurrencesHighlight) return;
		this._run();
	}
	_getSortedHighlights() {
		return this.decorations.getRanges().sort(Range$1.compareRangesUsingStarts);
	}
	moveNext() {
		const highlights = this._getSortedHighlights();
		const newIndex = (highlights.findIndex((range) => range.containsPosition(this.editor.getPosition())) + 1) % highlights.length;
		const dest = highlights[newIndex];
		try {
			this._ignorePositionChangeEvent = true;
			this.editor.setPosition(dest.getStartPosition());
			this.editor.revealRangeInCenterIfOutsideViewport(dest);
			const word = this._getWord();
			if (word) alert(`${this.editor.getModel().getLineContent(dest.startLineNumber)}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
		} finally {
			this._ignorePositionChangeEvent = false;
		}
	}
	moveBack() {
		const highlights = this._getSortedHighlights();
		const newIndex = (highlights.findIndex((range) => range.containsPosition(this.editor.getPosition())) - 1 + highlights.length) % highlights.length;
		const dest = highlights[newIndex];
		try {
			this._ignorePositionChangeEvent = true;
			this.editor.setPosition(dest.getStartPosition());
			this.editor.revealRangeInCenterIfOutsideViewport(dest);
			const word = this._getWord();
			if (word) alert(`${this.editor.getModel().getLineContent(dest.startLineNumber)}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
		} finally {
			this._ignorePositionChangeEvent = false;
		}
	}
	_removeDecorations() {
		if (this.decorations.length > 0) {
			this.decorations.clear();
			this._hasWordHighlights.set(false);
		}
	}
	_stopAll() {
		this._removeDecorations();
		if (this.renderDecorationsTimer !== -1) {
			clearTimeout(this.renderDecorationsTimer);
			this.renderDecorationsTimer = -1;
		}
		if (this.workerRequest !== null) {
			this.workerRequest.cancel();
			this.workerRequest = null;
		}
		if (!this.workerRequestCompleted) {
			this.workerRequestTokenId++;
			this.workerRequestCompleted = true;
		}
	}
	_onPositionChanged(e) {
		if (!this.occurrencesHighlight) {
			this._stopAll();
			return;
		}
		if (e.reason !== 3) {
			this._stopAll();
			return;
		}
		this._run();
	}
	_getWord() {
		const editorSelection = this.editor.getSelection();
		const lineNumber = editorSelection.startLineNumber;
		const startColumn = editorSelection.startColumn;
		return this.model.getWordAtPosition({
			lineNumber,
			column: startColumn
		});
	}
	_run() {
		const editorSelection = this.editor.getSelection();
		if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
			this._stopAll();
			return;
		}
		const startColumn = editorSelection.startColumn;
		const endColumn = editorSelection.endColumn;
		const word = this._getWord();
		if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
			this._stopAll();
			return;
		}
		const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this.decorations);
		this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime();
		if (workerRequestIsValid) {
			if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
				clearTimeout(this.renderDecorationsTimer);
				this.renderDecorationsTimer = -1;
				this._beginRenderDecorations();
			}
		} else {
			this._stopAll();
			const myRequestId = ++this.workerRequestTokenId;
			this.workerRequestCompleted = false;
			this.workerRequest = computeOccurencesAtPosition(this.providers, this.model, this.editor.getSelection(), this.editor.getOption(119));
			this.workerRequest.result.then((data) => {
				if (myRequestId === this.workerRequestTokenId) {
					this.workerRequestCompleted = true;
					this.workerRequestValue = data || [];
					this._beginRenderDecorations();
				}
			}, onUnexpectedError);
		}
	}
	_beginRenderDecorations() {
		const currentTime = (/* @__PURE__ */ new Date()).getTime();
		const minimumRenderTime = this.lastCursorPositionChangeTime + 250;
		if (currentTime >= minimumRenderTime) {
			this.renderDecorationsTimer = -1;
			this.renderDecorations();
		} else this.renderDecorationsTimer = setTimeout(() => {
			this.renderDecorations();
		}, minimumRenderTime - currentTime);
	}
	renderDecorations() {
		this.renderDecorationsTimer = -1;
		const decorations = [];
		for (const info of this.workerRequestValue) if (info.range) decorations.push({
			range: info.range,
			options: WordHighlighter._getDecorationOptions(info.kind)
		});
		this.decorations.set(decorations);
		this._hasWordHighlights.set(this.hasDecorations());
	}
	static _getDecorationOptions(kind) {
		if (kind === DocumentHighlightKind.Write) return this._WRITE_OPTIONS;
		else if (kind === DocumentHighlightKind.Text) return this._TEXT_OPTIONS;
		else return this._REGULAR_OPTIONS;
	}
	dispose() {
		this._stopAll();
		this.toUnhook.dispose();
	}
};
WordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({
	description: "word-highlight-strong",
	stickiness: 1,
	className: "wordHighlightStrong",
	overviewRuler: {
		color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
		position: OverviewRulerLane.Center
	},
	minimap: {
		color: themeColorFromId(minimapSelectionOccurrenceHighlight),
		position: MinimapPosition.Inline
	}
});
WordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({
	description: "selection-highlight",
	stickiness: 1,
	className: "selectionHighlight",
	overviewRuler: {
		color: themeColorFromId(overviewRulerSelectionHighlightForeground),
		position: OverviewRulerLane.Center
	},
	minimap: {
		color: themeColorFromId(minimapSelectionOccurrenceHighlight),
		position: MinimapPosition.Inline
	}
});
WordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({
	description: "word-highlight",
	stickiness: 1,
	className: "wordHighlight",
	overviewRuler: {
		color: themeColorFromId(overviewRulerWordHighlightForeground),
		position: OverviewRulerLane.Center
	},
	minimap: {
		color: themeColorFromId(minimapSelectionOccurrenceHighlight),
		position: MinimapPosition.Inline
	}
});
var WordHighlighterContribution = class WordHighlighterContribution$1 extends Disposable {
	constructor(editor$1, contextKeyService, languageFeaturesService) {
		super();
		this.wordHighlighter = null;
		const createWordHighlighterIfPossible = () => {
			if (editor$1.hasModel()) this.wordHighlighter = new WordHighlighter(editor$1, languageFeaturesService.documentHighlightProvider, contextKeyService);
		};
		this._register(editor$1.onDidChangeModel((e) => {
			if (this.wordHighlighter) {
				this.wordHighlighter.dispose();
				this.wordHighlighter = null;
			}
			createWordHighlighterIfPossible();
		}));
		createWordHighlighterIfPossible();
	}
	static get(editor$1) {
		return editor$1.getContribution(WordHighlighterContribution$1.ID);
	}
	saveViewState() {
		if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) return true;
		return false;
	}
	moveNext() {
		if (this.wordHighlighter) this.wordHighlighter.moveNext();
	}
	moveBack() {
		if (this.wordHighlighter) this.wordHighlighter.moveBack();
	}
	restoreViewState(state) {
		if (this.wordHighlighter && state) this.wordHighlighter.restore();
	}
	dispose() {
		if (this.wordHighlighter) {
			this.wordHighlighter.dispose();
			this.wordHighlighter = null;
		}
		super.dispose();
	}
};
WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
WordHighlighterContribution = __decorate$9([__param$9(1, IContextKeyService), __param$9(2, ILanguageFeaturesService)], WordHighlighterContribution);
var WordHighlightNavigationAction = class extends EditorAction {
	constructor(next, opts) {
		super(opts);
		this._isNext = next;
	}
	run(accessor, editor$1) {
		const controller = WordHighlighterContribution.get(editor$1);
		if (!controller) return;
		if (this._isNext) controller.moveNext();
		else controller.moveBack();
	}
};
var NextWordHighlightAction = class extends WordHighlightNavigationAction {
	constructor() {
		super(true, {
			id: "editor.action.wordHighlight.next",
			label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
			alias: "Go to Next Symbol Highlight",
			precondition: ctxHasWordHighlights,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 65,
				weight: 100
			}
		});
	}
};
var PrevWordHighlightAction = class extends WordHighlightNavigationAction {
	constructor() {
		super(false, {
			id: "editor.action.wordHighlight.prev",
			label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
			alias: "Go to Previous Symbol Highlight",
			precondition: ctxHasWordHighlights,
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 1089,
				weight: 100
			}
		});
	}
};
var TriggerWordHighlightAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.wordHighlight.trigger",
			label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
			alias: "Trigger Symbol Highlight",
			precondition: ctxHasWordHighlights.toNegated(),
			kbOpts: {
				kbExpr: EditorContextKeys.editorTextFocus,
				primary: 0,
				weight: 100
			}
		});
	}
	run(accessor, editor$1, args) {
		const controller = WordHighlighterContribution.get(editor$1);
		if (!controller) return;
		controller.restoreViewState(true);
	}
};
registerEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);
registerThemingParticipant((theme, collector) => {
	const selectionHighlight = theme.getColor(editorSelectionHighlight);
	if (selectionHighlight) {
		collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);
		collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(.5)}; }`);
	}
	const wordHighlight = theme.getColor(editorWordHighlight);
	if (wordHighlight) collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);
	const wordHighlightStrong = theme.getColor(editorWordHighlightStrong);
	if (wordHighlightStrong) collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);
	const selectionHighlightBorder = theme.getColor(editorSelectionHighlightBorder);
	if (selectionHighlightBorder) collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${selectionHighlightBorder}; box-sizing: border-box; }`);
	const wordHighlightBorder = theme.getColor(editorWordHighlightBorder);
	if (wordHighlightBorder) collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${wordHighlightBorder}; box-sizing: border-box; }`);
	const wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);
	if (wordHighlightStrongBorder) collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/browser/wordOperations.js
var MoveWordCommand = class extends EditorCommand {
	constructor(opts) {
		super(opts);
		this._inSelectionMode = opts.inSelectionMode;
		this._wordNavigationType = opts.wordNavigationType;
	}
	runEditorCommand(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		const wordSeparators = getMapForWordSeparators(editor$1.getOption(119));
		const model = editor$1.getModel();
		const result = editor$1.getSelections().map((sel) => {
			const inPosition = new Position$1(sel.positionLineNumber, sel.positionColumn);
			const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
			return this._moveTo(sel, outPosition, this._inSelectionMode);
		});
		model.pushStackElement();
		editor$1._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState.fromModelSelection(r)));
		if (result.length === 1) {
			const pos = new Position$1(result[0].positionLineNumber, result[0].positionColumn);
			editor$1.revealPosition(pos, 0);
		}
	}
	_moveTo(from, to, inSelectionMode) {
		if (inSelectionMode) return new Selection$1(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
		else return new Selection$1(to.lineNumber, to.column, to.lineNumber, to.column);
	}
};
var WordLeftCommand = class extends MoveWordCommand {
	_move(wordSeparators, model, position, wordNavigationType) {
		return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
	}
};
var WordRightCommand = class extends MoveWordCommand {
	_move(wordSeparators, model, position, wordNavigationType) {
		return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
	}
};
var CursorWordStartLeft = class extends WordLeftCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 0,
			id: "cursorWordStartLeft",
			precondition: void 0
		});
	}
};
var CursorWordEndLeft = class extends WordLeftCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 2,
			id: "cursorWordEndLeft",
			precondition: void 0
		});
	}
};
var CursorWordLeft = class extends WordLeftCommand {
	constructor() {
		var _a$5;
		super({
			inSelectionMode: false,
			wordNavigationType: 1,
			id: "cursorWordLeft",
			precondition: void 0,
			kbOpts: {
				kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a$5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a$5 === void 0 ? void 0 : _a$5.negate()),
				primary: 2063,
				mac: { primary: 527 },
				weight: 100
			}
		});
	}
};
var CursorWordStartLeftSelect = class extends WordLeftCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 0,
			id: "cursorWordStartLeftSelect",
			precondition: void 0
		});
	}
};
var CursorWordEndLeftSelect = class extends WordLeftCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 2,
			id: "cursorWordEndLeftSelect",
			precondition: void 0
		});
	}
};
var CursorWordLeftSelect = class extends WordLeftCommand {
	constructor() {
		var _a$5;
		super({
			inSelectionMode: true,
			wordNavigationType: 1,
			id: "cursorWordLeftSelect",
			precondition: void 0,
			kbOpts: {
				kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a$5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a$5 === void 0 ? void 0 : _a$5.negate()),
				primary: 3087,
				mac: { primary: 1551 },
				weight: 100
			}
		});
	}
};
var CursorWordAccessibilityLeft = class extends WordLeftCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 3,
			id: "cursorWordAccessibilityLeft",
			precondition: void 0
		});
	}
	_move(_, model, position, wordNavigationType) {
		return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
	}
};
var CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 3,
			id: "cursorWordAccessibilityLeftSelect",
			precondition: void 0
		});
	}
	_move(_, model, position, wordNavigationType) {
		return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
	}
};
var CursorWordStartRight = class extends WordRightCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 0,
			id: "cursorWordStartRight",
			precondition: void 0
		});
	}
};
var CursorWordEndRight = class extends WordRightCommand {
	constructor() {
		var _a$5;
		super({
			inSelectionMode: false,
			wordNavigationType: 2,
			id: "cursorWordEndRight",
			precondition: void 0,
			kbOpts: {
				kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a$5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a$5 === void 0 ? void 0 : _a$5.negate()),
				primary: 2065,
				mac: { primary: 529 },
				weight: 100
			}
		});
	}
};
var CursorWordRight = class extends WordRightCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 2,
			id: "cursorWordRight",
			precondition: void 0
		});
	}
};
var CursorWordStartRightSelect = class extends WordRightCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 0,
			id: "cursorWordStartRightSelect",
			precondition: void 0
		});
	}
};
var CursorWordEndRightSelect = class extends WordRightCommand {
	constructor() {
		var _a$5;
		super({
			inSelectionMode: true,
			wordNavigationType: 2,
			id: "cursorWordEndRightSelect",
			precondition: void 0,
			kbOpts: {
				kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a$5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a$5 === void 0 ? void 0 : _a$5.negate()),
				primary: 3089,
				mac: { primary: 1553 },
				weight: 100
			}
		});
	}
};
var CursorWordRightSelect = class extends WordRightCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 2,
			id: "cursorWordRightSelect",
			precondition: void 0
		});
	}
};
var CursorWordAccessibilityRight = class extends WordRightCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 3,
			id: "cursorWordAccessibilityRight",
			precondition: void 0
		});
	}
	_move(_, model, position, wordNavigationType) {
		return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
	}
};
var CursorWordAccessibilityRightSelect = class extends WordRightCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 3,
			id: "cursorWordAccessibilityRightSelect",
			precondition: void 0
		});
	}
	_move(_, model, position, wordNavigationType) {
		return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
	}
};
var DeleteWordCommand = class extends EditorCommand {
	constructor(opts) {
		super(opts);
		this._whitespaceHeuristics = opts.whitespaceHeuristics;
		this._wordNavigationType = opts.wordNavigationType;
	}
	runEditorCommand(accessor, editor$1, args) {
		const languageConfigurationService = accessor.get(ILanguageConfigurationService);
		if (!editor$1.hasModel()) return;
		const wordSeparators = getMapForWordSeparators(editor$1.getOption(119));
		const model = editor$1.getModel();
		const selections = editor$1.getSelections();
		const autoClosingBrackets = editor$1.getOption(5);
		const autoClosingQuotes = editor$1.getOption(8);
		const autoClosingPairs = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getAutoClosingPairs();
		const viewModel = editor$1._getViewModel();
		const commands = selections.map((sel) => {
			return new ReplaceCommand(this._delete({
				wordSeparators,
				model,
				selection: sel,
				whitespaceHeuristics: this._whitespaceHeuristics,
				autoClosingDelete: editor$1.getOption(6),
				autoClosingBrackets,
				autoClosingQuotes,
				autoClosingPairs,
				autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
			}, this._wordNavigationType), "");
		});
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
var DeleteWordLeftCommand = class extends DeleteWordCommand {
	_delete(ctx, wordNavigationType) {
		const r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
		if (r) return r;
		return new Range$1(1, 1, 1, 1);
	}
};
var DeleteWordRightCommand = class extends DeleteWordCommand {
	_delete(ctx, wordNavigationType) {
		const r = WordOperations.deleteWordRight(ctx, wordNavigationType);
		if (r) return r;
		const lineCount = ctx.model.getLineCount();
		const maxColumn = ctx.model.getLineMaxColumn(lineCount);
		return new Range$1(lineCount, maxColumn, lineCount, maxColumn);
	}
};
var DeleteWordStartLeft = class extends DeleteWordLeftCommand {
	constructor() {
		super({
			whitespaceHeuristics: false,
			wordNavigationType: 0,
			id: "deleteWordStartLeft",
			precondition: EditorContextKeys.writable
		});
	}
};
var DeleteWordEndLeft = class extends DeleteWordLeftCommand {
	constructor() {
		super({
			whitespaceHeuristics: false,
			wordNavigationType: 2,
			id: "deleteWordEndLeft",
			precondition: EditorContextKeys.writable
		});
	}
};
var DeleteWordLeft = class extends DeleteWordLeftCommand {
	constructor() {
		super({
			whitespaceHeuristics: true,
			wordNavigationType: 0,
			id: "deleteWordLeft",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 2049,
				mac: { primary: 513 },
				weight: 100
			}
		});
	}
};
var DeleteWordStartRight = class extends DeleteWordRightCommand {
	constructor() {
		super({
			whitespaceHeuristics: false,
			wordNavigationType: 0,
			id: "deleteWordStartRight",
			precondition: EditorContextKeys.writable
		});
	}
};
var DeleteWordEndRight = class extends DeleteWordRightCommand {
	constructor() {
		super({
			whitespaceHeuristics: false,
			wordNavigationType: 2,
			id: "deleteWordEndRight",
			precondition: EditorContextKeys.writable
		});
	}
};
var DeleteWordRight = class extends DeleteWordRightCommand {
	constructor() {
		super({
			whitespaceHeuristics: true,
			wordNavigationType: 2,
			id: "deleteWordRight",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 2068,
				mac: { primary: 532 },
				weight: 100
			}
		});
	}
};
var DeleteInsideWord = class extends EditorAction {
	constructor() {
		super({
			id: "deleteInsideWord",
			precondition: EditorContextKeys.writable,
			label: localize("deleteInsideWord", "Delete Word"),
			alias: "Delete Word"
		});
	}
	run(accessor, editor$1, args) {
		if (!editor$1.hasModel()) return;
		const wordSeparators = getMapForWordSeparators(editor$1.getOption(119));
		const model = editor$1.getModel();
		const commands = editor$1.getSelections().map((sel) => {
			return new ReplaceCommand(WordOperations.deleteInsideWord(wordSeparators, model, sel), "");
		});
		editor$1.pushUndoStop();
		editor$1.executeCommands(this.id, commands);
		editor$1.pushUndoStop();
	}
};
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());
registerEditorAction(DeleteInsideWord);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/browser/wordPartOperations.js
var DeleteWordPartLeft = class extends DeleteWordCommand {
	constructor() {
		super({
			whitespaceHeuristics: true,
			wordNavigationType: 0,
			id: "deleteWordPartLeft",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 769 },
				weight: 100
			}
		});
	}
	_delete(ctx, wordNavigationType) {
		const r = WordPartOperations.deleteWordPartLeft(ctx);
		if (r) return r;
		return new Range$1(1, 1, 1, 1);
	}
};
var DeleteWordPartRight = class extends DeleteWordCommand {
	constructor() {
		super({
			whitespaceHeuristics: true,
			wordNavigationType: 2,
			id: "deleteWordPartRight",
			precondition: EditorContextKeys.writable,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 788 },
				weight: 100
			}
		});
	}
	_delete(ctx, wordNavigationType) {
		const r = WordPartOperations.deleteWordPartRight(ctx);
		if (r) return r;
		const lineCount = ctx.model.getLineCount();
		const maxColumn = ctx.model.getLineMaxColumn(lineCount);
		return new Range$1(lineCount, maxColumn, lineCount, maxColumn);
	}
};
var WordPartLeftCommand = class extends MoveWordCommand {
	_move(wordSeparators, model, position, wordNavigationType) {
		return WordPartOperations.moveWordPartLeft(wordSeparators, model, position);
	}
};
var CursorWordPartLeft = class extends WordPartLeftCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 0,
			id: "cursorWordPartLeft",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 783 },
				weight: 100
			}
		});
	}
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
var CursorWordPartLeftSelect = class extends WordPartLeftCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 0,
			id: "cursorWordPartLeftSelect",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 1807 },
				weight: 100
			}
		});
	}
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
var WordPartRightCommand = class extends MoveWordCommand {
	_move(wordSeparators, model, position, wordNavigationType) {
		return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
	}
};
var CursorWordPartRight = class extends WordPartRightCommand {
	constructor() {
		super({
			inSelectionMode: false,
			wordNavigationType: 2,
			id: "cursorWordPartRight",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 785 },
				weight: 100
			}
		});
	}
};
var CursorWordPartRightSelect = class extends WordPartRightCommand {
	constructor() {
		super({
			inSelectionMode: true,
			wordNavigationType: 2,
			id: "cursorWordPartRightSelect",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.textInputFocus,
				primary: 0,
				mac: { primary: 1809 },
				weight: 100
			}
		});
	}
};
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/readOnlyMessage/browser/contribution.js
var ReadOnlyMessageController = class extends Disposable {
	constructor(editor$1) {
		super();
		this.editor = editor$1;
		this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
	}
	_onDidAttemptReadOnlyEdit() {
		const messageController = MessageController.get(this.editor);
		if (messageController && this.editor.hasModel()) if (this.editor.isSimpleWidget) messageController.showMessage(localize("editor.simple.readonly", "Cannot edit in read-only input"), this.editor.getPosition());
		else messageController.showMessage(localize("editor.readonly", "Cannot edit in read-only editor"), this.editor.getPosition());
	}
};
ReadOnlyMessageController.ID = "editor.contrib.readOnlyMessageController";
registerEditorContribution(ReadOnlyMessageController.ID, ReadOnlyMessageController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.js
var __decorate$8 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$8 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey("accessibilityHelpWidgetVisible", false);
var AccessibilityHelpController = class AccessibilityHelpController$1 extends Disposable {
	constructor(editor$1, instantiationService) {
		super();
		this._editor = editor$1;
		this._widget = this._register(instantiationService.createInstance(AccessibilityHelpWidget, this._editor));
	}
	static get(editor$1) {
		return editor$1.getContribution(AccessibilityHelpController$1.ID);
	}
	show() {
		this._widget.show();
	}
	hide() {
		this._widget.hide();
	}
};
AccessibilityHelpController.ID = "editor.contrib.accessibilityHelpController";
AccessibilityHelpController = __decorate$8([__param$8(1, IInstantiationService)], AccessibilityHelpController);
function getSelectionLabel(selections, charactersSelected) {
	if (!selections || selections.length === 0) return AccessibilityHelpNLS.noSelection;
	if (selections.length === 1) {
		if (charactersSelected) return format(AccessibilityHelpNLS.singleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);
		return format(AccessibilityHelpNLS.singleSelection, selections[0].positionLineNumber, selections[0].positionColumn);
	}
	if (charactersSelected) return format(AccessibilityHelpNLS.multiSelectionRange, selections.length, charactersSelected);
	if (selections.length > 0) return format(AccessibilityHelpNLS.multiSelection, selections.length);
	return "";
}
var AccessibilityHelpWidget = class AccessibilityHelpWidget$1 extends Widget {
	constructor(editor$1, _contextKeyService, _keybindingService, _openerService) {
		super();
		this._contextKeyService = _contextKeyService;
		this._keybindingService = _keybindingService;
		this._openerService = _openerService;
		this._editor = editor$1;
		this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(this._contextKeyService);
		this._domNode = createFastDomNode(document.createElement("div"));
		this._domNode.setClassName("accessibilityHelpWidget");
		this._domNode.setDisplay("none");
		this._domNode.setAttribute("role", "dialog");
		this._domNode.setAttribute("aria-hidden", "true");
		this._contentDomNode = createFastDomNode(document.createElement("div"));
		this._contentDomNode.setAttribute("role", "document");
		this._domNode.appendChild(this._contentDomNode);
		this._isVisible = false;
		this._register(this._editor.onDidLayoutChange(() => {
			if (this._isVisible) this._layout();
		}));
		this._register(addStandardDisposableListener(this._contentDomNode.domNode, "keydown", (e) => {
			if (!this._isVisible) return;
			if (e.equals(2083)) {
				alert(AccessibilityHelpNLS.emergencyConfOn);
				this._editor.updateOptions({ accessibilitySupport: "on" });
				clearNode(this._contentDomNode.domNode);
				this._buildContent();
				this._contentDomNode.domNode.focus();
				e.preventDefault();
				e.stopPropagation();
			}
			if (e.equals(2086)) {
				alert(AccessibilityHelpNLS.openingDocs);
				let url = this._editor.getRawOptions().accessibilityHelpUrl;
				if (typeof url === "undefined") url = "https://go.microsoft.com/fwlink/?linkid=852450";
				this._openerService.open(URI.parse(url));
				e.preventDefault();
				e.stopPropagation();
			}
		}));
		this.onblur(this._contentDomNode.domNode, () => {
			this.hide();
		});
		this._editor.addOverlayWidget(this);
	}
	dispose() {
		this._editor.removeOverlayWidget(this);
		super.dispose();
	}
	getId() {
		return AccessibilityHelpWidget$1.ID;
	}
	getDomNode() {
		return this._domNode.domNode;
	}
	getPosition() {
		return { preference: null };
	}
	show() {
		if (this._isVisible) return;
		this._isVisible = true;
		this._isVisibleKey.set(true);
		this._layout();
		this._domNode.setDisplay("block");
		this._domNode.setAttribute("aria-hidden", "false");
		this._contentDomNode.domNode.tabIndex = 0;
		this._buildContent();
		this._contentDomNode.domNode.focus();
	}
	_descriptionForCommand(commandId, msg, noKbMsg) {
		const kb = this._keybindingService.lookupKeybinding(commandId);
		if (kb) return format(msg, kb.getAriaLabel());
		return format(noKbMsg, commandId);
	}
	_buildContent() {
		const options = this._editor.getOptions();
		const selections = this._editor.getSelections();
		let charactersSelected = 0;
		if (selections) {
			const model = this._editor.getModel();
			if (model) selections.forEach((selection) => {
				charactersSelected += model.getValueLengthInRange(selection);
			});
		}
		let text = getSelectionLabel(selections, charactersSelected);
		if (options.get(56)) if (options.get(83)) text += AccessibilityHelpNLS.readonlyDiffEditor;
		else text += AccessibilityHelpNLS.editableDiffEditor;
		else if (options.get(83)) text += AccessibilityHelpNLS.readonlyEditor;
		else text += AccessibilityHelpNLS.editableEditor;
		const turnOnMessage = isMacintosh ? AccessibilityHelpNLS.changeConfigToOnMac : AccessibilityHelpNLS.changeConfigToOnWinLinux;
		switch (options.get(2)) {
			case 0:
				text += "\n\n - " + turnOnMessage;
				break;
			case 2:
				text += "\n\n - " + AccessibilityHelpNLS.auto_on;
				break;
			case 1:
				text += "\n\n - " + AccessibilityHelpNLS.auto_off;
				text += " " + turnOnMessage;
				break;
		}
		if (options.get(132)) text += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb);
		else text += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb);
		const openDocMessage = isMacintosh ? AccessibilityHelpNLS.openDocMac : AccessibilityHelpNLS.openDocWinLinux;
		text += "\n\n - " + openDocMessage;
		text += "\n\n" + AccessibilityHelpNLS.outroMsg;
		this._contentDomNode.domNode.appendChild(renderFormattedText(text));
		this._contentDomNode.domNode.setAttribute("aria-label", text);
	}
	hide() {
		if (!this._isVisible) return;
		this._isVisible = false;
		this._isVisibleKey.reset();
		this._domNode.setDisplay("none");
		this._domNode.setAttribute("aria-hidden", "true");
		this._contentDomNode.domNode.tabIndex = -1;
		clearNode(this._contentDomNode.domNode);
		this._editor.focus();
	}
	_layout() {
		const editorLayout = this._editor.getLayoutInfo();
		const w = Math.max(5, Math.min(AccessibilityHelpWidget$1.WIDTH, editorLayout.width - 40));
		const h = Math.max(5, Math.min(AccessibilityHelpWidget$1.HEIGHT, editorLayout.height - 40));
		this._domNode.setWidth(w);
		this._domNode.setHeight(h);
		const top = Math.round((editorLayout.height - h) / 2);
		this._domNode.setTop(top);
		const left = Math.round((editorLayout.width - w) / 2);
		this._domNode.setLeft(left);
	}
};
AccessibilityHelpWidget.ID = "editor.contrib.accessibilityHelpWidget";
AccessibilityHelpWidget.WIDTH = 500;
AccessibilityHelpWidget.HEIGHT = 300;
AccessibilityHelpWidget = __decorate$8([
	__param$8(1, IContextKeyService),
	__param$8(2, IKeybindingService),
	__param$8(3, IOpenerService)
], AccessibilityHelpWidget);
var ShowAccessibilityHelpAction = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.showAccessibilityHelp",
			label: AccessibilityHelpNLS.showAccessibilityHelpAction,
			alias: "Show Accessibility Help",
			precondition: void 0,
			kbOpts: {
				primary: 571,
				weight: 100,
				linux: {
					primary: 1595,
					secondary: [571]
				}
			}
		});
	}
	run(accessor, editor$1) {
		const controller = AccessibilityHelpController.get(editor$1);
		if (controller) controller.show();
	}
};
registerEditorContribution(AccessibilityHelpController.ID, AccessibilityHelpController);
registerEditorAction(ShowAccessibilityHelpAction);
registerEditorCommand(new (EditorCommand.bindToContribution(AccessibilityHelpController.get))({
	id: "closeAccessibilityHelp",
	precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,
	handler: (x) => x.hide(),
	kbOpts: {
		weight: 200,
		kbExpr: EditorContextKeys.focus,
		primary: 9,
		secondary: [1033]
	}
}));
registerThemingParticipant((theme, collector) => {
	const widgetBackground = theme.getColor(editorWidgetBackground);
	if (widgetBackground) collector.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${widgetBackground}; }`);
	const widgetForeground = theme.getColor(editorWidgetForeground);
	if (widgetForeground) collector.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${widgetForeground}; }`);
	const widgetShadowColor = theme.getColor(widgetShadow);
	if (widgetShadowColor) collector.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);
	const hcBorder = theme.getColor(contrastBorder);
	if (hcBorder) collector.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${hcBorder}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js
var IPadShowKeyboard = class extends Disposable {
	constructor(editor$1) {
		super();
		this.editor = editor$1;
		this.widget = null;
		if (isIOS) {
			this._register(editor$1.onDidChangeConfiguration(() => this.update()));
			this.update();
		}
	}
	update() {
		const shouldHaveWidget = !this.editor.getOption(83);
		if (!this.widget && shouldHaveWidget) this.widget = new ShowKeyboardWidget(this.editor);
		else if (this.widget && !shouldHaveWidget) {
			this.widget.dispose();
			this.widget = null;
		}
	}
	dispose() {
		super.dispose();
		if (this.widget) {
			this.widget.dispose();
			this.widget = null;
		}
	}
};
IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
var ShowKeyboardWidget = class ShowKeyboardWidget extends Disposable {
	constructor(editor$1) {
		super();
		this.editor = editor$1;
		this._domNode = document.createElement("textarea");
		this._domNode.className = "iPadShowKeyboard";
		this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
			this.editor.focus();
		}));
		this._register(addDisposableListener(this._domNode, "focus", (e) => {
			this.editor.focus();
		}));
		this.editor.addOverlayWidget(this);
	}
	dispose() {
		this.editor.removeOverlayWidget(this);
		super.dispose();
	}
	getId() {
		return ShowKeyboardWidget.ID;
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		return { preference: 1 };
	}
};
ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
registerEditorContribution(IPadShowKeyboard.ID, IPadShowKeyboard);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js
var __decorate$7 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$7 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var InspectTokensController = class InspectTokensController$1 extends Disposable {
	constructor(editor$1, standaloneColorService, languageService) {
		super();
		this._editor = editor$1;
		this._languageService = languageService;
		this._widget = null;
		this._register(this._editor.onDidChangeModel((e) => this.stop()));
		this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
		this._register(TokenizationRegistry.onDidChange((e) => this.stop()));
		this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
	}
	static get(editor$1) {
		return editor$1.getContribution(InspectTokensController$1.ID);
	}
	dispose() {
		this.stop();
		super.dispose();
	}
	launch() {
		if (this._widget) return;
		if (!this._editor.hasModel()) return;
		this._widget = new InspectTokensWidget(this._editor, this._languageService);
	}
	stop() {
		if (this._widget) {
			this._widget.dispose();
			this._widget = null;
		}
	}
};
InspectTokensController.ID = "editor.contrib.inspectTokens";
InspectTokensController = __decorate$7([__param$7(1, IStandaloneThemeService), __param$7(2, ILanguageService)], InspectTokensController);
var InspectTokens = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.inspectTokens",
			label: InspectTokensNLS.inspectTokensAction,
			alias: "Developer: Inspect Tokens",
			precondition: void 0
		});
	}
	run(accessor, editor$1) {
		const controller = InspectTokensController.get(editor$1);
		if (controller) controller.launch();
	}
};
function renderTokenText(tokenText) {
	let result = "";
	for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
		const charCode = tokenText.charCodeAt(charIndex);
		switch (charCode) {
			case 9:
				result += "";
				break;
			case 32:
				result += "";
				break;
			default: result += String.fromCharCode(charCode);
		}
	}
	return result;
}
function getSafeTokenizationSupport(languageIdCodec, languageId) {
	const tokenizationSupport = TokenizationRegistry.get(languageId);
	if (tokenizationSupport) return tokenizationSupport;
	const encodedLanguageId = languageIdCodec.encodeLanguageId(languageId);
	return {
		getInitialState: () => NullState,
		tokenize: (line, hasEOL, state) => nullTokenize(languageId, state),
		tokenizeEncoded: (line, hasEOL, state) => nullTokenizeEncoded(encodedLanguageId, state)
	};
}
var InspectTokensWidget = class InspectTokensWidget extends Disposable {
	constructor(editor$1, languageService) {
		super();
		this.allowEditorOverflow = true;
		this._editor = editor$1;
		this._languageService = languageService;
		this._model = this._editor.getModel();
		this._domNode = document.createElement("div");
		this._domNode.className = "tokens-inspect-widget";
		this._tokenizationSupport = getSafeTokenizationSupport(this._languageService.languageIdCodec, this._model.getLanguageId());
		this._compute(this._editor.getPosition());
		this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));
		this._editor.addContentWidget(this);
	}
	dispose() {
		this._editor.removeContentWidget(this);
		super.dispose();
	}
	getId() {
		return InspectTokensWidget._ID;
	}
	_compute(position) {
		const data = this._getTokensAtLine(position.lineNumber);
		let token1Index = 0;
		for (let i = data.tokens1.length - 1; i >= 0; i--) {
			const t = data.tokens1[i];
			if (position.column - 1 >= t.offset) {
				token1Index = i;
				break;
			}
		}
		let token2Index = 0;
		for (let i = data.tokens2.length >>> 1; i >= 0; i--) if (position.column - 1 >= data.tokens2[i << 1]) {
			token2Index = i;
			break;
		}
		const lineContent = this._model.getLineContent(position.lineNumber);
		let tokenText = "";
		if (token1Index < data.tokens1.length) {
			const tokenStartIndex = data.tokens1[token1Index].offset;
			const tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
			tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
		}
		reset(this._domNode, $("h2.tm-token", void 0, renderTokenText(tokenText), $("span.tm-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
		append(this._domNode, $("hr.tokens-inspect-separator", { "style": "clear:both" }));
		const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;
		append(this._domNode, $("table.tm-metadata-table", void 0, $("tbody", void 0, $("tr", void 0, $("td.tm-metadata-key", void 0, "language"), $("td.tm-metadata-value", void 0, `${metadata ? metadata.languageId : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "token type"), $("td.tm-metadata-value", void 0, `${metadata ? this._tokenTypeToString(metadata.tokenType) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "font style"), $("td.tm-metadata-value", void 0, `${metadata ? this._fontStyleToString(metadata.fontStyle) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "foreground"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "background"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : "-?-"}`)))));
		append(this._domNode, $("hr.tokens-inspect-separator"));
		if (token1Index < data.tokens1.length) append(this._domNode, $("span.tm-token-type", void 0, data.tokens1[token1Index].type));
		this._editor.layoutContentWidget(this);
	}
	_decodeMetadata(metadata) {
		const colorMap = TokenizationRegistry.getColorMap();
		const languageId = TokenMetadata.getLanguageId(metadata);
		const tokenType = TokenMetadata.getTokenType(metadata);
		const fontStyle = TokenMetadata.getFontStyle(metadata);
		const foreground$1 = TokenMetadata.getForeground(metadata);
		const background = TokenMetadata.getBackground(metadata);
		return {
			languageId: this._languageService.languageIdCodec.decodeLanguageId(languageId),
			tokenType,
			fontStyle,
			foreground: colorMap[foreground$1],
			background: colorMap[background]
		};
	}
	_tokenTypeToString(tokenType) {
		switch (tokenType) {
			case 0: return "Other";
			case 1: return "Comment";
			case 2: return "String";
			case 3: return "RegEx";
			default: return "??";
		}
	}
	_fontStyleToString(fontStyle) {
		let r = "";
		if (fontStyle & 1) r += "italic ";
		if (fontStyle & 2) r += "bold ";
		if (fontStyle & 4) r += "underline ";
		if (fontStyle & 8) r += "strikethrough ";
		if (r.length === 0) r = "---";
		return r;
	}
	_getTokensAtLine(lineNumber) {
		const stateBeforeLine = this._getStateBeforeLine(lineNumber);
		const tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), true, stateBeforeLine);
		const tokenizationResult2 = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(lineNumber), true, stateBeforeLine);
		return {
			startState: stateBeforeLine,
			tokens1: tokenizationResult1.tokens,
			tokens2: tokenizationResult2.tokens,
			endState: tokenizationResult1.endState
		};
	}
	_getStateBeforeLine(lineNumber) {
		let state = this._tokenizationSupport.getInitialState();
		for (let i = 1; i < lineNumber; i++) state = this._tokenizationSupport.tokenize(this._model.getLineContent(i), true, state).endState;
		return state;
	}
	getDomNode() {
		return this._domNode;
	}
	getPosition() {
		return {
			position: this._editor.getPosition(),
			preference: [2, 1]
		};
	}
};
InspectTokensWidget._ID = "editor.contrib.inspectTokensWidget";
registerEditorContribution(InspectTokensController.ID, InspectTokensController);
registerEditorAction(InspectTokens);
registerThemingParticipant((theme, collector) => {
	const border = theme.getColor(editorHoverBorder);
	if (border) {
		const borderWidth = isHighContrast(theme.type) ? 2 : 1;
		collector.addRule(`.monaco-editor .tokens-inspect-widget { border: ${borderWidth}px solid ${border}; }`);
		collector.addRule(`.monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: ${border}; }`);
	}
	const background = theme.getColor(editorHoverBackground);
	if (background) collector.addRule(`.monaco-editor .tokens-inspect-widget { background-color: ${background}; }`);
	const foreground$1 = theme.getColor(editorHoverForeground);
	if (foreground$1) collector.addRule(`.monaco-editor .tokens-inspect-widget { color: ${foreground$1}; }`);
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js
var __decorate$6 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$6 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var HelpQuickAccessProvider = class HelpQuickAccessProvider$1 {
	constructor(quickInputService, keybindingService) {
		this.quickInputService = quickInputService;
		this.keybindingService = keybindingService;
		this.registry = Registry.as(Extensions.Quickaccess);
	}
	provide(picker) {
		const disposables = new DisposableStore();
		disposables.add(picker.onDidAccept(() => {
			const [item] = picker.selectedItems;
			if (item) this.quickInputService.quickAccess.show(item.prefix, { preserveValue: true });
		}));
		disposables.add(picker.onDidChangeValue((value) => {
			const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider$1.PREFIX.length));
			if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider$1.PREFIX) this.quickInputService.quickAccess.show(providerDescriptor.prefix, { preserveValue: true });
		}));
		picker.items = this.getQuickAccessProviders();
		return disposables;
	}
	getQuickAccessProviders() {
		const providers = [];
		for (const provider of this.registry.getQuickAccessProviders().sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix))) {
			if (provider.prefix === HelpQuickAccessProvider$1.PREFIX) continue;
			for (const helpEntry of provider.helpEntries) {
				const prefix = helpEntry.prefix || provider.prefix;
				const label = prefix || "";
				providers.push({
					prefix,
					label,
					keybinding: helpEntry.commandId ? this.keybindingService.lookupKeybinding(helpEntry.commandId) : void 0,
					ariaLabel: localize("helpPickAriaLabel", "{0}, {1}", label, helpEntry.description),
					description: helpEntry.description
				});
			}
		}
		return providers;
	}
};
HelpQuickAccessProvider.PREFIX = "?";
HelpQuickAccessProvider = __decorate$6([__param$6(0, IQuickInputService), __param$6(1, IKeybindingService)], HelpQuickAccessProvider);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
	ctor: HelpQuickAccessProvider,
	prefix: "",
	helpEntries: [{ description: QuickHelpNLS.helpQuickAccessActionLabel }]
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js
/**
* A reusable quick access provider for the editor with support
* for adding decorations for navigating in the currently active file
* (for example "Go to line", "Go to symbol").
*/
var AbstractEditorNavigationQuickAccessProvider = class {
	constructor(options) {
		this.options = options;
		this.rangeHighlightDecorationId = void 0;
	}
	provide(picker, token) {
		var _a$5;
		const disposables = new DisposableStore();
		picker.canAcceptInBackground = !!((_a$5 = this.options) === null || _a$5 === void 0 ? void 0 : _a$5.canAcceptInBackground);
		picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
		const pickerDisposable = disposables.add(new MutableDisposable());
		pickerDisposable.value = this.doProvide(picker, token);
		disposables.add(this.onDidActiveTextEditorControlChange(() => {
			pickerDisposable.value = void 0;
			pickerDisposable.value = this.doProvide(picker, token);
		}));
		return disposables;
	}
	doProvide(picker, token) {
		const disposables = new DisposableStore();
		const editor$1 = this.activeTextEditorControl;
		if (editor$1 && this.canProvideWithTextEditor(editor$1)) {
			const context = { editor: editor$1 };
			const codeEditor = getCodeEditor(editor$1);
			if (codeEditor) {
				let lastKnownEditorViewState = withNullAsUndefined(editor$1.saveViewState());
				disposables.add(codeEditor.onDidChangeCursorPosition(() => {
					lastKnownEditorViewState = withNullAsUndefined(editor$1.saveViewState());
				}));
				context.restoreViewState = () => {
					if (lastKnownEditorViewState && editor$1 === this.activeTextEditorControl) editor$1.restoreViewState(lastKnownEditorViewState);
				};
				disposables.add(once(token.onCancellationRequested)(() => {
					var _a$5;
					return (_a$5 = context.restoreViewState) === null || _a$5 === void 0 ? void 0 : _a$5.call(context);
				}));
			}
			disposables.add(toDisposable(() => this.clearDecorations(editor$1)));
			disposables.add(this.provideWithTextEditor(context, picker, token));
		} else disposables.add(this.provideWithoutTextEditor(picker, token));
		return disposables;
	}
	/**
	* Subclasses to implement if they can operate on the text editor.
	*/
	canProvideWithTextEditor(editor$1) {
		return true;
	}
	gotoLocation({ editor: editor$1 }, options) {
		editor$1.setSelection(options.range);
		editor$1.revealRangeInCenter(options.range, 0);
		if (!options.preserveFocus) editor$1.focus();
	}
	getModel(editor$1) {
		var _a$5;
		return isDiffEditor(editor$1) ? (_a$5 = editor$1.getModel()) === null || _a$5 === void 0 ? void 0 : _a$5.modified : editor$1.getModel();
	}
	addDecorations(editor$1, range) {
		editor$1.changeDecorations((changeAccessor) => {
			const deleteDecorations = [];
			if (this.rangeHighlightDecorationId) {
				deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
				deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
				this.rangeHighlightDecorationId = void 0;
			}
			const newDecorations = [{
				range,
				options: {
					description: "quick-access-range-highlight",
					className: "rangeHighlight",
					isWholeLine: true
				}
			}, {
				range,
				options: {
					description: "quick-access-range-highlight-overview",
					overviewRuler: {
						color: themeColorFromId(overviewRulerRangeHighlight),
						position: OverviewRulerLane.Full
					}
				}
			}];
			const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
			this.rangeHighlightDecorationId = {
				rangeHighlightId,
				overviewRulerDecorationId
			};
		});
	}
	clearDecorations(editor$1) {
		const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
		if (rangeHighlightDecorationId) {
			editor$1.changeDecorations((changeAccessor) => {
				changeAccessor.deltaDecorations([rangeHighlightDecorationId.overviewRulerDecorationId, rangeHighlightDecorationId.rangeHighlightId], []);
			});
			this.rangeHighlightDecorationId = void 0;
		}
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js
var AbstractGotoLineQuickAccessProvider = class AbstractGotoLineQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
	constructor() {
		super({ canAcceptInBackground: true });
	}
	provideWithoutTextEditor(picker) {
		const label = localize("cannotRunGotoLine", "Open a text editor first to go to a line.");
		picker.items = [{ label }];
		picker.ariaLabel = label;
		return Disposable.None;
	}
	provideWithTextEditor(context, picker, token) {
		const editor$1 = context.editor;
		const disposables = new DisposableStore();
		disposables.add(picker.onDidAccept((event) => {
			const [item] = picker.selectedItems;
			if (item) {
				if (!this.isValidLineNumber(editor$1, item.lineNumber)) return;
				this.gotoLocation(context, {
					range: this.toRange(item.lineNumber, item.column),
					keyMods: picker.keyMods,
					preserveFocus: event.inBackground
				});
				if (!event.inBackground) picker.hide();
			}
		}));
		const updatePickerAndEditor = () => {
			const position = this.parsePosition(editor$1, picker.value.trim().substr(AbstractGotoLineQuickAccessProvider.PREFIX.length));
			const label = this.getPickLabel(editor$1, position.lineNumber, position.column);
			picker.items = [{
				lineNumber: position.lineNumber,
				column: position.column,
				label
			}];
			picker.ariaLabel = label;
			if (!this.isValidLineNumber(editor$1, position.lineNumber)) {
				this.clearDecorations(editor$1);
				return;
			}
			const range = this.toRange(position.lineNumber, position.column);
			editor$1.revealRangeInCenter(range, 0);
			this.addDecorations(editor$1, range);
		};
		updatePickerAndEditor();
		disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
		const codeEditor = getCodeEditor(editor$1);
		if (codeEditor) {
			if (codeEditor.getOptions().get(62).renderType === 2) {
				codeEditor.updateOptions({ lineNumbers: "on" });
				disposables.add(toDisposable(() => codeEditor.updateOptions({ lineNumbers: "relative" })));
			}
		}
		return disposables;
	}
	toRange(lineNumber = 1, column = 1) {
		return {
			startLineNumber: lineNumber,
			startColumn: column,
			endLineNumber: lineNumber,
			endColumn: column
		};
	}
	parsePosition(editor$1, value) {
		const numbers = value.split(/,|:|#/).map((part) => parseInt(part, 10)).filter((part) => !isNaN(part));
		const endLine = this.lineCount(editor$1) + 1;
		return {
			lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
			column: numbers[1]
		};
	}
	getPickLabel(editor$1, lineNumber, column) {
		if (this.isValidLineNumber(editor$1, lineNumber)) {
			if (this.isValidColumn(editor$1, lineNumber, column)) return localize("gotoLineColumnLabel", "Go to line {0} and character {1}.", lineNumber, column);
			return localize("gotoLineLabel", "Go to line {0}.", lineNumber);
		}
		const position = editor$1.getPosition() || {
			lineNumber: 1,
			column: 1
		};
		const lineCount = this.lineCount(editor$1);
		if (lineCount > 1) return localize("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
		return localize("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
	}
	isValidLineNumber(editor$1, lineNumber) {
		if (!lineNumber || typeof lineNumber !== "number") return false;
		return lineNumber > 0 && lineNumber <= this.lineCount(editor$1);
	}
	isValidColumn(editor$1, lineNumber, column) {
		if (!column || typeof column !== "number") return false;
		const model = this.getModel(editor$1);
		if (!model) return false;
		const positionCandidate = {
			lineNumber,
			column
		};
		return model.validatePosition(positionCandidate).equals(positionCandidate);
	}
	lineCount(editor$1) {
		var _a$5, _b$1;
		return (_b$1 = (_a$5 = this.getModel(editor$1)) === null || _a$5 === void 0 ? void 0 : _a$5.getLineCount()) !== null && _b$1 !== void 0 ? _b$1 : 0;
	}
};
AbstractGotoLineQuickAccessProvider.PREFIX = ":";

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js
var __decorate$5 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$5 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var StandaloneGotoLineQuickAccessProvider = class StandaloneGotoLineQuickAccessProvider$1 extends AbstractGotoLineQuickAccessProvider {
	constructor(editorService) {
		super();
		this.editorService = editorService;
		this.onDidActiveTextEditorControlChange = Event.None;
	}
	get activeTextEditorControl() {
		return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
	}
};
StandaloneGotoLineQuickAccessProvider = __decorate$5([__param$5(0, ICodeEditorService)], StandaloneGotoLineQuickAccessProvider);
var GotoLineAction$1 = class GotoLineAction$1 extends EditorAction {
	constructor() {
		super({
			id: GotoLineAction$1.ID,
			label: GoToLineNLS.gotoLineActionLabel,
			alias: "Go to Line/Column...",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 2085,
				mac: { primary: 293 },
				weight: 100
			}
		});
	}
	run(accessor) {
		accessor.get(IQuickInputService).quickAccess.show(StandaloneGotoLineQuickAccessProvider.PREFIX);
	}
};
GotoLineAction$1.ID = "editor.action.gotoLine";
registerEditorAction(GotoLineAction$1);
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
	ctor: StandaloneGotoLineQuickAccessProvider,
	prefix: StandaloneGotoLineQuickAccessProvider.PREFIX,
	helpEntries: [{
		description: GoToLineNLS.gotoLineActionLabel,
		commandId: GotoLineAction$1.ID
	}]
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js
var NO_SCORE2 = [void 0, []];
function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
	const preparedQuery = query;
	if (preparedQuery.values && preparedQuery.values.length > 1) return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);
	return doScoreFuzzy2Single(target, query, patternStart, wordStart);
}
function doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {
	let totalScore = 0;
	const totalMatches = [];
	for (const queryPiece of query) {
		const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);
		if (typeof score !== "number") return NO_SCORE2;
		totalScore += score;
		totalMatches.push(...matches);
	}
	return [totalScore, normalizeMatches(totalMatches)];
}
function doScoreFuzzy2Single(target, query, patternStart, wordStart) {
	const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, {
		firstMatchCanBeWeak: true,
		boostFullMatch: true
	});
	if (!score) return NO_SCORE2;
	return [score[0], createMatches(score)];
}
Object.freeze({ score: 0 });
function normalizeMatches(matches) {
	const sortedMatches = matches.sort((matchA, matchB) => {
		return matchA.start - matchB.start;
	});
	const normalizedMatches = [];
	let currentMatch = void 0;
	for (const match of sortedMatches) if (!currentMatch || !matchOverlaps(currentMatch, match)) {
		currentMatch = match;
		normalizedMatches.push(match);
	} else {
		currentMatch.start = Math.min(currentMatch.start, match.start);
		currentMatch.end = Math.max(currentMatch.end, match.end);
	}
	return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
	if (matchA.end < matchB.start) return false;
	if (matchB.end < matchA.start) return false;
	return true;
}
function queryExpectsExactMatch(query) {
	return query.startsWith("\"") && query.endsWith("\"");
}
/**
* Helper function to prepare a search value for scoring by removing unwanted characters
* and allowing to score on multiple pieces separated by whitespace character.
*/
var MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
function prepareQuery(original) {
	if (typeof original !== "string") original = "";
	const originalLowercase = original.toLowerCase();
	const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);
	const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;
	const expectExactMatch = queryExpectsExactMatch(original);
	let values = void 0;
	const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
	if (originalSplit.length > 1) for (const originalPiece of originalSplit) {
		const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);
		const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);
		if (normalizedPiece) {
			if (!values) values = [];
			values.push({
				original: originalPiece,
				originalLowercase: originalPiece.toLowerCase(),
				pathNormalized: pathNormalizedPiece,
				normalized: normalizedPiece,
				normalizedLowercase: normalizedLowercasePiece,
				expectContiguousMatch: expectExactMatchPiece
			});
		}
	}
	return {
		original,
		originalLowercase,
		pathNormalized,
		normalized,
		normalizedLowercase,
		values,
		containsPathSeparator,
		expectContiguousMatch: expectExactMatch
	};
}
function normalizeQuery(original) {
	let pathNormalized;
	if (isWindows) pathNormalized = original.replace(/\//g, sep);
	else pathNormalized = original.replace(/\\/g, sep);
	const normalized = stripWildcards(pathNormalized).replace(/\s|"/g, "");
	return {
		pathNormalized,
		normalized,
		normalizedLowercase: normalized.toLowerCase()
	};
}
function pieceToQuery(arg1) {
	if (Array.isArray(arg1)) return prepareQuery(arg1.map((piece) => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));
	return prepareQuery(arg1.original);
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js
var __decorate$4 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$4 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$3 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider$1 extends AbstractEditorNavigationQuickAccessProvider {
	constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {
		super(options);
		this._languageFeaturesService = _languageFeaturesService;
		this._outlineModelService = _outlineModelService;
		this.options = options;
		this.options.canAcceptInBackground = true;
	}
	provideWithoutTextEditor(picker) {
		this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information."));
		return Disposable.None;
	}
	provideWithTextEditor(context, picker, token) {
		const editor$1 = context.editor;
		const model = this.getModel(editor$1);
		if (!model) return Disposable.None;
		if (this._languageFeaturesService.documentSymbolProvider.has(model)) return this.doProvideWithEditorSymbols(context, model, picker, token);
		return this.doProvideWithoutEditorSymbols(context, model, picker, token);
	}
	doProvideWithoutEditorSymbols(context, model, picker, token) {
		const disposables = new DisposableStore();
		this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information."));
		__awaiter$3(this, void 0, void 0, function* () {
			if (!(yield this.waitForLanguageSymbolRegistry(model, disposables)) || token.isCancellationRequested) return;
			disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
		});
		return disposables;
	}
	provideLabelPick(picker, label) {
		picker.items = [{
			label,
			index: 0,
			kind: 14
		}];
		picker.ariaLabel = label;
	}
	waitForLanguageSymbolRegistry(model, disposables) {
		return __awaiter$3(this, void 0, void 0, function* () {
			if (this._languageFeaturesService.documentSymbolProvider.has(model)) return true;
			const symbolProviderRegistryPromise = new DeferredPromise();
			const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
				if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
					symbolProviderListener.dispose();
					symbolProviderRegistryPromise.complete(true);
				}
			}));
			disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));
			return symbolProviderRegistryPromise.p;
		});
	}
	doProvideWithEditorSymbols(context, model, picker, token) {
		var _a$5;
		const editor$1 = context.editor;
		const disposables = new DisposableStore();
		disposables.add(picker.onDidAccept((event) => {
			const [item] = picker.selectedItems;
			if (item && item.range) {
				this.gotoLocation(context, {
					range: item.range.selection,
					keyMods: picker.keyMods,
					preserveFocus: event.inBackground
				});
				if (!event.inBackground) picker.hide();
			}
		}));
		disposables.add(picker.onDidTriggerItemButton(({ item }) => {
			if (item && item.range) {
				this.gotoLocation(context, {
					range: item.range.selection,
					keyMods: picker.keyMods,
					forceSideBySide: true
				});
				picker.hide();
			}
		}));
		const symbolsPromise = this.getDocumentSymbols(model, token);
		let picksCts = void 0;
		const updatePickerItems = (positionToEnclose) => __awaiter$3(this, void 0, void 0, function* () {
			picksCts === null || picksCts === void 0 || picksCts.dispose(true);
			picker.busy = false;
			picksCts = new CancellationTokenSource$1(token);
			picker.busy = true;
			try {
				const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider$1.PREFIX.length).trim());
				const items = yield this.doGetSymbolPicks(symbolsPromise, query, void 0, picksCts.token);
				if (token.isCancellationRequested) return;
				if (items.length > 0) {
					picker.items = items;
					if (positionToEnclose && query.original.length === 0) {
						const candidate = findLast(items, (item) => Boolean(item.type !== "separator" && item.range && Range$1.containsPosition(item.range.decoration, positionToEnclose)));
						if (candidate) picker.activeItems = [candidate];
					}
				} else if (query.original.length > 0) this.provideLabelPick(picker, localize("noMatchingSymbolResults", "No matching editor symbols"));
				else this.provideLabelPick(picker, localize("noSymbolResults", "No editor symbols"));
			} finally {
				if (!token.isCancellationRequested) picker.busy = false;
			}
		});
		disposables.add(picker.onDidChangeValue(() => updatePickerItems(void 0)));
		updatePickerItems((_a$5 = editor$1.getSelection()) === null || _a$5 === void 0 ? void 0 : _a$5.getPosition());
		let ignoreFirstActiveEvent = 2;
		disposables.add(picker.onDidChangeActive(() => {
			const [item] = picker.activeItems;
			if (item && item.range) {
				if (ignoreFirstActiveEvent-- > 0) return;
				editor$1.revealRangeInCenter(item.range.selection, 0);
				this.addDecorations(editor$1, item.range.decoration);
			}
		}));
		return disposables;
	}
	doGetSymbolPicks(symbolsPromise, query, options, token) {
		return __awaiter$3(this, void 0, void 0, function* () {
			const symbols = yield symbolsPromise;
			if (token.isCancellationRequested) return [];
			const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider$1.SCOPE_PREFIX) === 0;
			const filterPos = filterBySymbolKind ? 1 : 0;
			let symbolQuery;
			let containerQuery;
			if (query.values && query.values.length > 1) {
				symbolQuery = pieceToQuery(query.values[0]);
				containerQuery = pieceToQuery(query.values.slice(1));
			} else symbolQuery = query;
			const filteredSymbolPicks = [];
			for (let index = 0; index < symbols.length; index++) {
				const symbol = symbols[index];
				const symbolLabel = trim(symbol.name);
				const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;
				const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
				let containerLabel = symbol.containerName;
				if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) if (containerLabel) containerLabel = `${options.extraContainerLabel}  ${containerLabel}`;
				else containerLabel = options.extraContainerLabel;
				let symbolScore = void 0;
				let symbolMatches = void 0;
				let containerScore = void 0;
				let containerMatches = void 0;
				if (query.original.length > filterPos) {
					let skipContainerQuery = false;
					if (symbolQuery !== query) {
						[symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: void 0 }), filterPos, symbolLabelIconOffset);
						if (typeof symbolScore === "number") skipContainerQuery = true;
					}
					if (typeof symbolScore !== "number") {
						[symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
						if (typeof symbolScore !== "number") continue;
					}
					if (!skipContainerQuery && containerQuery) {
						if (containerLabel && containerQuery.original.length > 0) [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
						if (typeof containerScore !== "number") continue;
						if (typeof symbolScore === "number") symbolScore += containerScore;
					}
				}
				const deprecated = symbol.tags && symbol.tags.indexOf(1) >= 0;
				filteredSymbolPicks.push({
					index,
					kind: symbol.kind,
					score: symbolScore,
					label: symbolLabelWithIcon,
					ariaLabel: symbolLabel,
					description: containerLabel,
					highlights: deprecated ? void 0 : {
						label: symbolMatches,
						description: containerMatches
					},
					range: {
						selection: Range$1.collapseToStart(symbol.selectionRange),
						decoration: symbol.range
					},
					strikethrough: deprecated,
					buttons: (() => {
						var _a$5, _b$1;
						const openSideBySideDirection = ((_a$5 = this.options) === null || _a$5 === void 0 ? void 0 : _a$5.openSideBySideDirection) ? (_b$1 = this.options) === null || _b$1 === void 0 ? void 0 : _b$1.openSideBySideDirection() : void 0;
						if (!openSideBySideDirection) return;
						return [{
							iconClass: openSideBySideDirection === "right" ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,
							tooltip: openSideBySideDirection === "right" ? localize("openToSide", "Open to the Side") : localize("openToBottom", "Open to the Bottom")
						}];
					})()
				});
			}
			const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));
			let symbolPicks = [];
			if (filterBySymbolKind) {
				let lastSymbolKind = void 0;
				let lastSeparator = void 0;
				let lastSymbolKindCounter = 0;
				function updateLastSeparatorLabel() {
					if (lastSeparator && typeof lastSymbolKind === "number" && lastSymbolKindCounter > 0) lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
				}
				for (const symbolPick of sortedFilteredSymbolPicks) {
					if (lastSymbolKind !== symbolPick.kind) {
						updateLastSeparatorLabel();
						lastSymbolKind = symbolPick.kind;
						lastSymbolKindCounter = 1;
						lastSeparator = { type: "separator" };
						symbolPicks.push(lastSeparator);
					} else lastSymbolKindCounter++;
					symbolPicks.push(symbolPick);
				}
				updateLastSeparatorLabel();
			} else if (sortedFilteredSymbolPicks.length > 0) symbolPicks = [{
				label: localize("symbols", "symbols ({0})", filteredSymbolPicks.length),
				type: "separator"
			}, ...sortedFilteredSymbolPicks];
			return symbolPicks;
		});
	}
	compareByScore(symbolA, symbolB) {
		if (typeof symbolA.score !== "number" && typeof symbolB.score === "number") return 1;
		else if (typeof symbolA.score === "number" && typeof symbolB.score !== "number") return -1;
		if (typeof symbolA.score === "number" && typeof symbolB.score === "number") {
			if (symbolA.score > symbolB.score) return -1;
			else if (symbolA.score < symbolB.score) return 1;
		}
		if (symbolA.index < symbolB.index) return -1;
		else if (symbolA.index > symbolB.index) return 1;
		return 0;
	}
	compareByKindAndScore(symbolA, symbolB) {
		const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
		const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
		const result = kindA.localeCompare(kindB);
		if (result === 0) return this.compareByScore(symbolA, symbolB);
		return result;
	}
	getDocumentSymbols(document$1, token) {
		return __awaiter$3(this, void 0, void 0, function* () {
			const model = yield this._outlineModelService.getOrCreate(document$1, token);
			return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
		});
	}
};
AbstractGotoSymbolQuickAccessProvider.PREFIX = "@";
AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ":";
AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;
AbstractGotoSymbolQuickAccessProvider = __decorate$4([__param$4(0, ILanguageFeaturesService), __param$4(1, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);
var FALLBACK_NLS_SYMBOL_KIND = localize("property", "properties ({0})");
var NLS_SYMBOL_KIND_CACHE = {
	[5]: localize("method", "methods ({0})"),
	[11]: localize("function", "functions ({0})"),
	[8]: localize("_constructor", "constructors ({0})"),
	[12]: localize("variable", "variables ({0})"),
	[4]: localize("class", "classes ({0})"),
	[22]: localize("struct", "structs ({0})"),
	[23]: localize("event", "events ({0})"),
	[24]: localize("operator", "operators ({0})"),
	[10]: localize("interface", "interfaces ({0})"),
	[2]: localize("namespace", "namespaces ({0})"),
	[3]: localize("package", "packages ({0})"),
	[25]: localize("typeParameter", "type parameters ({0})"),
	[1]: localize("modules", "modules ({0})"),
	[6]: localize("property", "properties ({0})"),
	[9]: localize("enum", "enumerations ({0})"),
	[21]: localize("enumMember", "enumeration members ({0})"),
	[14]: localize("string", "strings ({0})"),
	[0]: localize("file", "files ({0})"),
	[17]: localize("array", "arrays ({0})"),
	[15]: localize("number", "numbers ({0})"),
	[16]: localize("boolean", "booleans ({0})"),
	[18]: localize("object", "objects ({0})"),
	[19]: localize("key", "keys ({0})"),
	[7]: localize("field", "fields ({0})"),
	[13]: localize("constant", "constants ({0})")
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js
var __decorate$3 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$3 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider$1 extends AbstractGotoSymbolQuickAccessProvider {
	constructor(editorService, languageFeaturesService, outlineModelService) {
		super(languageFeaturesService, outlineModelService);
		this.editorService = editorService;
		this.onDidActiveTextEditorControlChange = Event.None;
	}
	get activeTextEditorControl() {
		return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
	}
};
StandaloneGotoSymbolQuickAccessProvider = __decorate$3([
	__param$3(0, ICodeEditorService),
	__param$3(1, ILanguageFeaturesService),
	__param$3(2, IOutlineModelService)
], StandaloneGotoSymbolQuickAccessProvider);
var GotoSymbolAction = class GotoSymbolAction extends EditorAction {
	constructor() {
		super({
			id: GotoSymbolAction.ID,
			label: QuickOutlineNLS.quickOutlineActionLabel,
			alias: "Go to Symbol...",
			precondition: EditorContextKeys.hasDocumentSymbolProvider,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 3117,
				weight: 100
			},
			contextMenuOpts: {
				group: "navigation",
				order: 3
			}
		});
	}
	run(accessor) {
		accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX);
	}
};
GotoSymbolAction.ID = "editor.action.quickOutline";
registerEditorAction(GotoSymbolAction);
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
	ctor: StandaloneGotoSymbolQuickAccessProvider,
	prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
	helpEntries: [{
		description: QuickOutlineNLS.quickOutlineActionLabel,
		prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
		commandId: GotoSymbolAction.ID
	}, {
		description: QuickOutlineNLS.quickOutlineByCategoryActionLabel,
		prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY
	}]
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
function exceptionToErrorMessage(exception, verbose) {
	if (verbose && (exception.stack || exception.stacktrace)) return localize("stackTrace.format", "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
	return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
	if (Array.isArray(stack)) return stack.join("\n");
	return stack;
}
function detectSystemErrorMessage(exception) {
	if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") return localize("nodeExceptionMessage", "A system error occurred ({0})", exception.message);
	return exception.message || localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
/**
* Tries to generate a human readable error message out of the error. If the verbose parameter
* is set to true, the error message will include stacktrace details if provided.
*
* @returns A string containing the error message.
*/
function toErrorMessage(error = null, verbose = false) {
	if (!error) return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
	if (Array.isArray(error)) {
		const errors = coalesce(error);
		const msg = toErrorMessage(errors[0], verbose);
		if (errors.length > 1) return localize("error.moreErrors", "{0} ({1} errors in total)", msg, errors.length);
		return msg;
	}
	if (isString(error)) return error;
	if (error.detail) {
		const detail = error.detail;
		if (detail.error) return exceptionToErrorMessage(detail.error, verbose);
		if (detail.exception) return exceptionToErrorMessage(detail.exception, verbose);
	}
	if (error.stack) return exceptionToErrorMessage(error, verbose);
	if (error.message) return error.message;
	return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js
var __awaiter$2 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var TriggerAction;
(function(TriggerAction$1) {
	/**
	* Do nothing after the button was clicked.
	*/
	TriggerAction$1[TriggerAction$1["NO_ACTION"] = 0] = "NO_ACTION";
	/**
	* Close the picker.
	*/
	TriggerAction$1[TriggerAction$1["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
	/**
	* Update the results of the picker.
	*/
	TriggerAction$1[TriggerAction$1["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
	/**
	* Remove the item from the picker.
	*/
	TriggerAction$1[TriggerAction$1["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
})(TriggerAction || (TriggerAction = {}));
function isPicksWithActive(obj) {
	const candidate = obj;
	return Array.isArray(candidate.items);
}
function isFastAndSlowPicks(obj) {
	const candidate = obj;
	return !!candidate.picks && candidate.additionalPicks instanceof Promise;
}
var PickerQuickAccessProvider = class PickerQuickAccessProvider extends Disposable {
	constructor(prefix, options) {
		super();
		this.prefix = prefix;
		this.options = options;
	}
	provide(picker, token) {
		var _a$5;
		const disposables = new DisposableStore();
		picker.canAcceptInBackground = !!((_a$5 = this.options) === null || _a$5 === void 0 ? void 0 : _a$5.canAcceptInBackground);
		picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
		let picksCts = void 0;
		const picksDisposable = disposables.add(new MutableDisposable());
		const updatePickerItems = () => __awaiter$2(this, void 0, void 0, function* () {
			const picksDisposables = picksDisposable.value = new DisposableStore();
			picksCts === null || picksCts === void 0 || picksCts.dispose(true);
			picker.busy = false;
			picksCts = new CancellationTokenSource$1(token);
			const picksToken = picksCts.token;
			const picksFilter = picker.value.substr(this.prefix.length).trim();
			const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken);
			const applyPicks = (picks, skipEmpty) => {
				var _a$6;
				let items;
				let activeItem = void 0;
				if (isPicksWithActive(picks)) {
					items = picks.items;
					activeItem = picks.active;
				} else items = picks;
				if (items.length === 0) {
					if (skipEmpty) return false;
					if (picksFilter.length > 0 && ((_a$6 = this.options) === null || _a$6 === void 0 ? void 0 : _a$6.noResultsPick)) items = [this.options.noResultsPick];
				}
				picker.items = items;
				if (activeItem) picker.activeItems = [activeItem];
				return true;
			};
			if (providedPicks === null) {} else if (isFastAndSlowPicks(providedPicks)) {
				let fastPicksApplied = false;
				let slowPicksApplied = false;
				yield Promise.all([(() => __awaiter$2(this, void 0, void 0, function* () {
					yield timeout(PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);
					if (picksToken.isCancellationRequested) return;
					if (!slowPicksApplied) fastPicksApplied = applyPicks(providedPicks.picks, true);
				}))(), (() => __awaiter$2(this, void 0, void 0, function* () {
					picker.busy = true;
					try {
						const awaitedAdditionalPicks = yield providedPicks.additionalPicks;
						if (picksToken.isCancellationRequested) return;
						let picks;
						let activePick = void 0;
						if (isPicksWithActive(providedPicks.picks)) {
							picks = providedPicks.picks.items;
							activePick = providedPicks.picks.active;
						} else picks = providedPicks.picks;
						let additionalPicks;
						let additionalActivePick = void 0;
						if (isPicksWithActive(awaitedAdditionalPicks)) {
							additionalPicks = awaitedAdditionalPicks.items;
							additionalActivePick = awaitedAdditionalPicks.active;
						} else additionalPicks = awaitedAdditionalPicks;
						if (additionalPicks.length > 0 || !fastPicksApplied) {
							let fallbackActivePick = void 0;
							if (!activePick && !additionalActivePick) {
								const fallbackActivePickCandidate = picker.activeItems[0];
								if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) fallbackActivePick = fallbackActivePickCandidate;
							}
							applyPicks({
								items: [...picks, ...additionalPicks],
								active: activePick || additionalActivePick || fallbackActivePick
							});
						}
					} finally {
						if (!picksToken.isCancellationRequested) picker.busy = false;
						slowPicksApplied = true;
					}
				}))()]);
			} else if (!(providedPicks instanceof Promise)) applyPicks(providedPicks);
			else {
				picker.busy = true;
				try {
					const awaitedPicks = yield providedPicks;
					if (picksToken.isCancellationRequested) return;
					applyPicks(awaitedPicks);
				} finally {
					if (!picksToken.isCancellationRequested) picker.busy = false;
				}
			}
		});
		disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
		updatePickerItems();
		disposables.add(picker.onDidAccept((event) => {
			const [item] = picker.selectedItems;
			if (typeof (item === null || item === void 0 ? void 0 : item.accept) === "function") {
				if (!event.inBackground) picker.hide();
				item.accept(picker.keyMods, event);
			}
		}));
		disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter$2(this, void 0, void 0, function* () {
			var _b$1, _c$1;
			if (typeof item.trigger === "function") {
				const buttonIndex = (_c$1 = (_b$1 = item.buttons) === null || _b$1 === void 0 ? void 0 : _b$1.indexOf(button)) !== null && _c$1 !== void 0 ? _c$1 : -1;
				if (buttonIndex >= 0) {
					const result = item.trigger(buttonIndex, picker.keyMods);
					const action = typeof result === "number" ? result : yield result;
					if (token.isCancellationRequested) return;
					switch (action) {
						case TriggerAction.NO_ACTION: break;
						case TriggerAction.CLOSE_PICKER:
							picker.hide();
							break;
						case TriggerAction.REFRESH_PICKER:
							updatePickerItems();
							break;
						case TriggerAction.REMOVE_ITEM: {
							const index = picker.items.indexOf(item);
							if (index !== -1) {
								const items = picker.items.slice();
								const removed = items.splice(index, 1);
								const activeItems = picker.activeItems.filter((activeItem) => activeItem !== removed[0]);
								const keepScrollPositionBefore = picker.keepScrollPosition;
								picker.keepScrollPosition = true;
								picker.items = items;
								if (activeItems) picker.activeItems = activeItems;
								picker.keepScrollPosition = keepScrollPositionBefore;
							}
							break;
						}
					}
				}
			}
		})));
		return disposables;
	}
};
PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200;

//#endregion
//#region node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
var __decorate$2 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$2 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter$1 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider$1 extends PickerQuickAccessProvider {
	constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
		super(AbstractCommandsQuickAccessProvider$1.PREFIX, options);
		this.instantiationService = instantiationService;
		this.keybindingService = keybindingService;
		this.commandService = commandService;
		this.telemetryService = telemetryService;
		this.dialogService = dialogService;
		this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));
		this.options = options;
	}
	_getPicks(filter, disposables, token) {
		return __awaiter$1(this, void 0, void 0, function* () {
			const allCommandPicks = yield this.getCommandPicks(disposables, token);
			if (token.isCancellationRequested) return [];
			const filteredCommandPicks = [];
			for (const commandPick of allCommandPicks) {
				const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider$1.WORD_FILTER(filter, commandPick.label));
				const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider$1.WORD_FILTER(filter, commandPick.commandAlias)) : void 0;
				if (labelHighlights || aliasHighlights) {
					commandPick.highlights = {
						label: labelHighlights,
						detail: this.options.showAlias ? aliasHighlights : void 0
					};
					filteredCommandPicks.push(commandPick);
				} else if (filter === commandPick.commandId) filteredCommandPicks.push(commandPick);
			}
			const mapLabelToCommand = /* @__PURE__ */ new Map();
			for (const commandPick of filteredCommandPicks) {
				const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
				if (existingCommandForLabel) {
					commandPick.description = commandPick.commandId;
					existingCommandForLabel.description = existingCommandForLabel.commandId;
				} else mapLabelToCommand.set(commandPick.label, commandPick);
			}
			filteredCommandPicks.sort((commandPickA, commandPickB) => {
				const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
				const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
				if (commandACounter && commandBCounter) return commandACounter > commandBCounter ? -1 : 1;
				if (commandACounter) return -1;
				if (commandBCounter) return 1;
				return commandPickA.label.localeCompare(commandPickB.label);
			});
			const commandPicks = [];
			let addSeparator = false;
			for (let i = 0; i < filteredCommandPicks.length; i++) {
				const commandPick = filteredCommandPicks[i];
				const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
				const ariaLabel = keybinding ? localize("commandPickAriaLabelWithKeybinding", "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;
				if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {
					commandPicks.push({
						type: "separator",
						label: localize("recentlyUsed", "recently used")
					});
					addSeparator = true;
				}
				if (i !== 0 && addSeparator && !this.commandsHistory.peek(commandPick.commandId)) {
					commandPicks.push({
						type: "separator",
						label: localize("morecCommands", "other commands")
					});
					addSeparator = false;
				}
				commandPicks.push(Object.assign(Object.assign({}, commandPick), {
					ariaLabel,
					detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : void 0,
					keybinding,
					accept: () => __awaiter$1(this, void 0, void 0, function* () {
						this.commandsHistory.push(commandPick.commandId);
						this.telemetryService.publicLog2("workbenchActionExecuted", {
							id: commandPick.commandId,
							from: "quick open"
						});
						try {
							yield this.commandService.executeCommand(commandPick.commandId);
						} catch (error) {
							if (!isCancellationError(error)) this.dialogService.show(severity_default.Error, localize("canNotRun", "Command '{0}' resulted in an error ({1})", commandPick.label, toErrorMessage(error)));
						}
					})
				}));
			}
			return commandPicks;
		});
	}
};
AbstractCommandsQuickAccessProvider.PREFIX = ">";
AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);
AbstractCommandsQuickAccessProvider = __decorate$2([
	__param$2(1, IInstantiationService),
	__param$2(2, IKeybindingService),
	__param$2(3, ICommandService),
	__param$2(4, ITelemetryService),
	__param$2(5, IDialogService)
], AbstractCommandsQuickAccessProvider);
var CommandsHistory = class CommandsHistory$1 extends Disposable {
	constructor(storageService, configurationService) {
		super();
		this.storageService = storageService;
		this.configurationService = configurationService;
		this.configuredCommandsHistoryLength = 0;
		this.updateConfiguration();
		this.load();
		this.registerListeners();
	}
	registerListeners() {
		this._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));
	}
	updateConfiguration() {
		this.configuredCommandsHistoryLength = CommandsHistory$1.getConfiguredCommandHistoryLength(this.configurationService);
		if (CommandsHistory$1.cache && CommandsHistory$1.cache.limit !== this.configuredCommandsHistoryLength) {
			CommandsHistory$1.cache.limit = this.configuredCommandsHistoryLength;
			CommandsHistory$1.saveState(this.storageService);
		}
	}
	load() {
		const raw = this.storageService.get(CommandsHistory$1.PREF_KEY_CACHE, 0);
		let serializedCache;
		if (raw) try {
			serializedCache = JSON.parse(raw);
		} catch (error) {}
		const cache = CommandsHistory$1.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
		if (serializedCache) {
			let entries;
			if (serializedCache.usesLRU) entries = serializedCache.entries;
			else entries = serializedCache.entries.sort((a, b) => a.value - b.value);
			entries.forEach((entry) => cache.set(entry.key, entry.value));
		}
		CommandsHistory$1.counter = this.storageService.getNumber(CommandsHistory$1.PREF_KEY_COUNTER, 0, CommandsHistory$1.counter);
	}
	push(commandId) {
		if (!CommandsHistory$1.cache) return;
		CommandsHistory$1.cache.set(commandId, CommandsHistory$1.counter++);
		CommandsHistory$1.saveState(this.storageService);
	}
	peek(commandId) {
		var _a$5;
		return (_a$5 = CommandsHistory$1.cache) === null || _a$5 === void 0 ? void 0 : _a$5.peek(commandId);
	}
	static saveState(storageService) {
		if (!CommandsHistory$1.cache) return;
		const serializedCache = {
			usesLRU: true,
			entries: []
		};
		CommandsHistory$1.cache.forEach((value, key) => serializedCache.entries.push({
			key,
			value
		}));
		storageService.store(CommandsHistory$1.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0, 0);
		storageService.store(CommandsHistory$1.PREF_KEY_COUNTER, CommandsHistory$1.counter, 0, 0);
	}
	static getConfiguredCommandHistoryLength(configurationService) {
		var _a$5, _b$1;
		const configuredCommandHistoryLength = (_b$1 = (_a$5 = configurationService.getValue().workbench) === null || _a$5 === void 0 ? void 0 : _a$5.commandPalette) === null || _b$1 === void 0 ? void 0 : _b$1.history;
		if (typeof configuredCommandHistoryLength === "number") return configuredCommandHistoryLength;
		return CommandsHistory$1.DEFAULT_COMMANDS_HISTORY_LENGTH;
	}
};
CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
CommandsHistory.PREF_KEY_CACHE = "commandPalette.mru.cache";
CommandsHistory.PREF_KEY_COUNTER = "commandPalette.mru.counter";
CommandsHistory.counter = 1;
CommandsHistory = __decorate$2([__param$2(0, IStorageService), __param$2(1, IConfigurationService)], CommandsHistory);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js
var AbstractEditorCommandsQuickAccessProvider = class extends AbstractCommandsQuickAccessProvider {
	constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
		super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);
	}
	getCodeEditorCommandPicks() {
		const activeTextEditorControl = this.activeTextEditorControl;
		if (!activeTextEditorControl) return [];
		const editorCommandPicks = [];
		for (const editorAction of activeTextEditorControl.getSupportedActions()) editorCommandPicks.push({
			commandId: editorAction.id,
			commandAlias: editorAction.alias,
			label: stripIcons(editorAction.label) || editorAction.id
		});
		return editorCommandPicks;
	}
};

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
var __decorate$1 = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$1 = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var __awaiter = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider$1 extends AbstractEditorCommandsQuickAccessProvider {
	constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, dialogService) {
		super({ showAlias: false }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
		this.codeEditorService = codeEditorService;
	}
	get activeTextEditorControl() {
		return withNullAsUndefined(this.codeEditorService.getFocusedCodeEditor());
	}
	getCommandPicks() {
		return __awaiter(this, void 0, void 0, function* () {
			return this.getCodeEditorCommandPicks();
		});
	}
};
StandaloneCommandsQuickAccessProvider = __decorate$1([
	__param$1(0, IInstantiationService),
	__param$1(1, ICodeEditorService),
	__param$1(2, IKeybindingService),
	__param$1(3, ICommandService),
	__param$1(4, ITelemetryService),
	__param$1(5, IDialogService)
], StandaloneCommandsQuickAccessProvider);
var GotoLineAction = class GotoLineAction extends EditorAction {
	constructor() {
		super({
			id: GotoLineAction.ID,
			label: QuickCommandNLS.quickCommandActionLabel,
			alias: "Command Palette",
			precondition: void 0,
			kbOpts: {
				kbExpr: EditorContextKeys.focus,
				primary: 59,
				weight: 100
			},
			contextMenuOpts: {
				group: "z_commands",
				order: 1
			}
		});
	}
	run(accessor) {
		accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);
	}
};
GotoLineAction.ID = "editor.action.quickCommand";
registerEditorAction(GotoLineAction);
Registry.as(Extensions.Quickaccess).registerQuickAccessProvider({
	ctor: StandaloneCommandsQuickAccessProvider,
	prefix: StandaloneCommandsQuickAccessProvider.PREFIX,
	helpEntries: [{
		description: QuickCommandNLS.quickCommandHelp,
		commandId: GotoLineAction.ID
	}]
});

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js
var __decorate = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var StandaloneReferencesController = class StandaloneReferencesController$1 extends ReferencesController {
	constructor(editor$1, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
		super(true, editor$1, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
	}
};
StandaloneReferencesController = __decorate([
	__param(1, IContextKeyService),
	__param(2, ICodeEditorService),
	__param(3, INotificationService),
	__param(4, IInstantiationService),
	__param(5, IStorageService),
	__param(6, IConfigurationService)
], StandaloneReferencesController);
registerEditorContribution(ReferencesController.ID, StandaloneReferencesController);

//#endregion
//#region node_modules/monaco-editor/esm/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js
var ToggleHighContrast = class extends EditorAction {
	constructor() {
		super({
			id: "editor.action.toggleHighContrast",
			label: ToggleHighContrastNLS.toggleHighContrast,
			alias: "Toggle High Contrast Theme",
			precondition: void 0
		});
		this._originalThemeName = null;
	}
	run(accessor, editor$1) {
		const standaloneThemeService = accessor.get(IStandaloneThemeService);
		const currentTheme = standaloneThemeService.getColorTheme();
		if (isHighContrast(currentTheme.type)) {
			standaloneThemeService.setTheme(this._originalThemeName || (isDark(currentTheme.type) ? VS_DARK_THEME_NAME : VS_LIGHT_THEME_NAME));
			this._originalThemeName = null;
		} else {
			standaloneThemeService.setTheme(isDark(currentTheme.type) ? HC_BLACK_THEME_NAME : HC_LIGHT_THEME_NAME);
			this._originalThemeName = currentTheme.themeName;
		}
	}
};
registerEditorAction(ToggleHighContrast);

//#endregion
export { CancellationTokenSource, Emitter, KeyCode, KeyMod, MarkerSeverity, MarkerTag, Position, Range, Selection, SelectionDirection, Token, Uri, editor, languages };
//# sourceMappingURL=editor.main-BZ_so1NV.js.map