var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { provide, defineComponent, createApp, inject, onMounted, nextTick, watch, onBeforeUnmount, createVNode } from "vue";
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    var _a;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator$1.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index2++));
    }));
  });
}
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index2++) && subscriber.next(value);
    }));
  });
}
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
function throttle(durationSelector, config2) {
  return operate(function(source, subscriber) {
    var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration$ = timer(duration, scheduler);
  return throttle(function() {
    return duration$;
  }, config2);
}
class Utils {
  static matches(element, selectorName) {
    const proto = Element.prototype;
    const func = proto["matches"] || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(s) {
      const matches = (this.document || this.ownerDocument).querySelectorAll(s);
      let i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {
      }
      return i > -1;
    };
    return func.call(element, selectorName);
  }
  static addClass(elementRef, className) {
    if (className === void 0) {
      return;
    }
    const e = this.getElementWithValidClassList(elementRef);
    if (e) {
      e.classList.add(className);
    }
  }
  static removeClass(elementRef, className) {
    if (className === void 0) {
      return;
    }
    const e = this.getElementWithValidClassList(elementRef);
    if (e) {
      e.classList.remove(className);
    }
  }
  static getElementWithValidClassList(elementRef) {
    const e = elementRef.nativeElement ? elementRef.nativeElement : elementRef;
    if (e.classList !== void 0 && e.classList !== null) {
      return e;
    }
    return null;
  }
  static slice(args, slice, sliceEnd) {
    const ret = [];
    let len = args.length;
    if (len === 0) {
      return ret;
    }
    const start = slice < 0 ? Math.max(0, slice + len) : slice || 0;
    if (sliceEnd !== void 0) {
      len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
    }
    while (len-- > start) {
      ret[len - start] = args[len];
    }
    return ret;
  }
  static addElStyles(el, styles) {
    if (styles instanceof Object) {
      for (const s in styles) {
        if (Object.prototype.hasOwnProperty.call(styles, s)) {
          if (Array.isArray(styles[s])) {
            styles[s].forEach((val) => {
              el.style[s] = val;
            });
          } else {
            el.style[s] = styles[s];
          }
        }
      }
    }
  }
  static dispatchEventToUnderElement(event, target, eventType) {
    const up = target || event.target;
    up.style.display = "none";
    const { x, y } = { x: event.clientX, y: event.clientY };
    const under = document.elementFromPoint(x, y);
    up.style.display = "";
    if (!under) {
      return event;
    }
    const ev = document.createEvent("DragEvent");
    ev.initMouseEvent(
      eventType || event.type,
      true,
      true,
      window,
      0,
      event.screenX,
      event.screenY,
      event.clientX,
      event.clientY,
      event.ctrlKey,
      event.altKey,
      event.shiftKey,
      event.metaKey,
      event.button,
      event.relatedTarget
    );
    if (ev.dataTransfer !== null) {
      ev.dataTransfer.setData("text", "");
      ev.dataTransfer.effectAllowed = event.dataTransfer.effectAllowed;
    }
    setTimeout(() => {
      under.dispatchEvent(ev);
    }, 0);
    return event;
  }
}
function injectFromContext(token, context2) {
  return context2[token];
}
function provideToContext(token, value, context2) {
  context2[token] = value;
}
const _DragDropTouch = class {
  constructor() {
    this.lastClick = 0;
    this.touchstart = (e) => {
      if (this.shouldHandle(e)) {
        if (Date.now() - this.lastClick < _DragDropTouch.DBLCLICK) {
          if (this.dispatchEvent(e, "dblclick", e.target)) {
            e.preventDefault();
            this.reset();
            return;
          }
        }
        this.reset();
        const src = this.closestDraggable(e.target);
        if (src) {
          this.dragSource = src;
          this.ptDown = this.getPoint(e);
          this.lastTouch = e;
          if (_DragDropTouch.IS_PRESS_HOLD_MODE) {
            this.pressHoldInterval = setTimeout(() => {
              this.bindTouchmoveTouchend(e);
              this.isDragEnabled = true;
              this.touchmove(e);
            }, _DragDropTouch.PRESS_HOLD_AWAIT);
          } else {
            e.preventDefault();
            this.bindTouchmoveTouchend(e);
          }
        }
      }
    };
    this.touchmoveOnDocument = (e) => {
      if (this.shouldCancelPressHoldMove(e)) {
        this.reset();
        return;
      }
    };
    this.touchmove = (e) => {
      if (this.shouldCancelPressHoldMove(e)) {
        this.reset();
        return;
      }
      if (this.shouldHandleMove(e) || this.shouldHandlePressHoldMove(e)) {
        const target = this.getTarget(e);
        if (this.dragSource && !this.img && this.shouldStartDragging(e)) {
          this.dispatchEvent(e, "dragstart", this.dragSource);
          this.createImage(e);
        }
        if (this.img) {
          this.clearDragoverInterval();
          this.lastTouch = e;
          e.preventDefault();
          if (target !== this.lastTarget) {
            this.dispatchEvent(e, "dragenter", target);
            this.dispatchEvent(this.lastTouch, "dragleave", this.lastTarget);
            this.lastTarget = target;
          }
          this.moveImage(e);
          this.isDropZone = this.dispatchEvent(e, "dragover", target);
          this.setDragoverInterval(e);
        }
      }
    };
    this.touchendOnDocument = (e) => {
      if (this.shouldHandle(e)) {
        if (!this.img) {
          this.dragSource = null;
          this.lastClick = Date.now();
        }
        this.destroyImage();
        if (this.dragSource) {
          this.reset();
        }
      }
    };
    this.touchend = (e) => {
      if (this.shouldHandle(e)) {
        if (!this.img) {
          this.dragSource = null;
          this.lastClick = Date.now();
        }
        this.destroyImage();
        if (this.dragSource) {
          if (e.type.indexOf("cancel") < 0 && this.isDropZone) {
            this.dispatchEvent(this.lastTouch, "drop", this.lastTarget);
          }
          this.dispatchEvent(this.lastTouch, "dragend", this.dragSource);
          this.reset();
        }
      }
    };
    if (_DragDropTouch.instance) {
      throw new Error("DragDropTouch instance already created.");
    }
    let supportsPassive = false;
    if (typeof document !== "undefined") {
      document.addEventListener("test", () => {
      }, {
        get passive() {
          supportsPassive = true;
          return true;
        }
      });
      if (_DragDropTouch.isTouchDevice()) {
        const d = document;
        const ts = this.touchstart;
        const tmod = this.touchmoveOnDocument;
        const teod = this.touchendOnDocument;
        const opt = supportsPassive ? { passive: false, capture: false } : false;
        const optPassive = supportsPassive ? { passive: true } : false;
        d.addEventListener("touchstart", ts, opt);
        d.addEventListener("touchmove", tmod, optPassive);
        d.addEventListener("touchend", teod);
        d.addEventListener("touchcancel", teod);
        this.touchmoveListener = this.touchmove;
        this.touchendListener = this.touchend;
        this.listenerOpt = opt;
      }
    }
  }
  static getInstance() {
    if (!_DragDropTouch.instance) {
      _DragDropTouch.instance = new _DragDropTouch();
    }
    return _DragDropTouch.instance;
  }
  static isTouchDevice() {
    var _a;
    if (typeof window === "undefined" || typeof document === "undefined") {
      return false;
    }
    const d = document;
    const w = window;
    let bool;
    if ("ontouchstart" in d || "ontouchstart" in w || navigator.maxTouchPoints > 0 || navigator["msMaxTouchPoints"] > 0 || window["DocumentTouch"] && document instanceof window["DocumentTouch"]) {
      bool = true;
    } else {
      const fakeBody = document.createElement("fakebody");
      fakeBody.innerHTML += `
      <style>
        @media (touch-enabled),(-webkit-touch-enabled),(-moz-touch-enabled),(-o-touch-enabled){
          #touch_test {
            top: 42px;
            position: absolute;
          }
        }
      </style>`;
      document.documentElement.appendChild(fakeBody);
      const touchTestNode = document.createElement("div");
      touchTestNode.id = "touch_test";
      fakeBody.appendChild(touchTestNode);
      bool = touchTestNode.offsetTop === 42;
      (_a = fakeBody.parentElement) == null ? void 0 : _a.removeChild(fakeBody);
    }
    return bool;
  }
  bindTouchmoveTouchend(e) {
    this.touchTarget = e.target;
    e.target.addEventListener("touchmove", this.touchmoveListener, this.listenerOpt);
    e.target.addEventListener("touchend", this.touchendListener);
    e.target.addEventListener("touchcancel", this.touchendListener);
  }
  removeTouchmoveTouchend() {
    if (this.touchTarget) {
      this.touchTarget.removeEventListener("touchmove", this.touchmoveListener);
      this.touchTarget.removeEventListener("touchend", this.touchendListener);
      this.touchTarget.removeEventListener("touchcancel", this.touchendListener);
      this.touchTarget = void 0;
    }
  }
  shouldHandle(e) {
    return e && !e.defaultPrevented && e.touches && e.touches.length < 2;
  }
  shouldHandleMove(e) {
    return !_DragDropTouch.IS_PRESS_HOLD_MODE && this.shouldHandle(e);
  }
  shouldHandlePressHoldMove(e) {
    return _DragDropTouch.IS_PRESS_HOLD_MODE && this.isDragEnabled && e && e.touches && e.touches.length;
  }
  shouldCancelPressHoldMove(e) {
    return _DragDropTouch.IS_PRESS_HOLD_MODE && !this.isDragEnabled && this.getDelta(e) > _DragDropTouch.PRESS_HOLD_MARGIN;
  }
  shouldStartDragging(e) {
    const dragHandleSelector = this.getDragHandle();
    if (dragHandleSelector && !this.matchSelector(e.target, dragHandleSelector)) {
      return false;
    }
    const delta = this.getDelta(e);
    return delta > _DragDropTouch.THRESHOLD || _DragDropTouch.IS_PRESS_HOLD_MODE && delta >= _DragDropTouch.PRESS_HOLD_THRESHOLD;
  }
  getDragHandle() {
    if (this.dragSource) {
      return this.dragSource.getAttribute(_DragDropTouch.DRAG_HANDLE_ATTR) || "";
    }
    return "";
  }
  matchSelector(element, selector) {
    if (selector) {
      const proto = Element.prototype;
      const func = proto["matches"] || proto["matchesSelector"] || proto["mozMatchesSelector"] || proto["msMatchesSelector"] || proto["oMatchesSelector"] || proto["webkitMatchesSelector"] || function(s) {
        const matches = (this.document || this.ownerDocument).querySelectorAll(s);
        let i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {
        }
        return i > -1;
      };
      return func.call(element, selector);
    }
    return true;
  }
  reset() {
    this.removeTouchmoveTouchend();
    this.destroyImage();
    this.dragSource = null;
    this.lastTouch = null;
    this.lastTarget = null;
    this.ptDown = null;
    this.isDragEnabled = false;
    this.isDropZone = false;
    this.dataTransfer = new _DragDropTouch.DataTransfer();
    clearInterval(this.pressHoldInterval);
    this.clearDragoverInterval();
  }
  getPoint(e, page) {
    if (e && e.touches) {
      e = e.touches[0];
    }
    return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };
  }
  getDelta(e) {
    if (_DragDropTouch.IS_PRESS_HOLD_MODE && !this.ptDown) {
      return 0;
    }
    const p = this.getPoint(e);
    return Math.abs(p.x - this.ptDown.x) + Math.abs(p.y - this.ptDown.y);
  }
  getTarget(e) {
    const pt = this.getPoint(e);
    let el = document.elementFromPoint(pt.x, pt.y);
    while (el && getComputedStyle(el).pointerEvents === "none") {
      el = el.parentElement;
    }
    return el;
  }
  createImage(e) {
    if (this.img) {
      this.destroyImage();
    }
    const src = this.imgCustom || this.dragSource;
    this.img = src.cloneNode(true);
    this.copyStyle(src, this.img);
    this.img.style.top = this.img.style.left = "-9999px";
    if (!this.imgCustom) {
      const rc = src.getBoundingClientRect();
      const pt = this.getPoint(e);
      this.imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };
      this.img.style.opacity = _DragDropTouch.OPACITY.toString();
    }
    this.moveImage(e);
    document.body.appendChild(this.img);
  }
  destroyImage() {
    if (this.img && this.img.parentElement) {
      this.img.parentElement.removeChild(this.img);
    }
    this.img = null;
    this.imgCustom = null;
  }
  moveImage(e) {
    requestAnimationFrame(() => {
      if (this.img) {
        const pt = this.getPoint(e, true);
        const s = this.img.style;
        s.position = "absolute";
        s.pointerEvents = "none";
        s.zIndex = "999999";
        s.left = Math.round(pt.x - this.imgOffset.x) + "px";
        s.top = Math.round(pt.y - this.imgOffset.y) + "px";
      }
    });
  }
  copyProps(dst, src, props) {
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      dst[p] = src[p];
    }
  }
  copyStyle(src, dst) {
    _DragDropTouch.rmvAttrs.forEach(function(att) {
      dst.removeAttribute(att);
    });
    if (src instanceof HTMLCanvasElement) {
      const canSrc = src;
      const canDst = dst;
      canDst.width = canSrc.width;
      canDst.height = canSrc.height;
      canDst.getContext("2d").drawImage(canSrc, 0, 0);
    }
    const srcCanvases = src.querySelectorAll("canvas");
    if (srcCanvases.length > 0) {
      const dstCanvases = dst.querySelectorAll("canvas");
      for (let i = 0; i < dstCanvases.length; i++) {
        const cSrc = srcCanvases[i];
        const cDst = dstCanvases[i];
        cDst.getContext("2d").drawImage(cSrc, 0, 0);
      }
    }
    const cs = getComputedStyle(src);
    for (let i = 0; i < cs.length; i++) {
      const key = cs[i];
      if (key.indexOf("transition") < 0) {
        dst.style[key] = cs[key];
      }
    }
    dst.style.pointerEvents = "none";
    for (let i = 0; i < src.children.length; i++) {
      this.copyStyle(src.children[i], dst.children[i]);
    }
  }
  dispatchEvent(e, type, target) {
    if (e && target) {
      const evt = document.createEvent("Event");
      const t = e.touches ? e.touches[0] : e;
      evt.initEvent(type, true, true);
      const obj = {
        button: 0,
        which: 0,
        buttons: 1,
        dataTransfer: this.dataTransfer
      };
      this.copyProps(evt, e, _DragDropTouch.kbdProps);
      this.copyProps(evt, t, _DragDropTouch.ptProps);
      this.copyProps(evt, { fromTouch: true }, ["fromTouch"]);
      this.copyProps(evt, obj, Object.keys(obj));
      target.dispatchEvent(evt);
      return evt.defaultPrevented;
    }
    return false;
  }
  closestDraggable(e) {
    for (; e; e = e.parentElement) {
      if (e.hasAttribute("draggable") && e.draggable) {
        return e;
      }
    }
    return null;
  }
  setDragoverInterval(e) {
    this.dragoverTimer = setInterval(() => {
      const target = this.getTarget(e);
      if (target !== this.lastTarget) {
        this.dispatchEvent(e, "dragenter", target);
        this.dispatchEvent(e, "dragleave", this.lastTarget);
        this.lastTarget = target;
      }
      this.isDropZone = this.dispatchEvent(e, "dragover", target);
    }, _DragDropTouch.DRAG_OVER_TIME);
  }
  clearDragoverInterval() {
    if (this.dragoverTimer) {
      clearInterval(this.dragoverTimer);
      this.dragoverTimer = void 0;
    }
  }
};
let DragDropTouch = _DragDropTouch;
DragDropTouch.THRESHOLD = 5;
DragDropTouch.OPACITY = 0.5;
DragDropTouch.DBLCLICK = 500;
DragDropTouch.DRAG_OVER_TIME = 300;
DragDropTouch.CTX_MENU = 900;
DragDropTouch.IS_PRESS_HOLD_MODE = true;
DragDropTouch.PRESS_HOLD_AWAIT = 400;
DragDropTouch.PRESS_HOLD_MARGIN = 25;
DragDropTouch.PRESS_HOLD_THRESHOLD = 0;
DragDropTouch.DRAG_HANDLE_ATTR = "data-drag-handle-selector";
DragDropTouch.rmvAttrs = "id,class,style,draggable".split(",");
DragDropTouch.kbdProps = "altKey,ctrlKey,metaKey,shiftKey".split(",");
DragDropTouch.ptProps = "pageX,pageY,clientX,clientY,screenX,screenY".split(",");
DragDropTouch.instance = null;
((DragDropTouch2) => {
  class DataTransfer2 {
    get dropEffect() {
      return this._dropEffect;
    }
    set dropEffect(value) {
      this._dropEffect = value;
    }
    get effectAllowed() {
      return this._effectAllowed;
    }
    set effectAllowed(value) {
      this._effectAllowed = value;
    }
    get types() {
      return Object.keys(this._data);
    }
    constructor() {
      this._dropEffect = "move";
      this._effectAllowed = "all";
      this._data = {};
    }
    clearData(type) {
      if (type !== null) {
        delete this._data[type];
      } else {
        this._data = null;
      }
    }
    getData(type) {
      return this._data[type] || "";
    }
    setData(type, value) {
      this._data[type] = value;
    }
    setDragImage(img, offsetX, offsetY) {
      const ddt = DragDropTouch2.getInstance();
      ddt.imgCustom = img;
      ddt.imgOffset = { x: offsetX, y: offsetY };
    }
  }
  DragDropTouch2.DataTransfer = DataTransfer2;
})(DragDropTouch || (DragDropTouch = {}));
class DragDropService {
  constructor() {
    this.dropTargets = [];
    this.dropEvent = new Subject();
    this.dragEndEvent = new Subject();
    this.dragStartEvent = new Subject();
    this.subscription = new Subscription();
    this.dragItemParentName = "";
    this.dragItemChildrenName = "";
    this.intersectionObserver = null;
    this.dragElShowHideEvent = new Subject();
    this.followMouse4CloneNode = (event) => {
      const { offsetLeft, offsetTop } = this.dragOffset;
      const { clientX, clientY } = event;
      requestAnimationFrame(() => {
        if (!this.dragCloneNode) {
          return;
        }
        this.dragCloneNode.style.left = clientX - offsetLeft + "px";
        this.dragCloneNode.style.top = clientY - offsetTop + "px";
      });
    };
    this.touchInstance = DragDropTouch.getInstance();
  }
  get dragEmptyImage() {
    if (!this._dragEmptyImage) {
      this._dragEmptyImage = new Image();
      this._dragEmptyImage.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==";
    }
    return this._dragEmptyImage;
  }
  get document() {
    return window.document;
  }
  newSubscription() {
    this.subscription.unsubscribe();
    return this.subscription = new Subscription();
  }
  enableDraggedCloneNodeFollowMouse() {
    if (!this.dragCloneNode) {
      this.dragItemContainer = this.draggedEl.parentElement;
      if (this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate) {
        this.dragPreviewDirective.createPreview();
        this.dragCloneNode = this.dragPreviewDirective.getPreviewElement();
        this.dragItemContainer = this.document.body;
      } else {
        this.dragCloneNode = this.draggedEl.cloneNode(true);
      }
      this.dragCloneNode.style.margin = "0";
      if (this.dragFollowOptions && this.dragFollowOptions.appendToBody) {
        this.dragItemContainer = this.document.body;
        this.copyStyle(this.draggedEl, this.dragCloneNode);
      }
      if (this.dragItemChildrenName !== "") {
        const parentElement = this.dragItemParentName === "" ? this.dragCloneNode : this.document.querySelector(this.dragItemParentName);
        const dragItemChildren = parentElement.querySelectorAll(this.dragItemChildrenName);
        this.interceptChildNode(parentElement, dragItemChildren);
      }
      const originCanvasArr = this.draggedEl.querySelectorAll("canvas");
      const targetCanvasArr = this.dragCloneNode.querySelectorAll("canvas");
      [].forEach.call(targetCanvasArr, (canvas, index2) => {
        canvas.getContext("2d").drawImage(originCanvasArr[index2], 0, 0);
      });
      this.document.addEventListener("dragover", this.followMouse4CloneNode, { capture: true, passive: true });
      this.dragCloneNode.style.width = this.dragOffset.width + "px";
      this.dragCloneNode.style.height = this.dragOffset.height + "px";
      if (!(this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate && this.dragPreviewDirective.dragPreviewOptions && this.dragPreviewDirective.dragPreviewOptions.skipBatchPreview)) {
        if (this.batchDragging && this.batchDragData && this.batchDragData.length > 1) {
          const node = this.document.createElement("div");
          node.appendChild(this.dragCloneNode);
          node.classList.add("batch-dragged-node");
          if (this.batchDragStyle && this.batchDragStyle.length && this.batchDragStyle.indexOf("badge") > -1) {
            const badge = this.document.createElement("div");
            badge.innerText = String(this.batchDragData.length);
            badge.classList.add("batch-dragged-node-count");
            node.style.position = "relative";
            const style = {
              position: "absolute",
              right: "5px",
              top: "-12px",
              height: "24px",
              width: "24px",
              borderRadius: "12px",
              fontSize: "14px",
              lineHeight: "24px",
              textAlign: "center",
              color: "#fff",
              background: ["#5170ff", "var(--brand-1, #5170ff)"]
            };
            Utils.addElStyles(badge, style);
            node.appendChild(badge);
          }
          if (this.batchDragStyle && this.batchDragStyle.length && this.batchDragStyle.indexOf("stack") > -1) {
            let stack = 2;
            if (this.batchDragData.length === 2) {
              stack = 1;
            }
            for (let i = 0; i < stack; i++) {
              const stackNode = this.dragCloneNode.cloneNode(false);
              const stackStyle = {
                position: "absolute",
                left: -5 * (i + 1) + "px",
                top: -5 * (i + 1) + "px",
                zIndex: String(-(i + 1)),
                width: this.dragOffset.width + "px",
                height: this.dragOffset.height + "px",
                background: "#fff",
                border: ["1px solid #5170ff", "1px solid var(--brand-1, #5170ff)"]
              };
              Utils.addElStyles(stackNode, stackStyle);
              node.appendChild(stackNode);
            }
          }
          this.dragCloneNode = node;
        }
      }
      this.dragCloneNode.classList.add("drag-clone-node");
      if (!(this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate)) {
        this.dragCloneNode.style.width = this.dragOffset.width + "px";
        this.dragCloneNode.style.height = this.dragOffset.height + "px";
      }
      this.dragCloneNode.style.position = "fixed";
      this.dragCloneNode.style.zIndex = "1090";
      this.dragCloneNode.style.pointerEvents = "none";
      this.dragCloneNode.style.top = this.dragOffset.top + "px";
      this.dragCloneNode.style.left = this.dragOffset.left + "px";
      this.dragCloneNode.style.willChange = "left, top";
      this.dragItemContainer.appendChild(this.dragCloneNode);
      setTimeout(() => {
        if (this.draggedEl) {
          this.draggedEl.style.display = "none";
          this.dragElShowHideEvent.next(false);
          if (this.dragOriginPlaceholder) {
            this.dragOriginPlaceholder.style.display = "block";
          }
        }
      });
    }
  }
  disableDraggedCloneNodeFollowMouse() {
    if (this.dragCloneNode) {
      this.document.removeEventListener("dragover", this.followMouse4CloneNode, { capture: true });
      this.dragItemContainer.removeChild(this.dragCloneNode);
      this.draggedEl.style.display = "";
      this.dragElShowHideEvent.next(true);
    }
    if (this.dragPreviewDirective && this.dragPreviewDirective.dragPreviewTemplate) {
      this.dragPreviewDirective.destroyPreview();
    }
    this.dragCloneNode = void 0;
    this.dragItemContainer = void 0;
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
    }
  }
  interceptChildNode(parentNode, childNodeList) {
    const interceptOptions = {
      root: parentNode
    };
    this.intersectionObserver = new IntersectionObserver(this.setChildNodeHide, interceptOptions);
    [].forEach.call(childNodeList, (childNode) => {
      this.intersectionObserver.observe(childNode);
    });
  }
  setChildNodeHide(entries) {
    entries.forEach((element) => {
      const { isIntersecting, target: childNode } = element;
      if (isIntersecting) {
        childNode.style.display = "block";
      } else {
        childNode.style.display = "none";
      }
    });
  }
  getBatchDragData(identity2, order = "draggedElFirst") {
    const result = this.batchDragData.map((dragData) => dragData.dragData);
    if (typeof order === "function") {
      result.sort(order);
    } else if (order === "draggedElFirst") {
      let dragData = this.dragData;
      if (identity2) {
        const realDragData = this.batchDragData.filter((dd) => dd.identity === identity2).pop().dragData;
        dragData = realDragData;
      }
      result.splice(result.indexOf(dragData), 1);
      result.splice(0, 0, dragData);
    }
    return result;
  }
  cleanBatchDragData() {
    const batchDragData = this.batchDragData;
    if (this.batchDragData) {
      this.batchDragData.filter((dragData) => dragData.draggable).map((dragData) => dragData.draggable).forEach((draggable) => {
        draggable.batchDraggable.dragData = void 0;
      });
      this.batchDragData = void 0;
      this.batchDragGroup = void 0;
    }
    return batchDragData;
  }
  copyStyle(source, target) {
    ["id", "class", "style", "draggable"].forEach(function(att) {
      target.removeAttribute(att);
    });
    const computedStyle = getComputedStyle(source);
    for (let i = 0; i < computedStyle.length; i++) {
      const key = computedStyle[i];
      if (key.indexOf("transition") < 0) {
        target.style[key] = computedStyle[key];
      }
    }
    target.style.pointerEvents = "none";
    for (let i = 0; i < source.children.length; i++) {
      this.copyStyle(source.children[i], target.children[i]);
    }
  }
}
DragDropService.TOKEN = Symbol("DRAG_DROP_SERVICE_TOKEN");
function useDragDropService() {
  const dragDropService = new DragDropService();
  provide(DragDropService.TOKEN, new DragDropService());
  return dragDropService;
}
class EventEmitter extends Subject {
  constructor(isAsync = false) {
    super();
    this.__isAsync = isAsync;
  }
  emit(value) {
    super.next(value);
  }
  subscribe(generatorOrNext, error, complete) {
    let schedulerFn;
    let errorFn = (err) => null;
    let completeFn = () => null;
    if (generatorOrNext && typeof generatorOrNext === "object") {
      schedulerFn = this.__isAsync ? (value) => {
        setTimeout(() => generatorOrNext.next(value));
      } : (value) => {
        generatorOrNext.next(value);
      };
      if (generatorOrNext.error) {
        errorFn = this.__isAsync ? (err) => {
          setTimeout(() => generatorOrNext.error(err));
        } : (err) => {
          generatorOrNext.error(err);
        };
      }
      if (generatorOrNext.complete) {
        errorFn = this.__isAsync ? () => {
          setTimeout(() => generatorOrNext.complete());
        } : () => {
          generatorOrNext.complete();
        };
      }
    } else {
      schedulerFn = this.__isAsync ? (value) => {
        setTimeout(() => generatorOrNext(value));
      } : (value) => {
        generatorOrNext(value);
      };
      if (error) {
        errorFn = this.__isAsync ? (err) => {
          setTimeout(() => error(err));
        } : (err) => {
          error(err);
        };
      }
      if (complete) {
        completeFn = this.__isAsync ? () => {
          setTimeout(() => complete());
        } : () => {
          complete();
        };
      }
    }
    const sink = super.subscribe(schedulerFn, errorFn, completeFn);
    if (generatorOrNext instanceof Subscription) {
      generatorOrNext.add(sink);
    }
    return sink;
  }
}
class PreserveNextEventEmitter extends EventEmitter {
  constructor() {
    super(...arguments);
    this._isAsync = false;
  }
  get schedulerFns() {
    return this._schedulerFns;
  }
  forceCallback(value, once = false) {
    if (this.schedulerFns && this.schedulerFns.size) {
      this.schedulerFns.forEach((fn) => {
        fn(value);
      });
      if (once) {
        this.cleanCallbackFn();
      }
    }
  }
  cleanCallbackFn() {
    this._schedulerFns = void 0;
  }
  subscribe(generatorOrNext, error, complete) {
    let schedulerFn;
    if (generatorOrNext && typeof generatorOrNext === "object") {
      schedulerFn = this._isAsync ? (value) => {
        setTimeout(() => generatorOrNext.next(value));
      } : (value) => {
        generatorOrNext.next(value);
      };
    } else {
      schedulerFn = this._isAsync ? (value) => {
        setTimeout(() => generatorOrNext(value));
      } : (value) => {
        generatorOrNext(value);
      };
    }
    if (!this._schedulerFns) {
      this._schedulerFns = /* @__PURE__ */ new Set();
    }
    this._schedulerFns.add(schedulerFn);
    return super.subscribe(generatorOrNext, error, complete);
  }
}
class NgSimpleChange {
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  isFirstChange() {
    return this.firstChange;
  }
}
class NgDirectiveBase {
  constructor() {
    this.__eventListenerMap = /* @__PURE__ */ new Map();
    this.el = { nativeElement: null };
    this.hostBindingMap = void 0;
    this.hostListenerMap = void 0;
    this.inputNameMap = void 0;
    this.outputNameMap = void 0;
  }
  mounted() {
    if (this.hostBindingMap && this.el.nativeElement) {
      Object.keys(this.hostBindingMap).forEach((key) => {
        if (this[key] !== void 0) {
          this.hostBinding(this.hostBindingMap[key], key);
        }
      });
    }
    if (this.hostListenerMap && this.el.nativeElement) {
      Object.keys(this.hostListenerMap).forEach((key) => {
        if (this[key]) {
          this.hostListener(this.hostListenerMap[key], key);
        }
      });
    }
  }
  setInput(props) {
    if (!props) {
      return;
    }
    const changes = /* @__PURE__ */ new Map();
    Object.keys(props).forEach((key) => {
      if (key.startsWith("@")) {
        const outputKey = this.getOutputKey(key.slice(1));
        this.eventListener(outputKey, props[key]);
      } else {
        const inputKey = this.getInputKey(key);
        const previousValue = this[inputKey];
        this[inputKey] = props[key];
        changes.set(inputKey, {
          previousValue,
          currentValue: props[key],
          firstChange: true
        });
      }
    });
    this.notifyOnChanges(changes);
    if (this.hostBindingMap && this.el.nativeElement) {
      Object.keys(this.hostBindingMap).forEach((key) => {
        if (props[key]) {
          this.hostBinding(this.hostBindingMap[key], key);
        }
      });
    }
  }
  updateInput(props, old) {
    const changes = /* @__PURE__ */ new Map();
    props && Object.keys(props).forEach((key) => {
      const inputKey = this.getInputKey(key);
      if (props[key] !== (old == null ? void 0 : old[key])) {
        changes.set(inputKey, {
          previousValue: old[key],
          currentValue: props[key],
          firstChange: old[key] === void 0
        });
      }
    });
    old && Object.keys(old).filter((key) => !Object.keys(props).includes(key)).forEach((key) => {
      if (old[key] !== (props == null ? void 0 : props[key])) {
        const inputKey = this.getInputKey(key);
        changes.set(inputKey, {
          previousValue: old[key],
          currentValue: props[key],
          firstChange: old[key] === void 0
        });
      }
    });
    changes.forEach((value, key) => {
      if (key.startsWith("@")) {
        this.eventListener(key.slice(1), value["currentValue"]);
      } else {
        this[key] = value["currentValue"];
      }
    });
    this.notifyOnChanges(changes);
    if (this.hostBindingMap && this.el.nativeElement) {
      Object.keys(this.hostBindingMap).forEach((key) => {
        if (changes.get(key)) {
          this.hostBinding(this.hostBindingMap[key], key);
        }
      });
    }
  }
  hostBinding(key, valueKey) {
    const element = this.el.nativeElement;
    const value = this[valueKey];
    element.setAttribute(key, value);
  }
  hostListener(key, functionKey) {
    const element = this.el.nativeElement;
    element.addEventListener(key, this[functionKey].bind(this));
  }
  eventListener(key, userFunction) {
    var _a;
    const subscription = this[key].subscribe((e) => {
      userFunction(e);
    });
    if (this.__eventListenerMap.get(key)) {
      (_a = this.__eventListenerMap.get(key)) == null ? void 0 : _a.unsubscribe();
      this.__eventListenerMap.delete(key);
    }
    this.__eventListenerMap.set(key, subscription);
  }
  getInputKey(key) {
    return this.inputNameMap && this.inputNameMap[key] || key;
  }
  getOutputKey(key) {
    return this.outputNameMap && this.outputNameMap[key] || key;
  }
  notifyOnChanges(changes) {
    if (this.ngOnChanges) {
      const simpleChanges = [...changes.entries()].filter(([key, value]) => !key.startsWith("@")).reduce((obj, [key, value]) => {
        const { previousValue, currentValue, firstChange } = value;
        obj[key] = new NgSimpleChange(previousValue, currentValue, firstChange);
        return obj;
      }, {});
      if (Object.keys(simpleChanges).length) {
        this.ngOnChanges(simpleChanges);
      }
    }
  }
}
const DragPreviewTemplate = defineComponent({
  name: "DDragPreviewTemplate",
  setup(props, {
    slots,
    expose
  }) {
    expose({
      template: slots.default
    });
    return () => null;
  }
});
const DragPreviewComponent = defineComponent({
  name: "DDragPreviewContainer",
  props: {
    template: Function,
    context: Object
  },
  setup(props) {
    return () => {
      var _a;
      return (_a = props.template) == null ? void 0 : _a.call(props, props.context);
    };
  }
});
class DragPreviewDirective extends NgDirectiveBase {
  constructor(el, dragDropService) {
    super();
    this.dragDropService = dragDropService;
    this.inputNameMap = {
      dragPreview: "dragPreviewTemplate"
    };
    this.dragPreviewOptions = {
      skipBatchPreview: false
    };
    this.el = { nativeElement: null };
    this.el.nativeElement = el;
  }
  createPreview() {
    var _a;
    const context2 = {
      data: this.dragPreviewData,
      draggedEl: this.dragDropService.draggedEl,
      dragData: this.dragDropService.dragData,
      batchDragData: this.dragDropService.batchDragData && this.dragDropService.getBatchDragData(),
      dragSyncDOMElements: this.dragDropService.dragSyncGroupDirectives && this.getDragSyncDOMElements()
    };
    const app = createApp(DragPreviewComponent, { context: context2, template: (_a = this.dragPreviewTemplate) == null ? void 0 : _a.template });
    app._context.provides = Object.create(this.context);
    const element = document.createElement("div");
    const instance = app.mount(element);
    const unmount = () => {
      app.unmount();
    };
    this.previewRef = {
      instance,
      element,
      unmount
    };
  }
  destroyPreview() {
    if (this.previewRef) {
      this.previewRef.unmount();
      this.previewRef = void 0;
    }
  }
  getPreviewElement() {
    return this.previewRef && this.previewRef.element;
  }
  getDragSyncDOMElements() {
    return this.dragDropService.dragSyncGroupDirectives.map((dir) => dir.el.nativeElement);
  }
}
DragPreviewDirective.INSTANCE_KEY = "__vueDevuiDragPreviewDirectiveInstance";
DragPreviewDirective.TOKEN = Symbol("DRAG_PREVIEW_DIRECTIVE_TOKEN");
var DragPreview = {
  mounted(el, binding, vNode) {
    const context2 = vNode["ctx"].provides;
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    const dragPreviewDirective = el[DragPreviewDirective.INSTANCE_KEY] = new DragPreviewDirective(el, dragDropService);
    provideToContext(DragPreviewDirective.TOKEN, dragPreviewDirective, context2);
    dragPreviewDirective.setInput({ context: context2 });
    dragPreviewDirective.setInput(binding.value);
    dragPreviewDirective.mounted();
  },
  updated(el, binding) {
    const dragPreviewDirective = el[DragPreviewDirective.INSTANCE_KEY];
    dragPreviewDirective.updateInput(binding.value, binding.oldValue);
  }
};
class DraggableDirective extends NgDirectiveBase {
  constructor(el, dragDropService, dragPreviewDirective) {
    super();
    this.hostBindingMap = {
      draggable: "draggable",
      "data-drag-handle-selector": "dragHandle"
    };
    this.draggable = true;
    this.dragScope = "default";
    this.dragHandleClass = "drag-handle";
    this.dragEffect = "move";
    this._disabled = false;
    this.dragStartEvent = new EventEmitter();
    this.dragEvent = new PreserveNextEventEmitter();
    this.dragEndEvent = new EventEmitter();
    this.dropEndEvent = new PreserveNextEventEmitter();
    this.document = window.document;
    this.enableDragFollow = false;
    this.dragItemParentName = "";
    this.dragItemChildrenName = "";
    this.dragsSub = new Subscription();
    this.destroyDragEndSub = new Subscription();
    this.dragElShowHideEvent = new Subject();
    this.beforeDragStartEvent = new Subject();
    this.el = { nativeElement: null };
    this.insertOriginPlaceholder = (directShow = true, updateService = true) => {
      var _a, _b, _c;
      if (this.delayRemoveOriginPlaceholderTimer) {
        clearTimeout(this.delayRemoveOriginPlaceholderTimer);
        this.delayRemoveOriginPlaceholderTimer = void 0;
      }
      const node = this.document.createElement(((_a = this.originPlaceholder) == null ? void 0 : _a.tag) || "div");
      const rect = this.el.nativeElement.getBoundingClientRect();
      if (directShow) {
        node.style.display = "block";
      } else {
        node.style.display = "none";
      }
      node.style.width = rect.width + "px";
      node.style.height = rect.height + "px";
      node.classList.add("drag-origin-placeholder");
      if ((_b = this.originPlaceholder) == null ? void 0 : _b.text) {
        node.innerText = this.originPlaceholder.text;
      }
      if ((_c = this.originPlaceholder) == null ? void 0 : _c.style) {
        Utils.addElStyles(node, this.originPlaceholder.style);
      }
      if (updateService) {
        this.dragDropService.dragOriginPlaceholder = node;
        this.dragDropService.dragOriginPlaceholderNextSibling = this.el.nativeElement.nextSibling;
      } else {
        node.classList.add("side-drag-origin-placeholder");
        const originCloneNode = this.el.nativeElement.cloneNode(true);
        originCloneNode.style.margin = 0;
        originCloneNode.style.pointerEvents = "none";
        originCloneNode.style.opacity = "0.3";
        node.appendChild(originCloneNode);
      }
      this.dragOriginPlaceholder = node;
      this.dragOriginPlaceholderNextSibling = this.el.nativeElement.nextSibling;
      this.el.nativeElement.parentElement.insertBefore(node, this.el.nativeElement.nextSibling);
    };
    this.removeOriginPlaceholder = (updateService = true) => {
      var _a;
      if (this.dragOriginPlaceholder) {
        (_a = this.dragOriginPlaceholder.parentElement) == null ? void 0 : _a.removeChild(this.dragOriginPlaceholder);
      }
      if (updateService) {
        this.dragDropService.dragOriginPlaceholder = void 0;
        this.dragDropService.dragOriginPlaceholderNextSibling = void 0;
      }
      this.dragOriginPlaceholder = void 0;
      this.dragOriginPlaceholderNextSibling = void 0;
    };
    this.delayRemoveOriginPlaceholder = (updateService = true) => {
      var _a, _b;
      const timeout = (_a = this.originPlaceholder) == null ? void 0 : _a.removeDelay;
      const delayOriginPlaceholder = this.dragOriginPlaceholder;
      const dragOriginPlaceholderNextSibling = this.findNextSibling(this.dragOriginPlaceholderNextSibling);
      if ((_b = delayOriginPlaceholder == null ? void 0 : delayOriginPlaceholder.parentElement) == null ? void 0 : _b.contains(dragOriginPlaceholderNextSibling)) {
        delayOriginPlaceholder.parentElement.insertBefore(delayOriginPlaceholder, dragOriginPlaceholderNextSibling);
      }
      setTimeout(() => {
        var _a2;
        if ((_a2 = delayOriginPlaceholder == null ? void 0 : delayOriginPlaceholder.parentElement) == null ? void 0 : _a2.contains(dragOriginPlaceholderNextSibling)) {
          delayOriginPlaceholder.parentElement.insertBefore(delayOriginPlaceholder, dragOriginPlaceholderNextSibling);
        }
        delayOriginPlaceholder == null ? void 0 : delayOriginPlaceholder.classList.add("delay-deletion");
        this.delayRemoveOriginPlaceholderTimer = setTimeout(() => {
          var _a3;
          (_a3 = delayOriginPlaceholder == null ? void 0 : delayOriginPlaceholder.parentElement) == null ? void 0 : _a3.removeChild(delayOriginPlaceholder);
          if (this.document.body.contains(this.el.nativeElement)) {
            this.el.nativeElement.style.display = "";
            this.dragDropService.dragElShowHideEvent.next(false);
          }
        }, timeout);
        if (updateService) {
          this.dragDropService.dragOriginPlaceholder = void 0;
          this.dragDropService.dragOriginPlaceholderNextSibling = void 0;
        }
        this.dragOriginPlaceholder = void 0;
        this.dragOriginPlaceholderNextSibling = void 0;
      });
    };
    this.el.nativeElement = el;
    this.dragDropService = dragDropService;
    this.dragPreviewDirective = dragPreviewDirective;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.draggable = !this._disabled;
  }
  ngOnInit() {
    this.dragsSub.add(fromEvent(this.el.nativeElement, "mouseover").subscribe((event) => this.mouseover(event)));
    this.dragsSub.add(fromEvent(this.el.nativeElement, "dragstart").subscribe((event) => this.dragStart(event)));
    this.dragsSub.add(fromEvent(this.el.nativeElement, "dragend").subscribe((event) => this.dragEnd(event)));
  }
  dropSubscription() {
    const dragDropSub = this.dragDropService.newSubscription();
    dragDropSub.add(
      this.dragDropService.dropEvent.subscribe((event) => {
        this.mouseOverElement = void 0;
        Utils.removeClass(this.el.nativeElement, this.dragOverClass);
        this.dropEndEvent.emit(event);
        if (this.isDestroyed) {
          if (this.dropEndEvent.schedulerFns && this.dropEndEvent.schedulerFns.size > 0) {
            this.dropEndEvent.forceCallback(event, true);
          }
        }
        if (this.dragDropService.dragOriginPlaceholder) {
          if (this.originPlaceholder && this.originPlaceholder.removeDelay > 0 && !this.dragDropService.dropOnOrigin) {
            this.delayRemoveOriginPlaceholder();
          } else {
            this.removeOriginPlaceholder();
          }
          this.dragDropService.draggedElIdentity = void 0;
        }
        this.dragDropService.subscription.unsubscribe();
      })
    );
    dragDropSub.add(this.dragDropService.dragElShowHideEvent.subscribe(this.dragElShowHideEvent));
  }
  ngAfterViewInit() {
    this.applyDragHandleClass();
    if (this.dragIdentity) {
      if (this.dragDropService.draggedEl && this.dragIdentity === this.dragDropService.draggedElIdentity) {
        if (this.originPlaceholder && this.originPlaceholder.show !== false) {
          this.insertOriginPlaceholder();
        }
        this.dragDropService.draggedEl = this.el.nativeElement;
        this.el.nativeElement.style.display = "none";
      }
    }
  }
  ngOnDestroy() {
    this.isDestroyed = true;
    if (this.dragDropService.draggedEl === this.el.nativeElement) {
      this.destroyDragEndSub = new Subscription();
      this.destroyDragEndSub.add(
        fromEvent(this.el.nativeElement, "dragend").subscribe((event) => {
          this.dragEnd(event);
          if (this.dropEndEvent.schedulerFns && this.dropEndEvent.schedulerFns.size > 0) {
            this.dropEndEvent.forceCallback(event, true);
          }
          this.destroyDragEndSub.unsubscribe();
          this.destroyDragEndSub = void 0;
        })
      );
      if (this.originPlaceholder && this.originPlaceholder.show !== false && this.dragDropService.dragOriginPlaceholder && this.dragDropService.draggedElIdentity) {
        this.removeOriginPlaceholder();
      }
    }
    this.dragsSub.unsubscribe();
  }
  dragStart(e) {
    var _a;
    if (this.allowDrag(e)) {
      Utils.addClass(this.el.nativeElement, this.dragOverClass);
      this.dragDropService.dragData = this.dragData;
      this.dragDropService.scope = this.dragScope;
      this.dragDropService.draggedEl = this.el.nativeElement;
      this.dragDropService.draggedElIdentity = this.dragIdentity;
      this.dragDropService.dragFollow = this.enableDragFollow;
      this.dragDropService.dragFollowOptions = this.dragFollowOptions;
      this.dragDropService.dragItemParentName = this.dragItemParentName;
      this.dragDropService.dragItemChildrenName = this.dragItemChildrenName;
      this.beforeDragStartEvent.next(true);
      if (this.dragPreviewDirective && ((_a = this.dragPreviewDirective) == null ? void 0 : _a.dragPreviewTemplate)) {
        this.dragDropService.dragFollow = true;
        this.dragDropService.dragPreviewDirective = this.dragPreviewDirective;
      }
      if (this.batchDraggable) {
        if (this.batchDraggable.dragData) {
          if (this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
            this.dragDropService.batchDragging = true;
            this.dragDropService.batchDragStyle = this.batchDraggable.batchDragStyle;
          }
        } else if (this.batchDraggable.batchDragLastOneAutoActiveEventKeys) {
          const batchActiveAble = this.batchDraggable.batchDragLastOneAutoActiveEventKeys.map((key) => e[key]).some((eventKey) => eventKey === true);
          if (batchActiveAble) {
            if (this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 0) {
              this.batchDraggable.active();
              if (!this.batchDraggable.dragData) {
                this.batchDraggable.addToBatchGroup();
              }
              if (this.dragDropService.batchDragData.some((dragData) => dragData.draggable === this)) {
                this.dragDropService.batchDragging = true;
                this.dragDropService.batchDragStyle = this.batchDraggable.batchDragStyle;
              }
            }
          }
        }
      }
      const targetOffset = this.el.nativeElement.getBoundingClientRect();
      if (this.dragDropService.dragFollow) {
        const mousePositionXY = this.mousePosition(e);
        const transformOffset = this.checkAndGetViewPointChange(this.el.nativeElement);
        this.dragDropService.dragOffset = {
          left: targetOffset.left,
          top: targetOffset.top,
          offsetLeft: mousePositionXY.x - targetOffset.left + transformOffset.offsetX,
          offsetTop: mousePositionXY.y - targetOffset.top + transformOffset.offsetY,
          width: targetOffset.width,
          height: targetOffset.height
        };
        this.dragDropService.enableDraggedCloneNodeFollowMouse();
      } else {
        this.dragDropService.dragOffset = {
          left: targetOffset.left,
          top: targetOffset.top,
          offsetLeft: null,
          offsetTop: null,
          width: targetOffset.width,
          height: targetOffset.height
        };
      }
      if (this.originPlaceholder && this.originPlaceholder.show !== false) {
        this.insertOriginPlaceholder(false);
      }
      if (this.dragDropService.batchDragging && this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
        this.dragDropService.batchDragData.map((dragData) => dragData.draggable).filter((draggable) => draggable && draggable !== this).forEach((draggable) => {
          if (draggable.originPlaceholder && draggable.originPlaceholder.show !== false) {
            draggable.insertOriginPlaceholder(true, false);
            draggable.el.nativeElement.style.display = "none";
          } else {
            setTimeout(() => {
              draggable.el.nativeElement.style.display = "none";
            });
          }
        });
      }
      if (e.dataTransfer !== null) {
        e.dataTransfer.setData("text", "");
      }
      e.dataTransfer.effectAllowed = this.dragEffect;
      this.dropSubscription();
      if (this.dragDropService.dragFollow) {
        if (typeof DataTransfer.prototype.setDragImage === "function") {
          e.dataTransfer.setDragImage(this.dragDropService.dragEmptyImage, 0, 0);
        } else {
          e.srcElement.style.display = "none";
          this.dragDropService.dragElShowHideEvent.next(false);
        }
      }
      e.stopPropagation();
      this.dragStartEvent.emit(e);
      this.dragDropService.dragStartEvent.next(e);
    } else {
      e.preventDefault();
    }
  }
  dragEnd(e) {
    Utils.removeClass(this.el.nativeElement, this.dragOverClass);
    this.dragDropService.dragEndEvent.next(e);
    this.mouseOverElement = void 0;
    if (this.dragDropService.draggedEl) {
      if (this.dragDropService.dragFollow) {
        this.dragDropService.disableDraggedCloneNodeFollowMouse();
      }
      if (this.dragDropService.dragOriginPlaceholder) {
        this.removeOriginPlaceholder();
      }
      if (this.dragDropService.batchDragging && this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
        this.dragDropService.batchDragData.map((dragData) => dragData.draggable).filter((draggable) => draggable && draggable !== this).forEach((draggable) => {
          if (draggable.originPlaceholder && draggable.originPlaceholder.show !== false) {
            draggable.el.nativeElement.style.display = "";
            draggable.removeOriginPlaceholder();
          } else {
            draggable.el.nativeElement.style.display = "";
          }
        });
      }
      if (this.batchDraggable && !this.batchDraggable.batchDragActive) {
        this.batchDraggable.removeFromBatchGroup();
        this.dragDropService.batchDragging = false;
        this.dragDropService.batchDragStyle = void 0;
      }
      if (this.dragDropService.subscription) {
        this.dragDropService.subscription.unsubscribe();
      }
      this.dragDropService.dragData = void 0;
      this.dragDropService.scope = void 0;
      this.dragDropService.draggedEl = void 0;
      this.dragDropService.dragFollow = void 0;
      this.dragDropService.dragFollowOptions = void 0;
      this.dragDropService.dragOffset = void 0;
      this.dragDropService.draggedElIdentity = void 0;
      this.dragDropService.dragPreviewDirective = void 0;
    }
    e.stopPropagation();
    e.preventDefault();
    this.dragEndEvent.emit(e);
  }
  mouseover(e) {
    this.mouseOverElement = e.target;
  }
  allowDrag(e) {
    if (!this.draggable) {
      return false;
    }
    if (this.batchDraggable && !this.batchDraggable.allowAddToBatchGroup()) {
      return false;
    }
    if (this.dragHandle) {
      if (e && e.fromTouch) {
        return true;
      }
      if (!this.mouseOverElement) {
        return false;
      }
      return Utils.matches(this.mouseOverElement, this.dragHandle);
    } else {
      return true;
    }
  }
  applyDragHandleClass() {
    const dragElement = this.getDragHandleElement();
    if (!dragElement) {
      return;
    }
    if (this.draggable) {
      Utils.addClass(dragElement, this.dragHandleClass);
    } else {
      Utils.removeClass(this.el, this.dragHandleClass);
    }
  }
  getDragHandleElement() {
    let dragElement = this.el;
    if (this.dragHandle) {
      dragElement = this.el.nativeElement.querySelector(this.dragHandle);
    }
    return dragElement;
  }
  mousePosition(event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  findNextSibling(currentNextSibling) {
    if (!this.dragDropService.batchDragData) {
      return currentNextSibling;
    } else {
      if (this.dragDropService.batchDragData.map((dragData) => dragData.draggable && dragData.draggable.el.nativeElement).indexOf(currentNextSibling) > -1) {
        currentNextSibling = currentNextSibling.nextSibling;
      }
      return currentNextSibling;
    }
  }
  checkAndGetViewPointChange(element) {
    if (!element.parentNode) {
      return null;
    }
    const elementPosition = element.getBoundingClientRect();
    const testEl = this.document.createElement("div");
    Utils.addElStyles(testEl, {
      opacity: "0",
      position: "fixed",
      top: elementPosition.top + "px",
      left: elementPosition.left + "px",
      width: "1px",
      height: "1px",
      zIndex: "-999999"
    });
    element.parentNode.appendChild(testEl);
    const testElPosition = testEl.getBoundingClientRect();
    element.parentNode.removeChild(testEl);
    return {
      offsetX: testElPosition.left - elementPosition.left,
      offsetY: testElPosition.top - elementPosition.top
    };
  }
}
DraggableDirective.INSTANCE_KEY = "__vueDevuiDraggableDirectiveInstance";
DraggableDirective.TOKEN = Symbol("DRAGGABLE_DIRECTIVE_TOKEN");
var Draggable = {
  mounted(el, binding, vNode) {
    var _a, _b, _c;
    const context2 = (_a = vNode.ctx) == null ? void 0 : _a.provides;
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    let dragPreviewDirective = injectFromContext(DragPreviewDirective.TOKEN, context2);
    if ((dragPreviewDirective == null ? void 0 : dragPreviewDirective.el.nativeElement) !== el) {
      dragPreviewDirective = void 0;
    }
    const draggableDirective = el[DraggableDirective.INSTANCE_KEY] = new DraggableDirective(el, dragDropService, dragPreviewDirective);
    provideToContext(DraggableDirective.TOKEN, draggableDirective, context2);
    draggableDirective.setInput(binding.value);
    draggableDirective.mounted();
    (_b = draggableDirective.ngOnInit) == null ? void 0 : _b.call(draggableDirective);
    (_c = draggableDirective.ngAfterViewInit) == null ? void 0 : _c.call(draggableDirective);
  },
  updated(el, binding) {
    const draggableDirective = el[DraggableDirective.INSTANCE_KEY];
    draggableDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const draggableDirective = el[DraggableDirective.INSTANCE_KEY];
    (_a = draggableDirective.ngOnDestroy) == null ? void 0 : _a.call(draggableDirective);
  }
};
class DropEvent {
  constructor(event, data, dropSubject, dropIndex, dragFromIndex, dropOnItem, dropOnOrigin, batchDragData) {
    this.nativeEvent = event;
    this.dragData = data;
    this.dropSubject = dropSubject;
    this.dropIndex = dropIndex;
    this.dragFromIndex = dragFromIndex;
    this.dropOnItem = dropOnItem;
    this.dropOnOrigin = dropOnOrigin;
    this.batchDragData = batchDragData;
  }
}
class DroppableDirective extends NgDirectiveBase {
  constructor(el, dragDropService) {
    super();
    this.hostListenerMap = {
      drop: "drop"
    };
    this.dragEnterEvent = new EventEmitter();
    this.dragOverEvent = new EventEmitter();
    this.dragLeaveEvent = new EventEmitter();
    this.dropEvent = new EventEmitter();
    this.dropScope = "default";
    this.placeholderTag = "div";
    this.placeholderStyle = { backgroundColor: ["#859bff", `var(--devui-brand-foil, #859bff)`], opacity: ".4" };
    this.placeholderText = "";
    this.allowDropOnItem = false;
    this.switchWhileCrossEdge = false;
    this.defaultDropPosition = "closest";
    this.dragCount = 0;
    this.dropIndex = void 0;
    this.placeholderInsertionEvent = new Subject();
    this.placeholderRenderEvent = new Subject();
    this.el = { nativeElement: null };
    this.dropSortCountSelectorFilterFn = (value) => {
      return Utils.matches(value, this.dropSortCountSelector) || value.contains(this.placeholder) || value === this.dragDropService.dragOriginPlaceholder;
    };
    this.setPlaceholder = () => {
      this.placeholder.style.width = this.dragDropService.dragOffset.width + "px";
      this.placeholder.style.height = this.dragDropService.dragOffset.height + "px";
      Utils.addElStyles(this.placeholder, this.placeholderStyle);
      this.placeholderRenderEvent.next({ width: this.dragDropService.dragOffset.width, height: this.dragDropService.dragOffset.height });
    };
    this.document = window.document;
    this.el.nativeElement = el;
    this.dragDropService = dragDropService;
  }
  ngOnInit() {
    this.placeholder = this.document.createElement(this.placeholderTag);
    this.placeholder.className = "drag-placeholder";
    this.placeholder.innerText = this.placeholderText;
    this.dragStartSubscription = this.dragDropService.dragStartEvent.subscribe(() => this.setPlaceholder());
    if (this.dragDropService.draggedEl) {
      this.setPlaceholder();
    }
    this.dropEndSubscription = this.dragDropService.dropEvent.subscribe(() => {
      if (this.dragDropService.draggedEl) {
        if (!this.dragDropService.dragFollow) {
          Utils.addElStyles(this.dragDropService.draggedEl, { display: "" });
          this.dragDropService.dragElShowHideEvent.next(true);
        }
      }
      this.removePlaceholder();
      this.overElement = void 0;
      this.allowDropCache = void 0;
      this.dragElIndex = void 0;
      this.dropIndex = void 0;
    });
    this.dragEndSubscription = this.dragDropService.dragEndEvent.subscribe(() => {
      if (this.dragDropService.draggedEl) {
        if (!this.dragDropService.dragFollow) {
          Utils.addElStyles(this.dragDropService.draggedEl, { display: "" });
          this.dragDropService.dragElShowHideEvent.next(true);
        }
      }
      this.removePlaceholder();
      this.dragCount = 0;
      this.overElement = void 0;
      this.allowDropCache = void 0;
      this.dragElIndex = void 0;
      this.dropIndex = void 0;
    });
    this.dragPartEventSub = new Subscription();
    this.dragPartEventSub.add(
      fromEvent(this.el.nativeElement, "dragover").pipe(
        filter((event) => this.allowDrop(event)),
        distinctUntilChanged((prev, current) => {
          const bool = prev.clientX === current.clientX && prev.clientY === current.clientY && prev.target === current.target;
          if (bool) {
            current.preventDefault();
            current.stopPropagation();
          }
          return bool;
        })
      ).subscribe((event) => this.dragOver(event))
    );
    this.dragPartEventSub.add(fromEvent(this.el.nativeElement, "dragenter").subscribe((event) => this.dragEnter(event)));
    this.dragPartEventSub.add(fromEvent(this.el.nativeElement, "dragleave").subscribe((event) => this.dragLeave(event)));
  }
  ngAfterViewInit() {
    if (this.el.nativeElement.hasAttribute("d-sortable")) {
      this.sortContainer = this.el.nativeElement;
    } else {
      this.sortContainer = this.el.nativeElement.querySelector("[d-sortable]");
    }
    this.sortDirection = this.sortContainer ? this.sortContainer.getAttribute("dsortable") || "v" : "v";
    this.sortDirectionZMode = this.sortContainer ? this.sortContainer.getAttribute("d-sortable-zmode") === "true" || false : false;
  }
  ngOnDestroy() {
    var _a, _b, _c;
    (_a = this.dragStartSubscription) == null ? void 0 : _a.unsubscribe();
    (_b = this.dragEndSubscription) == null ? void 0 : _b.unsubscribe();
    (_c = this.dropEndSubscription) == null ? void 0 : _c.unsubscribe();
    if (this.dragPartEventSub) {
      this.dragPartEventSub.unsubscribe();
    }
  }
  dragEnter(e) {
    this.dragCount++;
    e.preventDefault();
    this.dragEnterEvent.emit(e);
  }
  dragOver(e) {
    if (this.allowDrop(e)) {
      if (this.dragDropService.dropTargets.indexOf(this.el) === -1) {
        this.dragDropService.dropTargets.forEach((el) => {
          const placeHolderEl = el.nativeElement.querySelector(".drag-placeholder");
          if (placeHolderEl) {
            placeHolderEl.parentElement.removeChild(placeHolderEl);
          }
          Utils.removeClass(el, this.dragOverClass);
          this.removeDragoverItemClass(el.nativeElement);
        });
        this.dragDropService.dropTargets = [this.el];
        this.overElement = void 0;
      }
      Utils.addClass(this.el, this.dragOverClass);
      const hitPlaceholder = this.dragDropService.dragOriginPlaceholder && this.dragDropService.dragOriginPlaceholder.contains(e.target);
      if (this.sortContainer && (hitPlaceholder && this.overElement === void 0 || !(e.target.contains(this.placeholder) || hitPlaceholder) || this.switchWhileCrossEdge && !this.placeholder.contains(e.target) && !hitPlaceholder || !this.sortContainer.contains(e.target) && this.defaultDropPosition === "closest")) {
        const overElement = this.findSortableEl(e);
        if (!(this.overElement && overElement) || this.overElement.index !== overElement.index || this.allowDropOnItem && this.overElement.position !== overElement.position && (this.overElement.position === "inside" || overElement.position === "inside")) {
          this.overElement = overElement;
          this.insertPlaceholder(overElement);
          this.removeDragoverItemClass(this.sortContainer, overElement);
          if (overElement.position === "inside" && this.dragOverItemClass) {
            Utils.addClass(overElement.el, this.dragOverItemClass);
          }
        } else {
          this.overElement = overElement;
        }
      } else {
        if (this.sortContainer && this.overElement && this.overElement.el) {
          if (!this.overElement.el.contains(e.target)) {
            this.overElement.realEl = e.target;
          } else {
            this.overElement.realEl = void 0;
          }
        }
      }
      if (this.dragDropService.draggedEl) {
        if (!this.dragDropService.dragFollow) {
          Utils.addElStyles(this.dragDropService.draggedEl, { display: "none" });
          this.dragDropService.dragElShowHideEvent.next(false);
          if (this.dragDropService.dragOriginPlaceholder) {
            Utils.addElStyles(this.dragDropService.dragOriginPlaceholder, { display: "block" });
          }
        }
      }
      e.preventDefault();
      e.stopPropagation();
      this.dragOverEvent.emit(e);
    }
  }
  dragLeave(e) {
    this.dragCount--;
    if (this.dragCount === 0) {
      if (this.dragDropService.dropTargets.indexOf(this.el) !== -1) {
        this.dragDropService.dropTargets = [];
      }
      Utils.removeClass(this.el, this.dragOverClass);
      this.removePlaceholder();
      this.removeDragoverItemClass(this.el.nativeElement);
      this.overElement = void 0;
      this.dragElIndex = void 0;
      this.dropIndex = void 0;
    }
    e.preventDefault();
    this.dragLeaveEvent.emit(e);
  }
  drop(e) {
    if (!this.allowDrop(e)) {
      return;
    }
    this.dragCount = 0;
    Utils.removeClass(this.el, this.dragOverClass);
    this.removeDragoverItemClass(this.sortContainer);
    this.removePlaceholder();
    e.preventDefault();
    e.stopPropagation();
    this.dragDropService.dropOnOrigin = this.isDragPlaceholderPosition(this.dropIndex);
    const draggedElIdentity = this.dragDropService.draggedElIdentity;
    this.dragDropService.draggedElIdentity = void 0;
    let batchDraggble = [];
    if (this.dragDropService.batchDragData && this.dragDropService.batchDragData.length > 1) {
      batchDraggble = this.dragDropService.batchDragData.map((dragData) => dragData.draggable).filter((draggable) => draggable && draggable.el.nativeElement !== this.dragDropService.draggedEl);
    }
    this.dropEvent.emit(
      new DropEvent(
        e,
        this.dragDropService.dragData,
        this.dragDropService.dropEvent,
        this.dropSortVirtualScrollOption ? this.getRealIndex(this.dropIndex, this.dropFlag) : this.dropIndex,
        this.sortContainer ? this.checkSelfFromIndex(this.dragDropService.draggedEl) : -1,
        this.dragDropService.dropOnItem,
        this.dragDropService.dropOnOrigin,
        this.dragDropService.batchDragging ? this.dragDropService.getBatchDragData(draggedElIdentity) : void 0
      )
    );
    if (this.dragDropService.dragFollow) {
      this.dragDropService.disableDraggedCloneNodeFollowMouse();
    } else {
      Utils.addElStyles(this.dragDropService.draggedEl, { display: void 0 });
      this.dragDropService.dragElShowHideEvent.next(false);
    }
    if (batchDraggble.length > 0 && this.dragDropService.batchDragging) {
      batchDraggble.forEach((draggable) => {
        if (!draggable.originPlaceholder || draggable.originPlaceholder.show === false) {
          draggable.el.nativeElement.style.display = "";
        } else if (draggable.originPlaceholder.removeDelay > 0 && !this.dragDropService.dropOnOrigin) {
          draggable.delayRemoveOriginPlaceholder(false);
        } else {
          draggable.el.nativeElement.style.display = "";
          draggable.removeOriginPlaceholder(false);
        }
      });
    }
    this.dragDropService.dropEvent.next(e);
    this.dragDropService.dragData = void 0;
    this.dragDropService.scope = void 0;
    this.dragDropService.draggedEl = void 0;
    this.dragDropService.dragFollow = void 0;
    this.dragDropService.dragFollowOptions = void 0;
    this.dragDropService.dragOffset = void 0;
    this.dragDropService.dropOnOrigin = void 0;
    this.dragDropService.batchDragging = false;
    this.dragDropService.batchDragStyle = void 0;
    this.dragDropService.dragPreviewDirective = void 0;
  }
  allowDrop(e) {
    if (!e) {
      return false;
    }
    if (this.allowDropCache !== void 0) {
      return this.allowDropCache;
    }
    let allowed = false;
    if (typeof this.dropScope === "string") {
      if (typeof this.dragDropService.scope === "string") {
        allowed = this.dragDropService.scope === this.dropScope;
      }
      if (this.dragDropService.scope instanceof Array) {
        allowed = this.dragDropService.scope.indexOf(this.dropScope) > -1;
      }
    }
    if (this.dropScope instanceof Array) {
      if (typeof this.dragDropService.scope === "string") {
        allowed = this.dropScope.indexOf(this.dragDropService.scope) > -1;
      }
      if (this.dragDropService.scope instanceof Array) {
        allowed = this.dropScope.filter((item) => {
          return this.dragDropService.scope.indexOf(item) !== -1;
        }).length > 0;
      }
    }
    this.allowDropCache = allowed;
    return allowed;
  }
  findSortableEl(event) {
    var _a;
    const moveElement = event.target;
    let overElement = null;
    if (!this.sortContainer) {
      return overElement;
    }
    overElement = { index: 0, el: null, position: "before" };
    this.dropIndex = 0;
    this.dropFlag = void 0;
    let childEls = Utils.slice(this.sortContainer.children);
    if (this.dropSortCountSelector) {
      childEls = childEls.filter(this.dropSortCountSelectorFilterFn);
    }
    if (childEls.some((el) => el !== this.dragDropService.dragOriginPlaceholder && el.classList.contains("drag-origin-placeholder"))) {
      childEls = childEls.filter(
        (el) => !(el.classList.contains("drag-origin-placeholder") && el !== this.dragDropService.dragOriginPlaceholder)
      );
    }
    if (this.dragDropService.dragFollow && this.dragDropService.dragCloneNode) {
      const cloneNodeIndex = childEls.findIndex((value) => value === this.dragDropService.dragCloneNode);
      if (-1 !== cloneNodeIndex) {
        childEls.splice(cloneNodeIndex, 1);
      }
    }
    if (this.dragDropService.dragOriginPlaceholder) {
      const dragOriginPlaceholderIndex = childEls.findIndex((value) => value === this.dragDropService.dragOriginPlaceholder);
      if (-1 !== dragOriginPlaceholderIndex) {
        this.dragElIndex = dragOriginPlaceholderIndex - 1;
        childEls.splice(dragOriginPlaceholderIndex, 1);
      } else {
        this.dragElIndex = -1;
      }
    } else {
      this.dragElIndex = -1;
    }
    const placeholderIndex = childEls.findIndex((value) => value.contains(this.placeholder));
    if (-1 !== placeholderIndex) {
      childEls.splice(placeholderIndex, 1);
    }
    if (-1 !== placeholderIndex && -1 !== this.dragElIndex && placeholderIndex < this.dragElIndex) {
      this.dragElIndex--;
    }
    const positionIndex = -1 !== placeholderIndex ? placeholderIndex : this.dragElIndex;
    const currentIndex = childEls.findIndex(
      (value) => value.contains(moveElement) || value.nextElementSibling === moveElement && value.nextElementSibling.classList.contains("drag-origin-placeholder")
    );
    if (this.switchWhileCrossEdge && !this.allowDropOnItem && childEls.length && -1 !== positionIndex && currentIndex > -1) {
      const lastIndex = positionIndex;
      const realEl = this.overElement && (this.overElement.realEl || this.overElement.el);
      if (-1 !== currentIndex && realEl === childEls[currentIndex]) {
        this.dropIndex = this.overElement.index;
        return this.overElement;
      }
      overElement = {
        index: lastIndex > currentIndex ? currentIndex : currentIndex + 1,
        el: childEls[currentIndex],
        position: lastIndex > currentIndex ? "before" : "after"
      };
      this.dragDropService.dropOnItem = false;
      this.dropIndex = overElement.index;
      return overElement;
    }
    if (moveElement === this.sortContainer || ((_a = moveElement.classList) == null ? void 0 : _a.contains("drag-origin-placeholder")) || moveElement === (this.dragDropService && this.dragDropService.dragOriginPlaceholder) || !this.sortContainer.contains(moveElement) && this.defaultDropPosition === "closest") {
      if (!childEls.length) {
        this.dropIndex = 0;
        this.dragDropService.dropOnItem = false;
        return overElement;
      }
      let findInGap = false;
      for (let i = 0; i < childEls.length; i++) {
        const targetElement = childEls[i];
        if (childEls[i].nextSibling === moveElement && moveElement.classList.contains("drag-origin-placeholder")) {
          const position = this.calcPosition(event, moveElement);
          this.dragDropService.dropOnItem = position === "inside";
          overElement = { index: position === "after" ? i + 1 : i, el: childEls[i], position };
          this.dropIndex = overElement.index;
          return overElement;
        }
        const positionOutside = this.calcPositionOutside(event, targetElement);
        if (positionOutside === "before") {
          this.dragDropService.dropOnItem = false;
          overElement = { index: i, el: childEls[i], position: positionOutside, realEl: moveElement };
          this.dropIndex = overElement.index;
          findInGap = true;
          break;
        }
      }
      if (!findInGap) {
        this.dragDropService.dropOnItem = false;
        overElement = { index: childEls.length, el: childEls[childEls.length - 1], position: "after", realEl: moveElement };
        this.dropIndex = childEls.length;
      }
      return overElement;
    }
    if (!this.sortContainer.contains(moveElement)) {
      if (this.defaultDropPosition === "before") {
        overElement = { index: 0, el: childEls.length ? childEls[0] : null, position: "before", realEl: moveElement };
        this.dropFlag = "beforeAll";
      } else {
        overElement = {
          index: childEls.length,
          el: childEls.length ? childEls[childEls.length - 1] : null,
          position: "after",
          realEl: moveElement
        };
        this.dropFlag = "afterAll";
      }
      this.dropIndex = overElement.index;
      return overElement;
    }
    let find = false;
    for (let i = 0; i < childEls.length; i++) {
      if (childEls[i].contains(moveElement)) {
        const targetElement = childEls[i];
        const position = this.calcPosition(event, targetElement);
        this.dragDropService.dropOnItem = position === "inside";
        overElement = { index: position === "after" ? i + 1 : i, el: childEls[i], position };
        this.dropIndex = overElement.index;
        find = true;
        break;
      }
    }
    if (!find) {
      if (childEls.length) {
        overElement = { index: childEls.length, el: childEls[childEls.length - 1], position: "after" };
      }
      this.dropIndex = childEls.length;
      this.dragDropService.dropOnItem = false;
    }
    return overElement;
  }
  calcPosition(event, targetElement) {
    const rect = targetElement.getBoundingClientRect();
    const relY = event.clientY - (rect.y || rect.top);
    const relX = event.clientX - (rect.x || rect.left);
    if (this.allowDropOnItem) {
      const dropOnItemEdge = {
        height: this.nestingTargetRect && this.nestingTargetRect.height || rect.height,
        width: this.nestingTargetRect && this.nestingTargetRect.width || rect.width
      };
      const threeQuartersOfHeight = dropOnItemEdge.height * 3 / 4;
      const threeQuartersOfWidth = dropOnItemEdge.width * 3 / 4;
      const AQuarterOfHeight = Number(dropOnItemEdge.height) / 4;
      const AQuarterOfWidth = Number(dropOnItemEdge.width) / 4;
      if (this.sortDirectionZMode) {
        const slashPosition = relY / dropOnItemEdge.height + relX / dropOnItemEdge.width;
        if (slashPosition > 0.3 && slashPosition <= 0.7) {
          return "inside";
        } else if (slashPosition > 0.7) {
          const slashPositionNesting = (relY - rect.height + dropOnItemEdge.height) / dropOnItemEdge.height + (relX - rect.width + dropOnItemEdge.width) / dropOnItemEdge.width;
          if (slashPositionNesting <= 0.7) {
            return "inside";
          }
        }
      }
      if (this.sortDirection === "v" && relY > AQuarterOfHeight && relY <= threeQuartersOfHeight || this.sortDirection !== "v" && relX > AQuarterOfWidth && relX <= threeQuartersOfWidth) {
        return "inside";
      } else if (this.sortDirection === "v" && relY > threeQuartersOfHeight && relY <= rect.height - AQuarterOfHeight || this.sortDirection !== "v" && relX > threeQuartersOfWidth && relX <= rect.width - AQuarterOfWidth) {
        return "inside";
      }
    }
    if (this.sortDirectionZMode) {
      if (relY / rect.height + relX / rect.width < 1) {
        return "before";
      }
      return "after";
    }
    if (this.sortDirection === "v" && relY > rect.height / 2 || this.sortDirection !== "v" && relX > rect.width / 2) {
      return "after";
    }
    return "before";
  }
  calcPositionOutside(event, targetElement) {
    const rect = this.getBoundingRectAndRealPosition(targetElement);
    const relY = event.clientY - (rect.y || rect.top);
    const relX = event.clientX - (rect.x || rect.left);
    if (this.sortDirectionZMode) {
      if (this.sortDirection === "v" && (relY < 0 || relY < rect.height && relX < 0) || this.sortDirection !== "v" && (relX < 0 || relX < rect.width && relY < 0)) {
        return "before";
      }
      return "notsure";
    }
    if (this.sortDirection === "v" && relY < rect.height / 2 || this.sortDirection !== "v" && relX < rect.width / 2) {
      return "before";
    }
    return "notsure";
  }
  insertPlaceholder(overElement) {
    const tempScrollTop = this.sortContainer.scrollTop;
    const tempScrollLeft = this.sortContainer.scrollLeft;
    let hitPlaceholder = false;
    let cmd;
    const getIndex = (arr, el, defaultValue) => {
      const index2 = arr.indexOf(el);
      return index2 > -1 ? index2 : defaultValue;
    };
    if (null !== overElement) {
      const sortContainerChildren = Utils.slice(this.sortContainer.children).filter(
        (el) => el !== this.dragDropService.dragCloneNode
      );
      if (overElement.el === null) {
        cmd = {
          command: "append"
        };
        this.sortContainer.appendChild(this.placeholder);
      } else {
        if (overElement.position === "inside") {
          cmd = {
            command: "remove"
          };
          this.removePlaceholder();
        } else if (this.dragDropService.dragOriginPlaceholder && this.isDragPlaceholderPosition(overElement.index)) {
          cmd = {
            command: "remove"
          };
          this.removePlaceholder();
          hitPlaceholder = true;
        } else if (overElement.position === "after") {
          if (overElement.el.nextSibling && overElement.el.nextSibling.classList && overElement.el.nextSibling.classList.contains("drag-origin-placeholder")) {
            cmd = {
              command: "insertBefore",
              index: getIndex(sortContainerChildren, overElement.el.nextSibling, sortContainerChildren.length) + 1
            };
            this.sortContainer.insertBefore(this.placeholder, overElement.el.nextSibling.nextSibling);
          } else {
            cmd = {
              command: "insertBefore",
              index: getIndex(sortContainerChildren, overElement.el, sortContainerChildren.length) + 1
            };
            this.sortContainer.insertBefore(this.placeholder, overElement.el.nextSibling);
          }
        } else {
          cmd = {
            command: "insertBefore",
            index: getIndex(sortContainerChildren, overElement.el, sortContainerChildren.length)
          };
          this.sortContainer.insertBefore(this.placeholder, overElement.el);
        }
      }
    }
    this.placeholderInsertionEvent.next(cmd);
    this.sortContainer.scrollTop = tempScrollTop;
    this.sortContainer.scrollLeft = tempScrollLeft;
    if (this.dragDropService.dragOriginPlaceholder) {
      if (hitPlaceholder) {
        this.hitDragOriginPlaceholder();
      } else {
        this.hitDragOriginPlaceholder(false);
      }
    }
  }
  isDragPlaceholderPosition(index2) {
    if (this.dragElIndex > -1 && (index2 === this.dragElIndex || index2 === this.dragElIndex + 1)) {
      return true;
    } else {
      return false;
    }
  }
  hitDragOriginPlaceholder(bool = true) {
    const placeholder = this.dragDropService.dragOriginPlaceholder;
    if (bool) {
      placeholder.classList.add("hit-origin-placeholder");
    } else {
      placeholder.classList.remove("hit-origin-placeholder");
    }
  }
  removePlaceholder() {
    if (this.sortContainer && this.sortContainer.contains(this.placeholder)) {
      this.sortContainer.removeChild(this.placeholder);
      this.placeholderInsertionEvent.next({
        command: "remove"
      });
    }
  }
  removeDragoverItemClass(container, overElement) {
    if (this.dragOverItemClass) {
      const dragOverItemClassGroup = container.querySelectorAll("." + this.dragOverItemClass);
      if (dragOverItemClassGroup && dragOverItemClassGroup.length > 0) {
        for (const element of dragOverItemClassGroup) {
          if (overElement) {
            if (element !== overElement.el || overElement.position !== "inside") {
              Utils.removeClass(element, this.dragOverItemClass);
            }
          } else {
            Utils.removeClass(element, this.dragOverItemClass);
          }
        }
      }
    }
  }
  checkSelfFromIndex(el) {
    let fromIndex = -1;
    if (!this.sortContainer.contains(el)) {
      return fromIndex;
    }
    let children = Utils.slice(this.sortContainer.children);
    if (this.dropSortCountSelector) {
      children = children.filter(this.dropSortCountSelectorFilterFn);
    }
    for (let i = 0; i < children.length; i++) {
      if (children[i].contains(this.dragDropService.draggedEl)) {
        fromIndex = i;
        break;
      }
    }
    return this.getRealIndex(fromIndex);
  }
  getRealIndex(index2, flag) {
    let realIndex;
    const startIndex = this.dropSortVirtualScrollOption && this.dropSortVirtualScrollOption.startIndex || 0;
    const totalLength = this.dropSortVirtualScrollOption && this.dropSortVirtualScrollOption.totalLength;
    if (flag === "beforeAll") {
      realIndex = 0;
    } else if (flag === "afterAll") {
      realIndex = totalLength || index2;
    } else {
      realIndex = startIndex + index2;
    }
    return realIndex;
  }
  getBoundingRectAndRealPosition(targetElement) {
    let rect = targetElement.getBoundingClientRect();
    const { bottom, right, width, height } = rect;
    if (rect.width === 0 && rect.height === 0 && (targetElement.style.display === "none" || getComputedStyle(targetElement).display === "none")) {
      if (targetElement.nextElementSibling) {
        const { top: realTop, left: realLeft } = targetElement.nextElementSibling.getBoundingClientRect();
        rect = { x: realLeft, y: realTop, top: realTop, left: realLeft, bottom, right, width, height };
      }
    }
    return rect;
  }
  getSortContainer() {
    return this.sortContainer;
  }
}
DroppableDirective.INSTANCE_KEY = "__vueDevuiDroppableDirectiveInstance";
DroppableDirective.TOKEN = Symbol("DROPPABLE_DIRECTIVE_TOKEN");
var Droppable = {
  mounted(el, binding, vNode) {
    var _a;
    const context2 = vNode["ctx"].provides;
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    const droppableDirective = el[DroppableDirective.INSTANCE_KEY] = new DroppableDirective(el, dragDropService);
    provideToContext(DroppableDirective.TOKEN, droppableDirective, context2);
    droppableDirective.setInput(binding.value);
    droppableDirective.mounted();
    (_a = droppableDirective.ngOnInit) == null ? void 0 : _a.call(droppableDirective);
    setTimeout(() => {
      var _a2;
      (_a2 = droppableDirective.ngAfterViewInit) == null ? void 0 : _a2.call(droppableDirective);
    }, 0);
  },
  updated(el, binding) {
    const droppableDirective = el[DroppableDirective.INSTANCE_KEY];
    droppableDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const droppableDirective = el[DroppableDirective.INSTANCE_KEY];
    (_a = droppableDirective.ngOnDestroy) == null ? void 0 : _a.call(droppableDirective);
  }
};
class SortableDirective extends NgDirectiveBase {
  constructor(el) {
    super();
    this.dSortDirection = "v";
    this.dSortableZMode = false;
    this.dSortable = true;
    this.hostBindingMap = {
      dSortDirection: "dsortable",
      dSortableZMode: "d-sortable-zmode",
      dSortable: "d-sortable"
    };
    this.inputNameMap = {
      dSortable: "dSortDirection"
    };
    this.el = { nativeElement: null };
    this.el.nativeElement = el;
  }
}
SortableDirective.INSTANCE_KEY = "__vueDevuiSortableDirectiveInstance";
var Sortable = {
  mounted(el, binding) {
    const sortableDirective = el[SortableDirective.INSTANCE_KEY] = new SortableDirective(el);
    sortableDirective.setInput(binding.value);
    sortableDirective.mounted();
  },
  updated(el, binding) {
    const sortableDirective = el[SortableDirective.INSTANCE_KEY];
    sortableDirective.updateInput(binding.value, binding.oldValue);
  }
};
var DropScrollOrientation = /* @__PURE__ */ ((DropScrollOrientation2) => {
  DropScrollOrientation2[DropScrollOrientation2["forward"] = 0] = "forward";
  DropScrollOrientation2[DropScrollOrientation2["backward"] = 1] = "backward";
  return DropScrollOrientation2;
})(DropScrollOrientation || {});
const DropScrollEnhanceTimingFunctionGroup = {
  default: (x) => Math.ceil((1 - x) * 18) * 100
};
class DropScrollEnhancedDirective extends NgDirectiveBase {
  constructor(el, dragDropService) {
    super();
    this.minSpeed = 50;
    this.maxSpeed = 1e3;
    this.responseEdgeWidth = "100px";
    this.speedFn = DropScrollEnhanceTimingFunctionGroup.default;
    this.direction = "v";
    this.backSpaceDroppable = true;
    this.subscription = new Subscription();
    this.el = { nativeElement: null };
    this.el.nativeElement = el;
    this.dragDropService = dragDropService;
    this.document = window.document;
  }
  ngAfterViewInit() {
    this.el.nativeElement.parentNode.style.position = "relative";
    this.el.nativeElement.parentNode.style.display = "block";
    this.forwardScrollArea = this.createScrollArea(this.direction, 0);
    this.backwardScrollArea = this.createScrollArea(this.direction, 1);
    this.forwardScrollFn = this.createScrollFn(this.direction, 0, this.speedFn);
    this.backwardScrollFn = this.createScrollFn(this.direction, 1, this.speedFn);
    this.subscription.add(
      fromEvent(this.forwardScrollArea, "dragover").pipe(
        tap((event) => {
          event.preventDefault();
          event.stopPropagation();
        }),
        throttleTime(100, void 0, { leading: true, trailing: false })
      ).subscribe((event) => this.forwardScrollFn(event))
    );
    this.subscription.add(
      fromEvent(this.backwardScrollArea, "dragover").pipe(
        tap((event) => {
          event.preventDefault();
          event.stopPropagation();
        }),
        throttleTime(100, void 0, { leading: true, trailing: false })
      ).subscribe((event) => this.backwardScrollFn(event))
    );
    this.subscription.add(
      merge(fromEvent(this.forwardScrollArea, "drop"), fromEvent(this.backwardScrollArea, "drop")).subscribe(
        (event) => this.delegateDropEvent(event)
      )
    );
    this.subscription.add(
      merge(
        fromEvent(this.forwardScrollArea, "dragleave", { passive: true }),
        fromEvent(this.backwardScrollArea, "dragleave", { passive: true })
      ).subscribe((event) => this.cleanLastScrollTime())
    );
    this.subscription.add(
      fromEvent(this.el.nativeElement, "scroll", { passive: true }).pipe(throttleTime(300, void 0, { leading: true, trailing: true })).subscribe((event) => {
        this.toggleScrollToOneEnd(this.el.nativeElement, this.forwardScrollArea, this.direction, 0);
        this.toggleScrollToOneEnd(this.el.nativeElement, this.backwardScrollArea, this.direction, 1);
      })
    );
    this.subscription.add(
      fromEvent(window, "resize", { passive: true }).pipe(throttleTime(300, void 0, { leading: true, trailing: true })).subscribe((event) => this.resizeArea())
    );
    this.subscription.add(
      this.dragDropService.dragStartEvent.subscribe(() => {
        if (!this.allowScroll()) {
          return;
        }
        setTimeout(() => {
          this.forwardScrollArea.style.display = "block";
          this.backwardScrollArea.style.display = "block";
        });
      })
    );
    this.subscription.add(
      merge(this.dragDropService.dragEndEvent, this.dragDropService.dropEvent).subscribe(() => {
        this.forwardScrollArea.style.display = "none";
        this.backwardScrollArea.style.display = "none";
        this.lastScrollTime = void 0;
      })
    );
    setTimeout(() => {
      this.resizeArea();
    }, 0);
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  createScrollFn(direction, orientation, speedFn) {
    if (typeof window === "undefined") {
      return;
    }
    const scrollAttr = direction === "v" ? "scrollTop" : "scrollLeft";
    const eventAttr = direction === "v" ? "clientY" : "clientX";
    const scrollWidthAttr = direction === "v" ? "scrollHeight" : "scrollWidth";
    const offsetWidthAttr = direction === "v" ? "offsetHeight" : "offsetWidth";
    const clientWidthAttr = direction === "v" ? "clientHeight" : "clientWidth";
    const rectWidthAttr = direction === "v" ? "height" : "width";
    const compareTarget = orientation === 0 ? this.forwardScrollArea : this.backwardScrollArea;
    const targetAttr = this.getCriticalEdge(direction, orientation);
    const scrollElement = this.el.nativeElement;
    return (event) => {
      const compareTargetRect = compareTarget.getBoundingClientRect();
      const distance = event[eventAttr] - compareTargetRect[targetAttr];
      let speed = speedFn(Math.abs(distance / (compareTargetRect[rectWidthAttr] || 1)));
      if (speed < this.minSpeed) {
        speed = this.minSpeed;
      }
      if (speed > this.maxSpeed) {
        speed = this.maxSpeed;
      }
      if (distance < 0) {
        speed = -speed;
      }
      if (this.animationFrameId) {
        window.cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = void 0;
      }
      this.animationFrameId = requestAnimationFrame(() => {
        const time = new Date().getTime();
        const moveDistance = Math.ceil(speed * (time - (this.lastScrollTime || time)) / 1e3);
        scrollElement[scrollAttr] -= moveDistance;
        this.lastScrollTime = time;
        if (scrollElement[scrollAttr] === 0 && orientation === 1 || scrollElement[scrollAttr] + scrollElement.getBoundingClientRect()[rectWidthAttr] - scrollElement[offsetWidthAttr] + scrollElement[clientWidthAttr] === scrollElement[scrollWidthAttr] && orientation === 0) {
          compareTarget.style.pointerEvents = "none";
          this.toggleActiveClass(compareTarget, false);
        }
        this.animationFrameId = void 0;
      });
      if (this.backSpaceDroppable) {
        Utils.dispatchEventToUnderElement(event);
      }
    };
  }
  delegateDropEvent(event) {
    if (this.backSpaceDroppable) {
      const ev = Utils.dispatchEventToUnderElement(event);
      if (ev.defaultPrevented) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }
  getCriticalEdge(direction, orientation) {
    return direction === "v" && orientation === 0 && "bottom" || direction === "v" && orientation === 1 && "top" || direction !== "v" && orientation === 0 && "right" || direction !== "v" && orientation === 1 && "left" || "bottom";
  }
  getSecondEdge(direction) {
    return direction === "v" && "left" || direction !== "v" && "top" || "left";
  }
  createScrollArea(direction, orientation) {
    const area = this.document.createElement("div");
    area.className = `dropover-scroll-area dropover-scroll-area-${this.getCriticalEdge(direction, orientation)}`;
    area.classList.add("active");
    this.setAreaSize(area, direction, orientation);
    area.style.position = "absolute";
    this.setAreaStyleLayout(area, direction, orientation);
    area.style.display = "none";
    this.el.nativeElement.parentNode.appendChild(area, this.el.nativeElement);
    return area;
  }
  setAreaSize(area, direction, orientation) {
    const rect = this.el.nativeElement.getBoundingClientRect();
    const containerAttr = direction === "v" ? "height" : "width";
    const responseEdgeWidth = typeof this.responseEdgeWidth === "string" ? this.responseEdgeWidth : this.responseEdgeWidth(rect[containerAttr]);
    const settingOffset = this.viewOffset && (orientation === 0 ? this.viewOffset.forward : this.viewOffset.backward);
    let width = direction === "v" ? rect.width + "px" : responseEdgeWidth;
    let height = direction === "v" ? responseEdgeWidth : rect.height + "px";
    if (settingOffset) {
      if (settingOffset.widthOffset) {
        width = "calc(" + width + " + " + settingOffset.widthOffset + "px)";
      }
      if (settingOffset.heightOffset) {
        height = "calc(" + height + " + " + settingOffset.heightOffset + "px)";
      }
    }
    area.style.width = width;
    area.style.height = height;
  }
  setAreaStyleLayout(area, direction, orientation) {
    const target = this.el.nativeElement;
    const relatedTarget = this.el.nativeElement.parentNode;
    const defaultOffset = { left: 0, right: 0, top: 0, bottom: 0 };
    const settingOffset = this.viewOffset && (orientation === 0 ? this.viewOffset.forward : this.viewOffset.backward) || defaultOffset;
    const criticalEdge = this.getCriticalEdge(direction, orientation);
    const secondEdge = this.getSecondEdge(direction);
    [criticalEdge, secondEdge].forEach((edge) => {
      area.style[edge] = this.getRelatedPosition(target, relatedTarget, edge, settingOffset[edge]);
    });
  }
  getRelatedPosition(target, relatedTarget, edge, offsetValue) {
    if (typeof window === "undefined") {
      return "0px";
    }
    const relatedComputedStyle = window.getComputedStyle(relatedTarget);
    const relatedRect = relatedTarget.getBoundingClientRect();
    const selfRect = target.getBoundingClientRect();
    const helper = {
      left: ["left", "Left"],
      right: ["right", "Right"],
      top: ["top", "Top"],
      bottom: ["bottom", "Bottom"]
    };
    let factor = 1;
    if (edge === "right" || edge === "bottom") {
      factor = -1;
    }
    return (selfRect[helper[edge][0]] - relatedRect[helper[edge][0]] + parseInt(relatedComputedStyle["border" + helper[edge][1] + "Width"], 10)) * factor + (offsetValue || 0) + "px";
  }
  resizeArea() {
    [
      { area: this.forwardScrollArea, orientation: 0 },
      { area: this.backwardScrollArea, orientation: 1 }
    ].forEach((item) => {
      this.setAreaSize(item.area, this.direction, item.orientation);
      this.setAreaStyleLayout(item.area, this.direction, item.orientation);
    });
  }
  toggleScrollToOneEnd(scrollElement, toggleElement, direction, orientation) {
    const scrollAttr = direction === "v" ? "scrollTop" : "scrollLeft";
    const scrollWidthAttr = direction === "v" ? "scrollHeight" : "scrollWidth";
    const offsetWidthAttr = direction === "v" ? "offsetHeight" : "offsetWidth";
    const clientWidthAttr = direction === "v" ? "clientHeight" : "clientWidth";
    const rectWidthAttr = direction === "v" ? "height" : "width";
    if (scrollElement[scrollAttr] === 0 && orientation === 1 || Math.abs(
      scrollElement[scrollAttr] + scrollElement.getBoundingClientRect()[rectWidthAttr] - scrollElement[scrollWidthAttr] - scrollElement[offsetWidthAttr] + scrollElement[clientWidthAttr]
    ) < 1 && orientation === 0) {
      toggleElement.style.pointerEvents = "none";
      this.toggleActiveClass(toggleElement, false);
    } else {
      toggleElement.style.pointerEvents = "auto";
      this.toggleActiveClass(toggleElement, true);
    }
  }
  cleanLastScrollTime() {
    if (this.animationFrameId && typeof window !== "undefined") {
      window.cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = void 0;
    }
    this.lastScrollTime = void 0;
  }
  toggleActiveClass(target, active) {
    if (active) {
      target.classList.remove("inactive");
      target.classList.add("active");
    } else {
      target.classList.remove("active");
      target.classList.add("inactive");
    }
  }
  allowScroll() {
    if (!this.dropScrollScope) {
      return true;
    }
    let allowed = false;
    if (typeof this.dropScrollScope === "string") {
      if (typeof this.dragDropService.scope === "string") {
        allowed = this.dragDropService.scope === this.dropScrollScope;
      }
      if (this.dragDropService.scope instanceof Array) {
        allowed = this.dragDropService.scope.indexOf(this.dropScrollScope) > -1;
      }
    }
    if (this.dropScrollScope instanceof Array) {
      if (typeof this.dragDropService.scope === "string") {
        allowed = this.dropScrollScope.indexOf(this.dragDropService.scope) > -1;
      }
      if (this.dragDropService.scope instanceof Array) {
        allowed = this.dropScrollScope.filter((item) => {
          return this.dragDropService.scope.indexOf(item) !== -1;
        }).length > 0;
      }
    }
    return allowed;
  }
}
DropScrollEnhancedDirective.INSTANCE_KEY = "__vueDevuiDropScrollEnhancedDirectiveInstance";
var DropScrollEnhanced = {
  mounted(el, binding, vNode) {
    const context2 = vNode["ctx"].provides;
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    const droppableDirective = el[DropScrollEnhancedDirective.INSTANCE_KEY] = new DropScrollEnhancedDirective(el, dragDropService);
    droppableDirective.setInput(binding.value);
    droppableDirective.mounted();
    setTimeout(() => {
      var _a;
      (_a = droppableDirective.ngAfterViewInit) == null ? void 0 : _a.call(droppableDirective);
    }, 0);
  },
  updated(el, binding) {
    const droppableDirective = el[DropScrollEnhancedDirective.INSTANCE_KEY];
    droppableDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const droppableDirective = el[DropScrollEnhancedDirective.INSTANCE_KEY];
    (_a = droppableDirective.ngOnDestroy) == null ? void 0 : _a.call(droppableDirective);
  }
};
class DropScrollEnhancedSideDirective extends DropScrollEnhancedDirective {
  constructor() {
    super(...arguments);
    this.inputNameMap = {
      direction: "sideDirection"
    };
    this.sideDirection = "h";
    this.direction = "v";
  }
  ngOnInit() {
    this.direction = this.sideDirection === "v" ? "h" : "v";
  }
}
const DropScrollEnhancedSide = {
  mounted(el, binding, vNode) {
    const context2 = vNode["ctx"].provides;
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    const droppableDirective = el[DropScrollEnhancedSideDirective.INSTANCE_KEY] = new DropScrollEnhancedSideDirective(
      el,
      dragDropService
    );
    droppableDirective.setInput(binding.value);
    droppableDirective.mounted();
    setTimeout(() => {
      var _a;
      (_a = droppableDirective.ngAfterViewInit) == null ? void 0 : _a.call(droppableDirective);
    }, 0);
  },
  updated(el, binding) {
    const droppableDirective = el[DropScrollEnhancedSideDirective.INSTANCE_KEY];
    droppableDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const droppableDirective = el[DropScrollEnhancedSideDirective.INSTANCE_KEY];
    (_a = droppableDirective.ngOnDestroy) == null ? void 0 : _a.call(droppableDirective);
  }
};
class BatchDraggableDirective extends NgDirectiveBase {
  constructor(draggable, dragDropService) {
    super();
    this.draggable = draggable;
    this.dragDropService = dragDropService;
    this.batchDragGroup = "default";
    this.batchDragActive = false;
    this.batchDragLastOneAutoActiveEventKeys = ["ctrlKey"];
    this.batchDragStyle = ["badge", "stack"];
    this.batchDragActiveEvent = new EventEmitter();
    this.needToRestore = false;
    this.draggable.batchDraggable = this;
  }
  ngOnInit() {
    this.initDragDataByIdentity();
  }
  ngOnDestroy() {
    this.draggable.batchDraggable = void 0;
    if (this.dragData) {
      if (this.dragData.draggable === this.draggable) {
        this.dragData.draggable = void 0;
        if (!this.dragData.identity) {
          this.removeFromBatchGroup();
        }
      }
    }
  }
  ngOnChanges(changes) {
    if (changes["batchDragActive"]) {
      if (!this.initDragDataByIdentity()) {
        if (this.batchDragActive) {
          if (!this.dragData && this.allowAddToBatchGroup()) {
            this.addToBatchGroup();
          }
        } else {
          this.removeFromBatchGroup();
        }
      }
    }
  }
  ngAfterViewInit() {
    if (this.needToRestore) {
      this.restoreDragDataViewAfterViewInit();
      this.needToRestore = false;
    }
  }
  initDragDataByIdentity() {
    const dragData = this.findInBatchDragDataByIdentities();
    if (dragData) {
      if (this.batchDragActive) {
        if (!this.dragData) {
          this.addToBatchGroup(dragData);
          this.registerRestoreDragDataViewAfterViewInitWhiteDragging();
        }
      } else {
        this.removeFromBatchGroup(dragData);
      }
    }
    return dragData;
  }
  registerRestoreDragDataViewAfterViewInitWhiteDragging() {
    if (this.dragDropService.draggedEl && this.dragDropService.draggedElIdentity && this.dragDropService.draggedEl !== this.draggable.el.nativeElement) {
      this.needToRestore = true;
    }
  }
  restoreDragDataViewAfterViewInit() {
    const draggable = this.draggable;
    if (draggable.originPlaceholder && draggable.originPlaceholder.show !== false) {
      draggable.insertOriginPlaceholder(true, false);
    }
    draggable.el.nativeElement.style.display = "none";
  }
  allowAddToBatchGroup() {
    if (!this.dragDropService.batchDragGroup) {
      return true;
    } else {
      return this.batchDragGroup === this.dragDropService.batchDragGroup;
    }
  }
  addToBatchGroup(dragData) {
    this.dragDropService.batchDragGroup = this.dragDropService.batchDragGroup || this.batchDragGroup;
    if (dragData) {
      dragData.draggable = this.draggable;
      dragData.dragData = this.draggable.dragData;
      this.dragData = dragData;
    } else {
      this.dragData = this.dragData || {
        identity: this.draggable.dragIdentity || void 0,
        draggable: this.draggable,
        dragData: this.draggable.dragData
      };
      this.dragDropService.batchDragData = this.addToArrayIfNotExist(this.dragDropService.batchDragData, this.dragData);
    }
  }
  removeFromBatchGroup(dragData) {
    this.deleteFromArrayIfExist(this.dragDropService.batchDragData, dragData || this.dragData);
    this.dragData = void 0;
    if (!(this.dragDropService.batchDragData && this.dragDropService.batchDragData.length)) {
      this.dragDropService.batchDragGroup = void 0;
    }
  }
  addToArrayIfNotExist(array, target) {
    array = array || [];
    if (array.indexOf(target) === -1) {
      array.push(target);
    }
    return array;
  }
  deleteFromArrayIfExist(array, target) {
    if (!array) {
      return;
    }
    if (array.length > 0) {
      const index2 = array.indexOf(target);
      if (index2 > -1) {
        array.splice(index2, 1);
      }
    }
    return array;
  }
  findInBatchDragDataByIdentities() {
    if (!this.draggable.dragIdentity) {
      return null;
    } else if (!this.dragDropService.batchDragData) {
      return void 0;
    } else {
      return this.dragDropService.batchDragData.filter((dragData) => dragData.identity === this.draggable.dragIdentity).pop();
    }
  }
  active() {
    this.batchDragActiveEvent.emit({ el: this.draggable.el.nativeElement, data: this.draggable.dragData });
  }
  updateDragData() {
    if (!this.dragData) {
      return;
    }
    Object.assign(this.dragData, {
      identity: this.draggable.dragIdentity || void 0,
      draggable: this.draggable,
      dragData: this.draggable.dragData
    });
  }
}
BatchDraggableDirective.INSTANCE_KEY = "__vueDevuiBatchDraggableDirectiveInstance";
var BatchDraggable = {
  mounted(el, binding, vNode) {
    var _a;
    const context2 = vNode["ctx"].provides;
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    const draggableDirective = injectFromContext(DraggableDirective.TOKEN, context2);
    const batchDraggableDirective = el[BatchDraggableDirective.INSTANCE_KEY] = new BatchDraggableDirective(
      draggableDirective,
      dragDropService
    );
    batchDraggableDirective.setInput(binding.value);
    batchDraggableDirective.mounted();
    (_a = batchDraggableDirective.ngOnInit) == null ? void 0 : _a.call(batchDraggableDirective);
    setTimeout(() => {
      var _a2;
      (_a2 = batchDraggableDirective.ngAfterViewInit) == null ? void 0 : _a2.call(batchDraggableDirective);
    }, 0);
  },
  updated(el, binding) {
    const batchDraggableDirective = el[BatchDraggableDirective.INSTANCE_KEY];
    batchDraggableDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const batchDraggableDirective = el[BatchDraggableDirective.INSTANCE_KEY];
    (_a = batchDraggableDirective.ngOnDestroy) == null ? void 0 : _a.call(batchDraggableDirective);
  }
};
class DragPreviewCloneDomRefComponent extends NgDirectiveBase {
  constructor(el, dragDropService) {
    super();
    __publicField(this, "copyStyle", true);
    this.el = el;
    this.dragDropService = dragDropService;
  }
  ngAfterViewInit() {
    if (!this.cloneNode) {
      this.createView();
    }
  }
  ngOnChanges(changes) {
    if (changes["domRef"]) {
      if (this.cloneNode) {
        this.destroyView();
        this.createView();
      } else {
        this.createView();
      }
    }
  }
  ngOnDestroy() {
    if (this.cloneNode) {
      this.destroyView();
    }
  }
  createView() {
    if (this.domRef) {
      this.cloneNode = this.domRef.cloneNode(true);
      if (this.copyStyle) {
        this.dragDropService.copyStyle(this.domRef, this.cloneNode);
      }
      setTimeout(() => {
        this.el.nativeElement.appendChild(this.cloneNode);
      }, 0);
    }
  }
  destroyView() {
    if (this.cloneNode) {
      if (this.el.nativeElement.contains(this.cloneNode)) {
        this.el.nativeElement.removeChild(this.cloneNode);
      }
      this.cloneNode = void 0;
    }
  }
  updateTemplate() {
  }
}
__publicField(DragPreviewCloneDomRefComponent, "NAME", "d-drag-preview-clone-dom-ref");
var DragPreviewCloneDomRef = defineComponent({
  name: "DDragPreviewCloneDomRef",
  props: {
    domRef: Object,
    copyStyle: {
      type: Boolean,
      default: true
    }
  },
  setup(props, {
    expose
  }) {
    const el = {
      nativeElement: null
    };
    const dragDropService = inject(DragDropService.TOKEN);
    const instance = new DragPreviewCloneDomRefComponent(el, dragDropService);
    instance.setInput(props);
    onMounted(() => {
      instance.mounted();
      nextTick(() => {
        var _a;
        (_a = instance.ngAfterViewInit) == null ? void 0 : _a.call(instance);
      });
    });
    watch(() => props, (binding, oldBinding) => {
      instance.updateInput(binding, oldBinding);
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = instance.ngOnDestroy) == null ? void 0 : _a.call(instance);
    });
    expose({
      instance
    });
    return () => createVNode("div", {
      "ref": (e) => el.nativeElement = e
    }, null);
  }
});
function flatten(list, dst) {
  if (dst === void 0)
    dst = list;
  for (let i = 0; i < list.length; i++) {
    let item = list[i];
    if (Array.isArray(item)) {
      if (dst === list) {
        dst = list.slice(0, i);
      }
      flatten(item, dst);
    } else if (dst !== list) {
      dst.push(item);
    }
  }
  return dst;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
const _QueryList = class {
  constructor() {
    this.dirty = true;
    this._results = [];
    this.changes = new EventEmitter();
    this.length = 0;
    const symbol = Symbol.iterator;
    const proto = _QueryList.prototype;
    if (!proto[symbol])
      proto[symbol] = symbolIterator;
  }
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  find(fn) {
    return this._results.find(fn);
  }
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  forEach(fn) {
    this._results.forEach(fn);
  }
  some(fn) {
    return this._results.some(fn);
  }
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  reset(resultsTree) {
    this._results = flatten(resultsTree);
    this.dirty = false;
    this.length = this._results.length;
    this.last = this._results[this.length - 1];
    this.first = this._results[0];
  }
  notifyOnChanges() {
    this.changes.emit(this);
  }
  setDirty() {
    this.dirty = true;
  }
  destroy() {
    this.changes.complete();
    this.changes.unsubscribe();
  }
};
let QueryList = _QueryList;
class DescendantRegisterService {
  constructor() {
    this._result = [];
    this.changeSubject = new BehaviorSubject([]);
    this.changes = this.changeSubject.asObservable().pipe(debounceTime(200));
  }
  register(t) {
    if (!t) {
      return;
    }
    const index2 = this._result.indexOf(t);
    if (index2 === -1) {
      this._result.push(t);
      this.changeSubject.next(this._result);
    }
  }
  unregister(t) {
    if (!t) {
      return;
    }
    const index2 = this._result.indexOf(t);
    if (index2 > -1) {
      this._result.splice(index2, 1);
      this.changeSubject.next(this._result);
    }
  }
  queryResult() {
    return this._result.concat([]);
  }
}
class DescendantChildren extends NgDirectiveBase {
  constructor(drs) {
    super();
    this.drs = drs;
  }
  ngOnInit() {
    this.drs.register(this.descendantItem);
  }
  ngOnDestroy() {
    this.drs.unregister(this.descendantItem);
  }
}
class DescendantRoot extends QueryList {
  constructor(drs) {
    super();
    this.drs = drs;
  }
  on() {
    if (this.sub) {
      return;
    }
    this.reset(this.drs.queryResult());
    this.sub = this.drs.changes.subscribe((result) => {
      this.reset(result);
    });
  }
  off() {
    if (this.sub) {
      this.sub.unsubscribe();
    }
  }
}
class DragSyncDescendantRegisterService extends DescendantRegisterService {
}
DragSyncDescendantRegisterService.TOKEN = Symbol("DRAG_SYNC_DR_SERVICE");
class DropSortSyncDescendantRegisterService extends DescendantRegisterService {
}
DropSortSyncDescendantRegisterService.TOKEN = Symbol("DROP_SORT_SYNC_DR_SERVICE");
class DragDropSyncService {
  updateDragSyncList(list) {
    this.dragSyncList = list;
  }
  getDragSyncByGroup(groupName) {
    if (groupName) {
      return [];
    }
    return this.dragSyncList ? this.dragSyncList.filter((dragSync) => dragSync.dragSyncGroup === groupName) : [];
  }
  updateDropSyncList(list) {
    this.dropSortSyncList = list;
  }
  getDropSyncByGroup(groupName) {
    if (groupName) {
      return [];
    }
    return this.dropSortSyncList ? this.dropSortSyncList.filter((dragSync) => dragSync.dropSyncGroup === groupName) : [];
  }
}
DragDropSyncService.TOKEN = Symbol("DRAG_DROP_SYNC_SERVICE");
class DragDropSyncBoxDirective extends NgDirectiveBase {
  constructor(dragDropSyncService, dragSyncDrs, dropSortSyncDrs) {
    super();
    this.dragDropSyncService = dragDropSyncService;
    this.dragSyncDrs = dragSyncDrs;
    this.dropSortSyncDrs = dropSortSyncDrs;
    this.sub = new Subscription();
  }
  ngOnInit() {
    this.dragSyncList = new DescendantRoot(this.dragSyncDrs);
    this.dropSyncList = new DescendantRoot(this.dropSortSyncDrs);
  }
  ngAfterViewInit() {
    this.dragSyncList.on();
    this.dropSyncList.on();
    this.dragDropSyncService.updateDragSyncList(this.dragSyncList);
    this.dragDropSyncService.updateDropSyncList(this.dropSyncList);
    this.sub.add(this.dragSyncList.changes.subscribe((list) => this.dragDropSyncService.updateDragSyncList(list)));
    this.sub.add(this.dropSyncList.changes.subscribe((list) => this.dragDropSyncService.updateDropSyncList(list)));
  }
  ngOnDestroy() {
    if (this.sub) {
      this.sub.unsubscribe();
    }
    this.dragSyncList.off();
    this.dropSyncList.off();
  }
}
DragDropSyncBoxDirective.INSTANCE_KEY = "__vueDevuiDragDropSyncBoxDirectiveInstance";
var DragDropSyncBox = {
  created(el, binding, vNode) {
    const context2 = vNode["ctx"].provides;
    const dragDropSyncService = new DragDropSyncService();
    const dragSyncDrs = new DragSyncDescendantRegisterService();
    const dropSortSyncDrs = new DropSortSyncDescendantRegisterService();
    provideToContext(DragDropSyncService.TOKEN, dragDropSyncService, context2);
    provideToContext(DragSyncDescendantRegisterService.TOKEN, dragSyncDrs, context2);
    provideToContext(DropSortSyncDescendantRegisterService.TOKEN, dropSortSyncDrs, context2);
  },
  mounted(el, binding, vNode) {
    var _a;
    const context2 = vNode["ctx"].provides;
    const dragDropSyncService = injectFromContext(DragDropSyncService.TOKEN, context2);
    const dragSyncDrs = injectFromContext(DragSyncDescendantRegisterService.TOKEN, context2);
    const dropSortSyncDrs = injectFromContext(DropSortSyncDescendantRegisterService.TOKEN, context2);
    const dragDropSyncBoxDirective = el[DragDropSyncBoxDirective.INSTANCE_KEY] = new DragDropSyncBoxDirective(
      dragDropSyncService,
      dragSyncDrs,
      dropSortSyncDrs
    );
    dragDropSyncBoxDirective.setInput(binding.value);
    dragDropSyncBoxDirective.mounted();
    (_a = dragDropSyncBoxDirective.ngOnInit) == null ? void 0 : _a.call(dragDropSyncBoxDirective);
    setTimeout(() => {
      var _a2;
      (_a2 = dragDropSyncBoxDirective.ngAfterViewInit) == null ? void 0 : _a2.call(dragDropSyncBoxDirective);
    }, 0);
  },
  updated(el, binding) {
    const dragDropSyncBoxDirective = el[DragDropSyncBoxDirective.INSTANCE_KEY];
    dragDropSyncBoxDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const dragDropSyncBoxDirective = el[DragDropSyncBoxDirective.INSTANCE_KEY];
    (_a = dragDropSyncBoxDirective.ngOnDestroy) == null ? void 0 : _a.call(dragDropSyncBoxDirective);
  }
};
class DragSyncDirective extends DescendantChildren {
  constructor(el, draggable, dragDropSyncService, dragDropService, dragSyncDrs) {
    super(dragSyncDrs);
    this.draggable = draggable;
    this.dragDropSyncService = dragDropSyncService;
    this.dragDropService = dragDropService;
    this.inputNameMap = {
      dragSync: "dragSyncGroup",
      dragSyncGroup: "dragSyncGroup"
    };
    this.dragSyncGroup = "";
    this.subscription = new Subscription();
    this.el = { nativeElement: null };
    this.subDragElEvent = (bool) => {
      this.syncGroupDirectives.forEach((dir) => this.renderDisplay(dir.el.nativeElement, bool));
    };
    this.el.nativeElement = el;
    this.descendantItem = this;
  }
  ngOnInit() {
    if (this.draggable) {
      this.subscription.add(this.draggable.dragElShowHideEvent.subscribe(this.subDragElEvent));
      this.subscription.add(
        this.draggable.beforeDragStartEvent.subscribe(() => {
          this.syncGroupDirectives = this.dragDropSyncService.getDragSyncByGroup(this.dragSyncGroup).filter((directive) => directive !== this);
          this.dragDropService.dragSyncGroupDirectives = this.syncGroupDirectives;
        })
      );
      this.subscription.add(
        this.draggable.dropEndEvent.subscribe(() => {
          this.dragDropService.dragSyncGroupDirectives = void 0;
          this.syncGroupDirectives = void 0;
        })
      );
    }
    super.ngOnInit();
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  renderDisplay(nativeEl, bool) {
    nativeEl.style.display = bool ? "" : "none";
  }
}
DragSyncDirective.INSTANCE_KEY = "__vueDevuiDragSyncDirectiveInstance";
var DragSync = {
  mounted(el, binding, vNode) {
    var _a;
    const context2 = vNode["ctx"].provides;
    let draggable = injectFromContext(DraggableDirective.TOKEN, context2);
    if ((draggable == null ? void 0 : draggable.el.nativeElement) !== el) {
      draggable = void 0;
    }
    const dragDropSyncService = injectFromContext(DragDropSyncService.TOKEN, context2);
    const dragDropService = injectFromContext(DragDropService.TOKEN, context2);
    const dragSyncDrs = injectFromContext(DragSyncDescendantRegisterService.TOKEN, context2);
    const dragSyncDirective = el[DragSyncDirective.INSTANCE_KEY] = new DragSyncDirective(
      el,
      draggable,
      dragDropSyncService,
      dragDropService,
      dragSyncDrs
    );
    dragSyncDirective.setInput(binding.value);
    dragSyncDirective.mounted();
    (_a = dragSyncDirective.ngOnInit) == null ? void 0 : _a.call(dragSyncDirective);
  },
  updated(el, binding) {
    const dragSyncDirective = el[DragSyncDirective.INSTANCE_KEY];
    dragSyncDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const dragSyncDirective = el[DragSyncDirective.INSTANCE_KEY];
    (_a = dragSyncDirective.ngOnDestroy) == null ? void 0 : _a.call(dragSyncDirective);
  }
};
class DropSortSyncDirective extends DescendantChildren {
  constructor(el, droppable, dragDropSyncService, dropSortSyncDrs) {
    super(dropSortSyncDrs);
    this.droppable = droppable;
    this.dragDropSyncService = dragDropSyncService;
    this.inputNameMap = {
      dropSortSync: "dropSyncGroup",
      dropSyncGroup: "dropSyncGroup",
      dropSyncDirection: "direction"
    };
    this.dropSyncGroup = "";
    this.direction = "v";
    this.subscription = new Subscription();
    this.el = { nativeElement: null };
    this.subRenderEvent = (nativeStyle) => {
      this.syncGroupDirectives = this.dragDropSyncService.getDropSyncByGroup(this.dropSyncGroup).filter((directive) => directive !== this);
      this.syncGroupDirectives.forEach((dir) => {
        dir.renderPlaceholder(nativeStyle, this.droppable);
      });
    };
    this.subInsertionEvent = (cmd) => {
      this.syncGroupDirectives = this.dragDropSyncService.getDropSyncByGroup(this.dropSyncGroup).filter((directive) => directive !== this);
      this.syncGroupDirectives.forEach((dir) => {
        dir.insertPlaceholderCommand({
          command: cmd.command,
          container: dir.sortContainer,
          relatedEl: dir.getChildrenElByIndex(dir.sortContainer, cmd.index)
        });
      });
    };
    this.el.nativeElement = el;
    this.descendantItem = this;
  }
  ngOnInit() {
    this.sortContainer = this.el.nativeElement;
    if (this.droppable) {
      this.sortContainer = this.droppable.getSortContainer();
      this.subscription.add(this.droppable.placeholderInsertionEvent.subscribe(this.subInsertionEvent));
      this.subscription.add(this.droppable.placeholderRenderEvent.subscribe(this.subRenderEvent));
    }
    super.ngOnInit();
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  getChildrenElByIndex(target, index2) {
    if (index2 === void 0 || target && target.children && target.children.length < index2 || index2 < 0) {
      return null;
    }
    return this.sortContainer.children.item(index2);
  }
  renderPlaceholder(nativeStyle, droppable) {
    if (!this.placeholder) {
      this.placeholder = document.createElement(droppable.placeholderTag);
      this.placeholder.className = "drag-placeholder";
      this.placeholder.classList.add("drag-sync-placeholder");
      this.placeholder.innerText = droppable.placeholderText;
    }
    const { width, height } = nativeStyle;
    if (this.direction === "v") {
      this.placeholder.style.width = width + "px";
      this.placeholder.style.height = this.sortContainer.getBoundingClientRect().height + "px";
    } else {
      this.placeholder.style.height = height + "px";
      this.placeholder.style.width = this.sortContainer.getBoundingClientRect().width + "px";
    }
    Utils.addElStyles(this.placeholder, droppable.placeholderStyle);
  }
  insertPlaceholderCommand(cmd) {
    if (cmd.command === "insertBefore" && cmd.container) {
      cmd.container.insertBefore(this.placeholder, cmd.relatedEl);
      return;
    }
    if (cmd.command === "append" && cmd.container) {
      cmd.container.appendChild(this.placeholder);
      return;
    }
    if (cmd.command === "remove" && cmd.container) {
      if (cmd.container.contains(this.placeholder)) {
        cmd.container.removeChild(this.placeholder);
      }
      return;
    }
  }
}
DropSortSyncDirective.INSTANCE_KEY = "__vueDevuiDropSortSyncDirectiveInstance";
var DropSortSync = {
  mounted(el, binding, vNode) {
    var _a;
    const context2 = vNode["ctx"].provides;
    let droppable = injectFromContext(DroppableDirective.TOKEN, context2);
    if ((droppable == null ? void 0 : droppable.el.nativeElement) !== el) {
      droppable = void 0;
    }
    const dragDropSyncService = injectFromContext(DragDropSyncService.TOKEN, context2);
    const dropSortSyncDrs = injectFromContext(
      DropSortSyncDescendantRegisterService.TOKEN,
      context2
    );
    const dropSortSyncDirective = el[DropSortSyncDirective.INSTANCE_KEY] = new DropSortSyncDirective(
      el,
      droppable,
      dragDropSyncService,
      dropSortSyncDrs
    );
    dropSortSyncDirective.setInput(binding.value);
    dropSortSyncDirective.mounted();
    (_a = dropSortSyncDirective.ngOnInit) == null ? void 0 : _a.call(dropSortSyncDirective);
  },
  updated(el, binding) {
    const dropSortSyncDirective = el[DropSortSyncDirective.INSTANCE_KEY];
    dropSortSyncDirective.updateInput(binding.value, binding.oldValue);
  },
  beforeUnmount(el) {
    var _a;
    const dropSortSyncDirective = el[DropSortSyncDirective.INSTANCE_KEY];
    (_a = dropSortSyncDirective.ngOnDestroy) == null ? void 0 : _a.call(dropSortSyncDirective);
  }
};
var useDragDropSort = {
  title: "DragDropSync \u62D6\u62FD\u540C\u6B65",
  category: "\u57FA\u7840\u7EC4\u4EF6",
  install(app) {
    app.directive("dDragDropSyncBox", DragDropSyncBox);
    app.directive("dDragSync", DragSync);
    app.directive("dDropSortSync", DropSortSync);
  }
};
var index = {
  title: "DragDrop 2.0 \u62D6\u62FD",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.directive("dDraggable", Draggable);
    app.directive("dDroppable", Droppable);
    app.directive("dSortable", Sortable);
    app.directive("dDropScrollEnhanced", DropScrollEnhanced);
    app.directive("dDropScrollEnhancedSide", DropScrollEnhancedSide);
    app.directive("dDraggableBatchDrag", BatchDraggable);
    app.directive("dDragPreview", DragPreview);
    app.component("DDragPreviewTemplate", DragPreviewTemplate);
    app.component(DragPreviewCloneDomRef.name, DragPreviewCloneDomRef);
    app.provide(DragDropService.TOKEN, new DragDropService());
    app.use(useDragDropSort);
  }
};
export { BatchDraggableDirective, DescendantChildren, DescendantRegisterService, DescendantRoot, DragDropService, DragDropSyncBox, DragDropSyncBoxDirective, DragDropSyncService, DragPreviewCloneDomRefComponent, DragPreviewComponent, DragPreviewDirective, DragPreviewTemplate, DragSync, DragSyncDescendantRegisterService, DragSyncDirective, Draggable, DraggableDirective, DropEvent, DropScrollEnhanceTimingFunctionGroup, DropScrollEnhanced, DropScrollEnhancedDirective, DropScrollEnhancedSide, DropScrollEnhancedSideDirective, DropScrollOrientation, DropSortSync, DropSortSyncDescendantRegisterService, DropSortSyncDirective, Droppable, DroppableDirective, Sortable, SortableDirective, index as default, useDragDropService };
